/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/assert/build/assert.js":
/*!*********************************************!*\
  !*** ./node_modules/assert/build/assert.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b

// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var _require = __webpack_require__(/*! ./internal/errors */ "./node_modules/assert/build/internal/errors.js"),
  _require$codes = _require.codes,
  ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
  ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var AssertionError = __webpack_require__(/*! ./internal/assert/assertion_error */ "./node_modules/assert/build/internal/assert/assertion_error.js");
var _require2 = __webpack_require__(/*! util/ */ "./node_modules/util/util.js"),
  inspect = _require2.inspect;
var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/util/util.js").types),
  isPromise = _require$types.isPromise,
  isRegExp = _require$types.isRegExp;
var objectAssign = __webpack_require__(/*! object.assign/polyfill */ "./node_modules/object.assign/polyfill.js")();
var objectIs = __webpack_require__(/*! object-is/polyfill */ "./node_modules/object-is/polyfill.js")();
var RegExpPrototypeTest = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js")('RegExp.prototype.test');
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;
function lazyLoadComparison() {
  var comparison = __webpack_require__(/*! ./internal/util/comparisons */ "./node_modules/assert/build/internal/util/comparisons.js");
  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
}

// Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex
var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];
var escapeFn = function escapeFn(str) {
  return meta[str.charCodeAt(0)];
};
var warned = false;

// The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {};

// All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}
function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;
  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }
    if (argsLen === 2) operator = '!=';
  }
  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };
  if (message !== undefined) {
    errArgs.message = message;
  }
  var err = new AssertionError(errArgs);
  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }
  throw err;
}
assert.fail = fail;

// The AssertionError is defined in internal/error.
assert.AssertionError = AssertionError;
function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;
    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }
    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}

// Pure assertion tests whether a value is truthy, as determined
// by !!value.
function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  innerOk.apply(void 0, [ok, args.length].concat(args));
}
assert.ok = ok;

// The equality assertion tests shallow, coercive equality with ==.
/* eslint-disable no-restricted-properties */
assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
};

// The non-equality assertion tests for whether two objects are not
// equal with !=.
assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
};

// The equivalence assertion tests a deep equality relation.
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
};

// The non-equivalence assertion tests for any deep inequality.
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (!objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};
var Comparison = /*#__PURE__*/_createClass(function Comparison(obj, keys, actual) {
  var _this = this;
  _classCallCheck(this, Comparison);
  keys.forEach(function (key) {
    if (key in obj) {
      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
});
function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);
      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}
function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
    // assert.doesNotThrow does not accept objects.
    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    }

    // Handle primitives properly.
    if (_typeof(actual) !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }
    var keys = Object.keys(expected);
    // Special handle errors to make sure the name and the message are compared
    // as well.
    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }
    if (isDeepEqual === undefined) lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
        return;
      }
      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  }
  // Guard instanceof against arrow functions as they don't have a prototype.
  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function getActual(fn) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL;
}
function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.

  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.

  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}
function waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;
    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn();
      // Fail in case no promise is returned.
      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }
    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}
function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }
    if (_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }
    message = error;
    error = undefined;
  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }
  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';
    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }
    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }
  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}
function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL) return;
  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }
  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }
  throw actual;
}
assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};
assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return waitForActual(promiseFn).then(function (result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};
assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};
assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  return waitForActual(fn).then(function (result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};
assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';
    if (_typeof(err) === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }
    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    });

    // Make sure we actually have a stack trace!
    var origStack = err.stack;
    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      var tmp2 = origStack.split('\n');
      tmp2.shift();
      // Filter all frames existing in err.stack.
      var tmp1 = newErr.stack.split('\n');
      for (var i = 0; i < tmp2.length; i++) {
        // Find the first occurrence of the frame.
        var pos = tmp1.indexOf(tmp2[i]);
        if (pos !== -1) {
          // Only keep new frames.
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }
      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
    }
    throw newErr;
  }
};

// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a871df3dfb8ea663ef5e1f8f62701ec51384ecb
function internalMatch(string, regexp, message, fn, fnName) {
  if (!isRegExp(regexp)) {
    throw new ERR_INVALID_ARG_TYPE('regexp', 'RegExp', regexp);
  }
  var match = fnName === 'match';
  if (typeof string !== 'string' || RegExpPrototypeTest(regexp, string) !== match) {
    if (message instanceof Error) {
      throw message;
    }
    var generatedMessage = !message;

    // 'The input was expected to not match the regular expression ' +
    message = message || (typeof string !== 'string' ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? 'The input did not match the regular expression ' : 'The input was expected to not match the regular expression ') + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
    var err = new AssertionError({
      actual: string,
      expected: regexp,
      message: message,
      operator: fnName,
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}
assert.match = function match(string, regexp, message) {
  internalMatch(string, regexp, message, match, 'match');
};
assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
  internalMatch(string, regexp, message, doesNotMatch, 'doesNotMatch');
};

// Expose a strict only variant of assert
function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  innerOk.apply(void 0, [strict, args.length].concat(args));
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

/***/ }),

/***/ "./node_modules/assert/build/internal/assert/assertion_error.js":
/*!**********************************************************************!*\
  !*** ./node_modules/assert/build/internal/assert/assertion_error.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c



function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _require = __webpack_require__(/*! util/ */ "./node_modules/util/util.js"),
  inspect = _require.inspect;
var _require2 = __webpack_require__(/*! ../errors */ "./node_modules/assert/build/internal/errors.js"),
  ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));
  while (count) {
    str += str;
    count--;
  }
  str += str.substring(0, maxCount - str.length);
  return str;
}
var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
};

// Comparing short primitives should just show === / !== instead of using the
// diff.
var kMaxShortLength = 10;
function copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}
function inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}
function createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = inspectValue(expected).split('\n');
  var i = 0;
  var indicator = '';

  // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.
  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  }

  // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.
  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length;
    // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.
    if (inputLength <= kMaxShortLength) {
      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        }
        // Ignore the first characters.
        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat(repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  }

  // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).
  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];
  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }
    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }
  var maxLines = Math.max(actualLines.length, expectedLines.length);
  // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n');

    // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.
    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);
      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }
    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }
  if (i > 3) {
    end = "\n".concat(blue, "...").concat(white).concat(end);
    skipped = true;
  }
  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }
  var printedLines = 0;
  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;
    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      }
      // Mark the current line as the last diverging one.
      lastPos = i;
      // Add the expected line to the cache.
      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++;
      // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      }
      // Mark the current line as the last diverging one.
      lastPos = i;
      // Add the actual line to the result.
      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++;
      // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i];
      // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.
      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine);
      // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //
      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }
      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        }
        // Mark the current line as the last diverging one.
        lastPos = i;
        // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.
        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2;
        // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = '';
        // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.
        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    }
    // Inspected object to big (Show ~20 rows max)
    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }
  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}
var AssertionError = /*#__PURE__*/function (_Error, _inspect$custom) {
  _inherits(AssertionError, _Error);
  var _super = _createSuper(AssertionError);
  function AssertionError(options) {
    var _this;
    _classCallCheck(this, AssertionError);
    if (_typeof(options) !== 'object' || options === null) {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }
    var message = options.message,
      operator = options.operator,
      stackStartFn = options.stackStartFn;
    var actual = options.actual,
      expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    if (message != null) {
      _this = _super.call(this, String(message));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\x1B[34m";
          green = "\x1B[32m";
          white = "\x1B[39m";
          red = "\x1B[31m";
        } else {
          blue = '';
          green = '';
          white = '';
          red = '';
        }
      }
      // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.
      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }
      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = _super.call(this, createErrDiff(actual, expected, operator));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split('\n');

        // In case "actual" is an object, it should not be reference equal.
        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        }

        // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.
        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);
          while (res.length > 27) {
            res.pop();
          }
        }

        // Only print a single input.
        if (res.length === 1) {
          _this = _super.call(this, "".concat(base, " ").concat(res[0]));
        } else {
          _this = _super.call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n"));
        }
      } else {
        var _res = inspectValue(actual);
        var other = '';
        var knownOperators = kReadableOperator[operator];
        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));
          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }
          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }
          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }
        _this = _super.call(this, "".concat(_res).concat(other));
      }
    }
    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;
    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
    }
    // Create error message including the error code in the name.
    _this.stack;
    // Reset the name.
    _this.name = 'AssertionError';
    return _possibleConstructorReturn(_this);
  }
  _createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: _inspect$custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);
  return AssertionError;
}( /*#__PURE__*/_wrapNativeSuper(Error), inspect.custom);
module.exports = AssertionError;

/***/ }),

/***/ "./node_modules/assert/build/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/assert/build/internal/errors.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

/* eslint node-core/documented-errors: "error" */
/* eslint node-core/alphabetize-errors: "error" */
/* eslint node-core/prefer-util-format-errors: "error" */



// The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var codes = {};

// Lazy loaded
var assert;
var util;
function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /*#__PURE__*/function (_Base) {
    _inherits(NodeError, _Base);
    var _super = _createSuper(NodeError);
    function NodeError(arg1, arg2, arg3) {
      var _this;
      _classCallCheck(this, NodeError);
      _this = _super.call(this, getMessage(arg1, arg2, arg3));
      _this.code = code;
      return _this;
    }
    return _createClass(NodeError);
  }(Base);
  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/assert/build/assert.js");
  assert(typeof name === 'string', "'name' must be a string");

  // determiner: 'must be' or 'must not be'
  var determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }
  var msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  // TODO(BridgeAR): Improve the output by showing `null` and similar.
  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if (util === undefined) util = __webpack_require__(/*! util/ */ "./node_modules/util/util.js");
  var inspected = util.inspect(value);
  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }
  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;
  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat(_typeof(value));
  }
  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/assert/build/assert.js");
  assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });
  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;
    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;
    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }
  return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

/***/ }),

/***/ "./node_modules/assert/build/internal/util/comparisons.js":
/*!****************************************************************!*\
  !*** ./node_modules/assert/build/internal/util/comparisons.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var regexFlagsSupported = /a/g.flags !== undefined;
var arrayFromSet = function arrayFromSet(set) {
  var array = [];
  set.forEach(function (value) {
    return array.push(value);
  });
  return array;
};
var arrayFromMap = function arrayFromMap(map) {
  var array = [];
  map.forEach(function (value, key) {
    return array.push([key, value]);
  });
  return array;
};
var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/object-is/index.js");
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
  return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(/*! is-nan */ "./node_modules/is-nan/index.js");
function uncurryThis(f) {
  return f.call.bind(f);
}
var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);
var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/util/util.js").types),
  isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
  isArrayBufferView = _require$types.isArrayBufferView,
  isDate = _require$types.isDate,
  isMap = _require$types.isMap,
  isRegExp = _require$types.isRegExp,
  isSet = _require$types.isSet,
  isNativeError = _require$types.isNativeError,
  isBoxedPrimitive = _require$types.isBoxedPrimitive,
  isNumberObject = _require$types.isNumberObject,
  isStringObject = _require$types.isStringObject,
  isBooleanObject = _require$types.isBooleanObject,
  isBigIntObject = _require$types.isBigIntObject,
  isSymbolObject = _require$types.isSymbolObject,
  isFloat32Array = _require$types.isFloat32Array,
  isFloat64Array = _require$types.isFloat64Array;
function isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;
  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  }
  // The maximum size for an array is 2 ** 32 -1.
  return key.length === 10 && key >= Math.pow(2, 32);
}
function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
}

// Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3;

// Check if they have the same source and flags
function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }
  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }
  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }
  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }
  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
}

// Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.

function innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? objectIs(val1, val2) : true;
  }

  // Check more closely if val1 and val2 are equal.
  if (strict) {
    if (_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
    }
    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof(val1) !== 'object') {
      if (val2 === null || _typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }
      return false;
    }
    if (val2 === null || _typeof(val2) !== 'object') {
      return false;
    }
  }
  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }
    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  }
  // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.
  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }
  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp(val1)) {
    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    }
    // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.
    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (_keys.length !== _keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }
  return keyCheck(val1, val2, strict, memos, kNoIterator);
}
function getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return propertyIsEnumerable(val, k);
  });
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2);

    // The pair must have the same number of owned properties.
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }

  // Cheap key test
  var i = 0;
  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }
  if (strict && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      var count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];
        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }
          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }
      var symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  }

  // Use memos to handle cycles.
  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];
    if (innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }
  return false;
}

// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').
function findLooseMatchingPrimitives(prim) {
  switch (_typeof(prim)) {
    case 'undefined':
      return null;
    case 'object':
      // Only pass in null as object!
      return undefined;
    case 'symbol':
      return false;
    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through
    case 'number':
      if (numberIsNaN(prim)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}
function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = b.get(altValue);
  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }
  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}
function setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = arrayFromSet(a);
  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i];
    // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.
    if (_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      }
      // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.
      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false;

      // Fast path to detect missing string, symbol, undefined and null values.
      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }
      if (set === null) {
        set = new Set();
      }
      set.add(val);
    }
  }
  if (set !== null) {
    var bValues = arrayFromSet(b);
    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i];
      // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.
      if (_typeof(_val) === 'object' && _val !== null) {
        if (!setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];
    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}
function mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = arrayFromMap(a);
  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2),
      key = _aEntries$i[0],
      item1 = _aEntries$i[1];
    if (_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }
      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);
      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false;
        // Fast path to detect missing string, symbol, undefined and null
        // keys.
        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
        if (set === null) {
          set = new Set();
        }
        set.add(key);
      }
    }
  }
  if (set !== null) {
    var bEntries = arrayFromMap(b);
    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
        _key = _bEntries$_i[0],
        item = _bEntries$_i[1];
      if (_typeof(_key) === 'object' && _key !== null) {
        if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;
  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty(a, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);
        for (; i < keysA.length; i++) {
          var key = keysA[i];
          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }
        if (keysA.length !== Object.keys(b).length) {
          return false;
        }
        return true;
      }
    }
  }

  // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:
  for (i = 0; i < keys.length; i++) {
    var _key2 = keys[i];
    if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
      return false;
    }
  }
  return true;
}
function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}
function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}
module.exports = {
  isDeepEqual: isDeepEqual,
  isDeepStrictEqual: isDeepStrictEqual
};

/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var setFunctionLength = __webpack_require__(/*! set-function-length */ "./node_modules/set-function-length/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");
var $max = GetIntrinsic('%Math.max%');

module.exports = function callBind(originalFunction) {
	if (typeof originalFunction !== 'function') {
		throw new $TypeError('a function is required');
	}
	var func = $reflectApply(bind, $call, arguments);
	return setFunctionLength(
		func,
		1 + $max(0, originalFunction.length - (arguments.length - 1)),
		true
	);
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/console-browserify/index.js":
/*!**************************************************!*\
  !*** ./node_modules/console-browserify/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*global window, global*/
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js")
var assert = __webpack_require__(/*! assert */ "./node_modules/assert/build/assert.js")
function now() { return new Date().getTime() }

var slice = Array.prototype.slice
var console
var times = {}

if (typeof __webpack_require__.g !== "undefined" && __webpack_require__.g.console) {
    console = __webpack_require__.g.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"],
    [info, "info"],
    [warn, "warn"],
    [error, "error"],
    [time, "time"],
    [timeEnd, "timeEnd"],
    [trace, "trace"],
    [dir, "dir"],
    [consoleAssert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    delete times[label]
    var duration = now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function consoleAssert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}


/***/ }),

/***/ "./node_modules/define-data-property/index.js":
/*!****************************************************!*\
  !*** ./node_modules/define-data-property/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");

var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");

var gopd = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};


/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keys = __webpack_require__(/*! object-keys */ "./node_modules/object-keys/index.js");
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty = __webpack_require__(/*! define-data-property */ "./node_modules/define-data-property/index.js");

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var supportsDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();

var defineProperty = function (object, name, value, predicate) {
	if (name in object) {
		if (predicate === true) {
			if (object[name] === value) {
				return;
			}
		} else if (!isFunction(predicate) || !predicate()) {
			return;
		}
	}

	if (supportsDescriptors) {
		defineDataProperty(object, name, value, true);
	} else {
		defineDataProperty(object, name, value);
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ "./node_modules/es-define-property/index.js":
/*!**************************************************!*\
  !*** ./node_modules/es-define-property/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

/** @type {import('.')} */
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ "./node_modules/es-errors/eval.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/eval.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ "./node_modules/es-errors/index.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ "./node_modules/es-errors/range.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/range.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ "./node_modules/es-errors/ref.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/ref.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ "./node_modules/es-errors/syntax.js":
/*!******************************************!*\
  !*** ./node_modules/es-errors/syntax.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ "./node_modules/es-errors/type.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/type.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ "./node_modules/es-errors/uri.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/uri.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ "./node_modules/for-each/index.js":
/*!****************************************!*\
  !*** ./node_modules/for-each/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(/*! is-callable */ "./node_modules/is-callable/index.js");

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Error = __webpack_require__(/*! es-errors */ "./node_modules/es-errors/index.js");
var $EvalError = __webpack_require__(/*! es-errors/eval */ "./node_modules/es-errors/eval.js");
var $RangeError = __webpack_require__(/*! es-errors/range */ "./node_modules/es-errors/range.js");
var $ReferenceError = __webpack_require__(/*! es-errors/ref */ "./node_modules/es-errors/ref.js");
var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $URIError = __webpack_require__(/*! es-errors/uri */ "./node_modules/es-errors/uri.js");

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var hasProto = __webpack_require__(/*! has-proto */ "./node_modules/has-proto/index.js")();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/hasown/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/gopd/index.js":
/*!************************************!*\
  !*** ./node_modules/gopd/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/has-property-descriptors/index.js":
/*!********************************************************!*\
  !*** ./node_modules/has-property-descriptors/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ "./node_modules/has-proto/index.js":
/*!*****************************************!*\
  !*** ./node_modules/has-proto/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


var test = {
	__proto__: null,
	foo: {}
};

var $Object = Object;

/** @type {import('.')} */
module.exports = function hasProto() {
	// @ts-expect-error: TS errors on an inherited property for some reason
	return { __proto__: test }.foo === test.foo
		&& !(test instanceof $Object);
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ "./node_modules/hasown/index.js":
/*!**************************************!*\
  !*** ./node_modules/hasown/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ "./node_modules/is-callable/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-callable/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};


/***/ }),

/***/ "./node_modules/is-generator-function/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};


/***/ }),

/***/ "./node_modules/is-nan/implementation.js":
/*!***********************************************!*\
  !*** ./node_modules/is-nan/implementation.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


/***/ }),

/***/ "./node_modules/is-nan/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-nan/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/is-nan/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/is-nan/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/is-nan/shim.js");

var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/is-nan/polyfill.js":
/*!*****************************************!*\
  !*** ./node_modules/is-nan/polyfill.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/is-nan/implementation.js");

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};


/***/ }),

/***/ "./node_modules/is-nan/shim.js":
/*!*************************************!*\
  !*** ./node_modules/is-nan/shim.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/is-nan/polyfill.js");

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, {
		isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/is-typed-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/which-typed-array/index.js");

/** @type {import('.')} */
module.exports = function isTypedArray(value) {
	return !!whichTypedArray(value);
};


/***/ }),

/***/ "./node_modules/object-is/implementation.js":
/*!**************************************************!*\
  !*** ./node_modules/object-is/implementation.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



/***/ }),

/***/ "./node_modules/object-is/index.js":
/*!*****************************************!*\
  !*** ./node_modules/object-is/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/object-is/shim.js");

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/object-is/polyfill.js":
/*!********************************************!*\
  !*** ./node_modules/object-is/polyfill.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


/***/ }),

/***/ "./node_modules/object-is/shim.js":
/*!****************************************!*\
  !*** ./node_modules/object-is/shim.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js"); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js");

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ "./node_modules/object-keys/implementation.js");

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ "./node_modules/object.assign/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/object.assign/implementation.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// modified from https://github.com/es-shims/es6-shim
var objectKeys = __webpack_require__(/*! object-keys */ "./node_modules/object-keys/index.js");
var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/has-symbols/shams.js")();
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var toObject = Object;
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

// eslint-disable-next-line no-unused-vars
module.exports = function assign(target, source1) {
	if (target == null) { throw new TypeError('target must be an object'); }
	var to = toObject(target); // step 1
	if (arguments.length === 1) {
		return to; // step 2
	}
	for (var s = 1; s < arguments.length; ++s) {
		var from = toObject(arguments[s]); // step 3.a.i

		// step 3.a.ii:
		var keys = objectKeys(from);
		var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
		if (getSymbols) {
			var syms = getSymbols(from);
			for (var j = 0; j < syms.length; ++j) {
				var key = syms[j];
				if ($propIsEnumerable(from, key)) {
					$push(keys, key);
				}
			}
		}

		// step 3.a.iii:
		for (var i = 0; i < keys.length; ++i) {
			var nextKey = keys[i];
			if ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2
				var propValue = from[nextKey]; // step 3.a.iii.2.a
				to[nextKey] = propValue; // step 3.a.iii.2.b
			}
		}
	}

	return to; // step 4
};


/***/ }),

/***/ "./node_modules/object.assign/polyfill.js":
/*!************************************************!*\
  !*** ./node_modules/object.assign/polyfill.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object.assign/implementation.js");

var lacksProperEnumerationOrder = function () {
	if (!Object.assign) {
		return false;
	}
	/*
	 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	 * note: this does not detect the bug unless there's 20 characters
	 */
	var str = 'abcdefghijklmnopqrst';
	var letters = str.split('');
	var map = {};
	for (var i = 0; i < letters.length; ++i) {
		map[letters[i]] = letters[i];
	}
	var obj = Object.assign({}, map);
	var actual = '';
	for (var k in obj) {
		actual += k;
	}
	return str !== actual;
};

var assignHasPendingExceptions = function () {
	if (!Object.assign || !Object.preventExtensions) {
		return false;
	}
	/*
	 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	 * which is 72% slower than our shim, and Firefox 40's native implementation.
	 */
	var thrower = Object.preventExtensions({ 1: 2 });
	try {
		Object.assign(thrower, 'xy');
	} catch (e) {
		return thrower[1] === 'y';
	}
	return false;
};

module.exports = function getPolyfill() {
	if (!Object.assign) {
		return implementation;
	}
	if (lacksProperEnumerationOrder()) {
		return implementation;
	}
	if (assignHasPendingExceptions()) {
		return implementation;
	}
	return Object.assign;
};


/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;


/***/ }),

/***/ "./node_modules/possible-typed-array-names/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/possible-typed-array-names/index.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = [
	'Float32Array',
	'Float64Array',
	'Int8Array',
	'Int16Array',
	'Int32Array',
	'Uint8Array',
	'Uint8ClampedArray',
	'Uint16Array',
	'Uint32Array',
	'BigInt64Array',
	'BigUint64Array'
];


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/set-function-length/index.js":
/*!***************************************************!*\
  !*** ./node_modules/set-function-length/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var define = __webpack_require__(/*! define-data-property */ "./node_modules/define-data-property/index.js");
var hasDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/support/types.js":
/*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(/*! is-arguments */ "./node_modules/is-arguments/index.js");
var isGeneratorFunction = __webpack_require__(/*! is-generator-function */ "./node_modules/is-generator-function/index.js");
var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/which-typed-array/index.js");
var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/is-typed-array/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(/*! ./support/types */ "./node_modules/util/support/types.js");

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


/***/ }),

/***/ "./node_modules/which-typed-array/index.js":
/*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! for-each */ "./node_modules/for-each/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/available-typed-arrays/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

/** @type {(O: object) => string} */
var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};

/** @typedef {(receiver: import('.').TypedArray) => string | typeof Uint8Array.prototype.slice.call | typeof Uint8Array.prototype.set.call} Getter */
/** @type {{ [k in `\$${import('.').TypedArrayName}`]?: Getter } & { __proto__: null }} */
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			// @ts-expect-error TS won't narrow inside a closure
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				// @ts-expect-error TS won't narrow inside a closure
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			// @ts-expect-error TODO: fix
			cache['$' + typedArray] = callBind(descriptor.get);
		}
	});
} else {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		var fn = arr.slice || arr.set;
		if (fn) {
			// @ts-expect-error TODO: fix
			cache['$' + typedArray] = callBind(fn);
		}
	});
}

/** @type {(value: object) => false | import('.').TypedArrayName} */
var tryTypedArrays = function tryAllTypedArrays(value) {
	/** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;
	forEach(
		// eslint-disable-next-line no-extra-parens
		/** @type {Record<`\$${TypedArrayName}`, Getter>} */ /** @type {any} */ (cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
		function (getter, typedArray) {
			if (!found) {
				try {
				// @ts-expect-error TODO: fix
					if ('$' + getter(value) === typedArray) {
						found = $slice(typedArray, 1);
					}
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {(value: object) => false | import('.').TypedArrayName} */
var trySlices = function tryAllSlices(value) {
	/** @type {ReturnType<typeof tryAllSlices>} */ var found = false;
	forEach(
		// eslint-disable-next-line no-extra-parens
		/** @type {Record<`\$${TypedArrayName}`, Getter>} */ /** @type {any} */ (cache),
		/** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */ function (getter, name) {
			if (!found) {
				try {
					// @ts-expect-error TODO: fix
					getter(value);
					found = $slice(name, 1);
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {import('.')} */
module.exports = function whichTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		/** @type {string} */
		var tag = $slice($toString(value), 8, -1);
		if ($indexOf(typedArrays, tag) > -1) {
			return tag;
		}
		if (tag !== 'Object') {
			return false;
		}
		// node < 0.6 hits here on real Typed Arrays
		return trySlices(value);
	}
	if (!gOPD) { return null; } // unknown engine
	return tryTypedArrays(value);
};


/***/ }),

/***/ "?a348":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?d87b":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?c221":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/available-typed-arrays/index.js":
/*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var possibleNames = __webpack_require__(/*! possible-typed-array-names */ "./node_modules/possible-typed-array-names/index.js");

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

/** @type {import('.')} */
module.exports = function availableTypedArrays() {
	var /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			// @ts-expect-error
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};


/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/parser.js */ "./lib/parser.js");
/* harmony import */ var _lib_lexer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/lexer.js */ "./lib/lexer.js");
/* harmony import */ var _lib_relic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/relic.js */ "./lib/relic.js");
/* harmony import */ var _lib_helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/helpers.js */ "./lib/helpers.js");
/* harmony import */ var _lib_sourcemaps_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/sourcemaps.js */ "./lib/sourcemaps.js");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! fs */ "?c221");










_lib_relic_js__WEBPACK_IMPORTED_MODULE_2__["default"].lexer = {
  options: {
    ranges: true
  },
  yylloc: { first_line: 0, first_column: 0, last_column: 0, last_line: 0 },
  lex() {
    var tag, token;
    token = _lib_relic_js__WEBPACK_IMPORTED_MODULE_2__["default"].tokens[this.pos];
    this.pos = this.pos + 1;

    if (token) {
      tag = token[0];
      this.yytext = token[1];
      this.yylloc = token[2];

      _lib_relic_js__WEBPACK_IMPORTED_MODULE_2__["default"].errorToken = token;
    } else {
      tag = '';
    }

    return tag;
  },
  setInput(tokens) {
    _lib_relic_js__WEBPACK_IMPORTED_MODULE_2__["default"].tokens = tokens;
    return this.pos = 0;
  },
  upcomingInput() {
    return '';
  }
};

for (var i = 0, keys = Object.keys(_lib_parser_js__WEBPACK_IMPORTED_MODULE_0__.Nodes); i < keys.length; i++) {
  var key = keys[i];
  _lib_relic_js__WEBPACK_IMPORTED_MODULE_2__["default"].yy[key] = _lib_parser_js__WEBPACK_IMPORTED_MODULE_0__.Nodes[key];
}

_lib_relic_js__WEBPACK_IMPORTED_MODULE_2__["default"].yy.parseError = function (message, holder, JisonErr) {
  let token = holder.parser.errorToken, symbol;
  if (!(symbol = token.origin || token[2].origin)) {
    symbol = token[0];
  }
  
  if (symbol === "INDENT") {
    token[2].first_line++;
    token[2].first_column = 1;
    token[2].last_column = token[1].split(/\n/g).pop().length + 1;
  }

  resolveToken(token);

  let err = new (JisonErr || SyntaxError)('unexpected ' + symbol.toLowerCase());

  err.toString = _lib_helpers_js__WEBPACK_IMPORTED_MODULE_3__.errorToString;
  err.location = token[2];
  err.stack = err.toString();
  err.token = token;
  err.isCompilerError = true;
  throw err;
}

/**
 * The compiler
 */
class Relic {
  /**
   * Compile a string
   * @param {string} script 
   * @param {object} options
   * @returns {object}
   */
  constructor(script, options) {
    return Relic.compile(script, options);
  }

  /**
   * 
   * @param {String} script The code or path to file
   * @param {Object} options
   */
  static compile(script, options = {}, { nodes: _oldNodes, tokens: _oldTokens, comments: _oldComments, names: _oldNames } = {}) {
    return prettyPrint(() => {
      if (!options.tabSize) {
        options.tabSize = (0,_lib_helpers_js__WEBPACK_IMPORTED_MODULE_3__.guessIndentation)(script).tabSize;
      }

      var result = {}, tokens, nodes, comments, names, filename;

      filename = options.filename || '<anonymous>';

      if (typeof options.dirname !== "string") {
        if (typeof __dirname !== "undefined") options.dirname = __dirname;
        else options.dirname = '';
      }

      if (!_oldTokens) {
        var lexed = new _lib_lexer_js__WEBPACK_IMPORTED_MODULE_1__["default"](script, options);
        tokens = lexed.tokens;
        comments = lexed.comments;
        names = lexed.names;
        if (!options.omitTypeScript && lexed.isTypeScript) options.isTypeScript = true;

        result.tokens = tokens;

        tokens.script = script;

        result.nodes = nodes = Relic.parseTokens(tokens);
      } else {
        comments = _oldComments;
        nodes = _oldNodes;
        names = _oldNames;
        tokens = _oldTokens;

        result.tokens = tokens;
        result.nodes = nodes;
      }

      if (options.nodes) return result;

      options.scope = names;
      let { js, sources, isTypeScript, isJSX } = new _lib_parser_js__WEBPACK_IMPORTED_MODULE_0__.Parser(nodes, { comments, ...options }).parse(options);

      let sourceMap;
      if (sources.length) {
        var ln = sources.length, stack = 0;
        var match;
        while (match = /\/\*@[0-9a-f]{18}\*\//g.exec(js.slice(stack))) {
          var str = match[0];
          var d = stack + match.index;
          var ind = sources.findIndex(src => src[0] === str);
          var source = sources[ind];

          if (source && source.length) {
            let x, y;
            x = js.slice(0, d).split(/\n/g).pop().length;
            y = count(js.slice(0, d), '\n');

            sources[ind] = {
              sourceLine: source[1].first_line - 1,
              sourceColumn: source[1].first_column - 1,
              lastSourceColumn: source[1].last_column - 1,
              lastSourceLine: source[1].last_line - 1,
              line: y,
              column: x,
              source: source[1].source,
              sourceName: source[1].sourceName
            }

            js = js.slice(0, d) + js.slice(d).replace(str, "");
          }

          stack += match.index;
        }

        sourceMap = new _lib_sourcemaps_js__WEBPACK_IMPORTED_MODULE_4__.SourceMap(sources).generate({ generatedFile: options.generatedFile, sourceMap: options.inlineMap ? script : undefined, ...options }, script);
      }

      result.sourceMap = sourceMap;      
      result.output = js;
      result.sources = sources;
      result.isTypeScript = isTypeScript;
      result.isJSX = isJSX;
      return result;
    })(script, options);
  }

  static parseTokens(tokens) {
    return _lib_relic_js__WEBPACK_IMPORTED_MODULE_2__["default"].parse(tokens);
  }

  static toJSON(ELSON, options = {}) {
    return JSON.parse(Relic.compile(ELSON, { ...options, isELSON: true }).output);
  }
}

Relic.Lexer = _lib_lexer_js__WEBPACK_IMPORTED_MODULE_1__["default"];

function prettyPrint(cb) {
  return function (script, options) {
    try {
      return cb.call(this, script, options)
    } catch (err) {
      let ref;
      if (!err.isCompilerError && !(err instanceof _lib_helpers_js__WEBPACK_IMPORTED_MODULE_3__.RelicError)) throw err;
      if (typeof script !== "string") throw err;
      if (err.isCompilerError) err.type = "SyntaxError";

      if ((typeof window == "undefined" || typeof self == "undefined") && err.token && (ref = err.token[2].src) !== options.src && ref || ((ref = err.src) !== options.src) && ref && ref !== '<anonymous>') {
        let __file;
        if ((0,path__WEBPACK_IMPORTED_MODULE_5__.isAbsolute)(ref)) __file = ref;
        else {
          __file = (0,path__WEBPACK_IMPORTED_MODULE_5__.join)(options.dirname, ref);
          if (!(0,fs__WEBPACK_IMPORTED_MODULE_6__.existsSync)(__file) && ref.includes(path__WEBPACK_IMPORTED_MODULE_5__.sep)) {
            __file = (0,path__WEBPACK_IMPORTED_MODULE_5__.join)(options.dirname, ref.split(path__WEBPACK_IMPORTED_MODULE_5__.sep).slice(1).join(path__WEBPACK_IMPORTED_MODULE_5__.sep))
          }
        }

        script = (0,fs__WEBPACK_IMPORTED_MODULE_6__.existsSync)(__file) ? (0,fs__WEBPACK_IMPORTED_MODULE_6__.readFileSync)(__file, { encoding: 'utf-8' }) : script;
        options.src = ref;
      }

      err = (0,_lib_helpers_js__WEBPACK_IMPORTED_MODULE_3__.updateSyntaxError)(err, script, options.src);

      throw err;
    }
  }
}

function count(string, substr) {
  var num, pos;
  num = pos = 0;
  if (!substr.length) {
    return 1 / 0;
  }
  while (pos = 1 + string.indexOf(substr, pos)) {
    num++;
  }
  return num;
};

function resolveToken(token) {
  switch (true) {
    case token[0] === "[" && token.generated: {
      token[0] = 'implicit array';
      break;
    };
    case token[0] === "CALL_START" && token.generated: {
      token[0] = 'implicit call';
      break;
    };
    case token[0] === "NEWLINE": {
      token[0] = 'end of line or expression';
      break;
    }
    default: {
      return;
    }
  }
}

if (typeof module !== "undefined" && typeof require === "function") {
  module.exports = Relic;
}

if (typeof window !== "undefined") {
  window.Relic = Relic;
}

if (typeof self !== "undefined") {
  self.Relic = Relic;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Relic);

/***/ }),

/***/ "./lib/grammar.js":
/*!************************!*\
  !*** ./lib/grammar.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const grammar = {};
let wrapped = {};
let u = function (group, rules) {
  grammar[group] = [];
  for (let [rule, ...actions] of rules) {
    let options;
    grammar[group].push([rule, "$$ = " + function () {
      let _len = rule.length === 0 && group !== "Root" ? 0 : rule.split(" ").length;
      if (typeof actions[actions.length - 1] == "object") {
        options = actions.pop();
      } else {
        options = {
          origin: _len === 1 ? 1 : undefined
        };
      }
      let soak = x => `@${x} && @${x}`;
      let actionDefault = _len > 0 ? `new yy["${group}"]("${rule}", ...[$1]).setLocation({ first_line: @1.first_line, first_column: @1.first_column, last_line: @${_len}.last_line, last_column: @${_len}.last_column, src: @1.src, type: @1.type${options.origin ? `, origin: ${soak(options.origin)}.origin` : ''} }).setTokens(${Array.from({
        length: _len
      }).map((_, ind) => {
        return `["${rule.split(" ")[ind]}", @${ind}]`;
      }).join(', ')})` : `undefined`;
      if (!actions.length) {
        return actions = [actionDefault];
      }
      let {
        first,
        last
      } = options = Object.assign({
        first: _len === 0 && group !== "Root" ? 0 : 1,
        last: _len,
        typeOf: _len === 0 && group !== "Root" ? 0 : 1,
        checkGenerated: false
      }, options);
      let action = actions.pop();
      if (!action) {
        action = actionDefault;
      }
      let loc = `{ first_line: ${soak(first)}.first_line, first_column: ${soak(first)}.first_column, last_line: ${soak(last)}.last_line, last_column: ${soak(last)}.last_column, src: ${soak(first)}.src${options.typeOf === undefined || options.typeOf !== 0 ? `, type: ${soak(options.typeOf)}.type || ${soak(first)}.type` : ''}${options.origin ? `, origin: ${soak(options.origin)}.origin` : ''} }`;
      actions.push(typeof action === "function" ? action.toString().replace(/new /g, 'new yy.').replace(/Block\.wrap\(/g, 'yy.Block.wrap(').replace(/function\s*\(\)\s*\{\s*(?:return)?(.*)\s*\}|\(\)\s*=>\s*\{?\s*(?:return)?(.*)\s*\}?/i, "$1").trim() : `Object.assign(new yy["${group}"]("${rule}", ...[${action}]), { rule: "${rule}", loc: ${loc} }, ${options ? JSON.stringify(Object.assign(options)) : "{}"}, { generated: ${options.checkGenerated ? `@${options.checkGenerated}.generated` : `undefined`}${options.indentOf !== undefined ? `, indented: @${options.indentOf}.indented` : ``} }).setTokens(${Array.from({
        length: _len
      }).map((_, ind) => {
        return `["${rule.split(" ")[ind]}", @${ind + 1}]`;
      }).join(', ')})`);
      return actions;
    }().join(' && '), options || {}]);
  }
};
u(`Root`, [[``, `'EMPTY'`], [`Body`]]);
u(`Body`, [[`Body NEWLINE Line`, `$1.push($3)`], [`Body NEWLINE`], [`Line`, `[$1]`]]);
u(`ClassBody`, [[`ClassBody NEWLINE ClassLine`, `$1.push($3)`], [`ClassBody NEWLINE`], [`ClassLine`, `[$1]`]]);

// Overriding automatic function because I`m silly
grammar[`Body`][0][1] = grammar[`ClassBody`][0][1] = `($1[1] = [...$1[1], Object.assign($3, { lineCount: $2 })]) && Object.assign($1, { loc: { first_line: @1.first_line, last_line: @3.last_line, first_column: @1.first_column, last_column: @3.last_column } })`;
grammar[`Body`][1][1] = grammar[`ClassBody`][1][1] = `$$ = Object.assign($1[1][$1[1].length - 1], { lineCount: $2 }) && Object.assign($1, { loc: { first_line: @1.first_line, last_line: @2.last_line, first_column: @1.first_column, last_column: @2.last_column } })`;
u(`Line`, [[`Statement`], [`Expression`]]);
u(`ClassLine`, [[`Statement`], [`Expression`], [`ClassFunction`]]);
u(`Expression`, [[`While`], [`For`], [`Switch`], [`TryBlock`], [`Class`], [`Code`], [`Label`], [`Value`], [`JSX`], [`If`], [`Operation`], [`Assign`]]);
u(`Operation`, [[`MathPrefix Expression`, `$1, $2`], [`Expression MathPostfix`, `$1, $2`], [`Expression Operator Expression`, `$1, $2, $3`], [`@ Value`, `$2`], [`DO Expression`, `$2`], [`WHETHER Expression`, `$2`], [`TYPEOF Expression`, `$2`], [`AWAIT Expression`, `$2`], [`AWAIT INDENT Expression OUTDENT`, `$3`], [`VOID Expression`, `$2`], [`VOID INDENT Expression OUTDENT`, `$3`], [`YIELD Expression`, `$2`], [`YIELD INDENT Expression OUTDENT`, `$3`], [`Expression EXISTS`, `$1`], [`Expression SYMBOL_EXISTS`, `$1`], [`Expression Compare Expression`, `$1, $2, $3`], [`Expression Logical Expression`, `$1, $2, $3`], [`Expression INCLUDES Expression`, `$1, $3`], [`Expression MATH_BIN Expression`, `$1, $2, $3`], [`Expression Multicheck`, `$1, $2.contents`], [`Multicondition`, `null, $1.contents`], [`Expression CHAIN Expression`, `$1, $3, /then\\?|\\?>/.test($2.origin || '')`], [`Expression CHAIN Block`, `$1, $3, /then\\?|\\?>/.test($2.origin || '')`]]);
u(`Clause`, [[`Clause COMPOUND_AND Compare Expression`, `...$1.contents, [$4, $3]`], [`Expression`, `[$1]`], [`Compare Expression`, `[$2, $1]`]]);
u(`MathPrefix`, [[`++`], [`--`], [`+`], [`-`], [`~`], [`~~`], [`NOT`], [`!`]]);
u(`MathPostfix`, [[`++`], [`--`]]);
u(`Operator`, [[`*`], [`**`], [`+`], [`PLUS`], [`-`], [`DIVISION`], [`%`], [`<<`], [`>>`], [`>>>`], [`^`]]);
u(`Compare`, [[`IS`], [`===`], [`ISNT`], [`!==`], [`==`], [`!=`], [`>=`], [`<=`], [`>`], [`<`], [`INSTANCEOF`]]);
u(`Logical`, [[`AND`], [`OR`], [`||`], [`&&`], [`|`], [`&`], [`??`]]);
u(`Multicheck`, [[`MulticheckCombinations MulticheckClauses`, `$1.rule, $2`]]);
u(`Multicondition`, [[`EITHER MulticheckClauses`, `$1, $2`]]);
u(`MulticheckCombinations`, [[`IS EITHER`], [`ISNT EITHER`]]);
u(`MulticheckClauses`, [[`MulticheckClauses EITHER_OR Clause`, `...$1.contents, $3`], [`Clause`, `$1`]]);
u(`Block`, [[`{{ }}`, `yy.Block.wrap()`], [`INDENT OUTDENT`, `yy.Block.wrap()`], [`{{ INDENT OUTDENT }}`, `yy.Block.wrap()`], [`INDENT Body OUTDENT`, `$2`], [`{{ INDENT Body OUTDENT }}`, `$3`], [`{ Body }`, `$2`]]);
u(`Code`, [[`FUNC_DIRECTIVE Expression`, `null, $1, $2`], [`WITHIN PARAM_START ParamList PARAM_END Block`, `$3, '=>', $5`], [`PARAM_START ParamList PARAM_END FUNC_DIRECTIVE Block`, `$2, $4, $5`], [`PARAM_START PARAM_END FUNC_DIRECTIVE Block`, `null, $3, $4`], [`PARAM_START ParamList PARAM_END FUNC_DIRECTIVE Expression`, `$2, $4, $5`], [`PARAM_START PARAM_END FUNC_DIRECTIVE Expression`, `null, $3, $4`], [`WITHIN PARAM_START ParamList PARAM_END THEN Block`, `$3, '=>', $5`], [`WITHIN PARAM_START ParamList PARAM_END Expression`, `$3, '=>', $5`], [`WITHIN PARAM_START ParamList PARAM_END THEN Expression`, `$3, '=>', $6`], [`WITHIN PARAM_START PARAM_END Block`, `null, '=>', $4`], [`WITHIN PARAM_START PARAM_END THEN Block`, `null, '=>', $5`], [`WITHIN PARAM_START PARAM_END Expression`, `null, '=>', $4`], [`WITHIN PARAM_START PARAM_END THEN Expression`, `null, '=>', $5`], [`WITHIN Block`, `null, '=>', $2`], [`ASYNC Code`, `...$2.contents`, {
  async: true
}]]);
u(`Label`, [[`USING Identifier THEN Expression`, `$2, yy.Block.wrap($4)`], [`USING Identifier THEN Statement`, `$2, yy.Block.wrap($4)`], [`USING Identifier Block`, `$2, $3`]]);
u(`Class`, [[`CLASS Identifier ClassConstructor? ClassImplements?`, `$2, false, false, @1.origin === "class*", $3.unwrap, $4.unwrap`, {
  last: 2
}], [`CLASS Identifier ClassConstructor? ClassImplements? ClassBlock`, `$2, false, $5[1], @1.origin === "class*", $3.unwrap, $4.unwrap`], [`CLASS Identifier ClassConstructor? ClassImplements? THEN ClassBlock`, `$2, false, $6[1], @1.origin === "class*", $3.unwrap, $4.unwrap`], [`CLASS ClassConstructor? ClassImplements? ClassBlock`, `undefined, false, $4[1], @1.origin === "class*", $2.unwrap, $3.unwrap`], [`CLASS ClassConstructor? ClassImplements? THEN ClassBlock`, `undefined, false, $5[1], @1.origin === "class*", $2.unwrap, $3.unwrap`], [`CLASS Identifier ClassConstructor? EXTENDS Value ClassImplements? ClassBlock`, `$2, $5, $7[1], @1.origin === "class*", $3.unwrap, $6.unwrap`], [`CLASS Identifier ClassConstructor? EXTENDS Value ClassImplements? THEN ClassBlock`, `$2, $5, $8[1], @1.origin === "class*", $3.unwrap, $6.unwrap`], [`CLASS ClassConstructor? EXTENDS Value ClassImplements? ClassBlock`, `undefined, $4, $6[1], @1.origin === "class*", $2.unwrap, $5.unwrap`], [`CLASS Identifier ClassConstructor? EXTENDS Value ClassImplements?`, `$2, $5, false, @1.origin === "class*", $3.unwrap, $6.unwrap`, {
  last: 5
}], [`CLASS ClassConstructor? EXTENDS Value ClassImplements?`, `undefined, $4,false, @1.origin === "class*", $2.unwrap, $5.unwrap`, {
  last: 4
}], [`CLASS ClassConstructor? EXTENDS Value ClassImplements? THEN ClassBlock`, `undefined, $4, $7[1], @1.origin === "class*", $2.unwrap, $5.unwrap`], [`CLASS ClassConstructor? ClassImplements?`, `,,,@1.origin === "class*", $2.unwrap, $3.unwrap`, {
  last: 1
}]]);
u(`ClassBlock`, [[`{{ }}`, `yy.Block.wrap()`], [`INDENT OUTDENT`, `yy.Block.wrap()`], [`{{ INDENT OUTDENT }}`, `yy.Block.wrap()`], [`INDENT ClassBody OUTDENT`, `$2`], [`{{ INDENT ClassBody OUTDENT }}`, `$3`], [`{ ClassBody }`, `$2`]]);
u(`ClassConstructor?`, [['', 'undefined'], ['<( TypeArguments )>', '{ args: $2 }'], ['TypeArguments? WITH Params', '{ args: $1.unwrap, ctor: $3 }', {
  first: 2
}], ['TypeArguments? Params', '{ args: $1.unwrap, ctor: $2 }', {
  first: 2
}]]);
u(`ForExpression`, [[`JointExpression`], [`Declare`]]);
u(`JointExpression`, [[`Expression`], [`JointExpression , Expression`, `...$1.contents, $3`]]);
u(`For`, [[`FOR ForExpression ; Expression ; Expression Block`, `[$2, $4, $6], $7`], [`FOR ForExpression ; Expression ; Expression THEN Block`, `[$2, $4, $6], $8`], [`FOR ForExpression ; Expression ; Expression THEN Expression`, `[$2, $4, $6], yy.Block.wrap($8)`], [`FOR ForExpression WHEN Expression WHILST Expression Block`, `[$2, $4, $6], $7`], [`FOR ForExpression WHEN Expression WHILST Expression THEN Block`, `[$2, $4, $6], $8`], [`FOR ForExpression WHEN Expression WHILST Expression THEN Expression`, `[$2, $4, $6], yy.Block.wrap($8)`], [`FOR ForAssignable FOR_OF Expression Block`, `[$2[1], $3, $4], $5, $2[2]`], [`FOR ForAssignable FOR_IN Expression Block`, `[$2[1], $3, $4], $5, $2[2]`], [`FOR ForAssignable FOR_OF Expression THEN Block`, `[$2[1], $3, $4], $6, $2[2]`], [`FOR ForAssignable FOR_IN Expression THEN Block`, `[$2[1], $3, $4], $6, $2[2]`], [`FOR ForAssignable FOR_OF Expression THEN Expression`, `[$2[1], $3, $4], yy.Block.wrap($6), $2[2]`], [`FOR ForAssignable FOR_IN Expression THEN Expression`, `[$2[1], $3, $4], yy.Block.wrap($6), $2[2]`], [`FOR Identifier , Assignable ForAny Expression THEN Expression`, `[[$2, $4], $5, $6], yy.Block.wrap($8)`], [`FOR Identifier , Assignable ForAny Expression THEN Block`, `[[$2, $4], $5, $6], $8`], [`FOR Identifier , Assignable ForAny Expression Block`, `[[$2, $4], $5, $6], $7`], [`FOR DeclarationKeyword Identifier , Assignable ForAny Expression THEN Expression`, `[[$3, $5], $6, $7], yy.Block.wrap($9), $2`], [`FOR DeclarationKeyword Identifier , Assignable ForAny Expression THEN Block`, `[[$3, $5], $6, $7], $8, $2`], [`FOR DeclarationKeyword Identifier , Assignable ForAny Expression Block`, `[[$3, $5], $6, $7], $8, $2`], [`Expression POSTFOR DeclarationKeyword Identifier , Assignable ForAny Expression`, `[[$4, $6], $7, $8], yy.Block.wrap($1), $3`], [`Expression POSTFOR ForAssignable FOR_OF Expression`, `[$3[1], $4, $5], yy.Block.wrap($1), $3[2]`], [`Expression POSTFOR ForAssignable FOR_IN Expression`, `[$3[1], $4, $5], yy.Block.wrap($1), $3[2]`], [`Expression POSTFOR Identifier , Assignable ForAny Expression`, `[[$3, $5], $6, $7], yy.Block.wrap($1)`]]);
u(`ForAssignable`, [[`DeclarationKeyword Assignable`, `$2, $1`], [`Assignable`, `$1`]]);
u(`Switch`, [[`SWITCH Expression INDENT Cases OUTDENT`, `$2, $4`], [`SWITCH INDENT Cases OUTDENT`, `false, $3`], [`SWITCH Expression {{ INDENT Cases OUTDENT }}`, `$2, $5`], [`SWITCH {{ INDENT Cases OUTDENT }}`, `false, $4`]]);
u(`Cases`, [[`Case`], [`Cases NEWLINE Case`, `...$1.contents, $3`]]);
u(`Case`, [[`Clauses THEN Expression`, `$1, yy.Block.wrap($3)`], [`Clauses THEN Block`, `$1, $3.unwrap`], [`Clauses Block`, `$1, $2.unwrap`], [`Multicondition THEN Expression`, `$1, yy.Block.wrap($3)`], [`Multicondition THEN Block`, `$1, $3.unwrap`], [`Multicondition Block`, `$1, $2.unwrap`], [`DEFAULT Expression`, `false, yy.Block.wrap($2)`], [`DEFAULT Block`, `false, $2.unwrap`], [`Expression POSTCASE MulticheckClauses`, `$3, yy.Block.wrap($1)`], [`BREAK`]]);
u(`Clauses`, [[`When`, `$1.contents`], [`Clauses NEWLINE When`, `...$1.contents, $3.contents`], [`Clauses COMPOUND_OR When`, `...$1.contents, $3.contents`]]);
u(`When`, [[`CASE Clause`, `...$2.contents`], [`IF Clause`, `...$2.contents`], [`ON Clause`, `...$2.contents`], [`WHEN Clause`, `...$2.contents`]]);
grammar.ForAny = [[`FOR_FROM`, `$$ = $1`], [`FOR_AT`, `$$ = $1`], [`FOR_AS`, `$$ = $1`]];
u(`If`, [[`IfBlock`], [`IfBlock Else`, `$1, $2`], [`Expression ? BlockExpression : BlockExpression`, `new yy.IfBlock('IfBlock', $1, $3.unwrap), new yy.Else('Else', $5.unwrap)`, {
  quoteSyntax: true
}], [`Expression ? BlockExpression`, `new yy.IfBlock('IfBlock', $1, $3.unwrap)`, {
  quoteSyntax: true
}], [`Expression ? INDENT BlockExpression : BlockExpression OUTDENT`, `new yy.IfBlock('IfBlock', $1, $4.unwrap), new yy.Else('Else', $6.unwrap)`, {
  quoteSyntax: true
}], [`Expression POSTIF Expression`, `$3, $1`, {
  postfix: true
}], [`Statement POSTIF Expression`, `$3, $1`, {
  postfix: true,
  statement: true
}], [`Expression POSTUNLESS Expression`, `$3, $1`, {
  postfix: true,
  unless: true
}], [`Statement POSTUNLESS Expression`, `$3, $1`, {
  postfix: true,
  statement: true,
  unless: true
}]]);
u(`BlockExpression`, [[`Expression`], [`INDENT Expression OUTDENT`, `$2`]]);
u(`Try`, [[`TRY Expression`, `yy.Block.wrap($2)`], [`TRY Block`, `$2`]]);
u(`Catch`, [[`CATCH Block`, `null, $2`], [`CATCH Expression`, `null, yy.Block.wrap($2)`], [`CATCH Identifier Block`, `$2, $3`], [`CATCH Identifier THEN Block`, `$2, $4`], [`CATCH Identifier THEN Expression`, `$2, yy.Block.wrap($4)`]]);
u(`Finally`, [[`FINALLY Block`, `$2`], [`FINALLY Expression`, `yy.Block.wrap($2)`]]);
u(`TryBlock`, [[`Try`, `$1, null, null`], [`Try Catch`, `$1, $2, null`], [`Try Catch Finally`, `$1, $2, $3`]]);
u(`Loop`, [[`LOOP Block`, `$2.unwrap`], [`LOOP Expression`, `yy.Block.wrap($2).unwrap`]]);
u(`WhileUntil`, [[`WHILE`], [`UNTIL`], ['POSTWHILE'], ['POSTUNTIL']]);
u(`ElseOtherwise`, [[`ELSE`], [`OTHERWISE`], [`OR`]]);
u(`While`, [[`WhileUntil Expression THEN Block`, `$2, $4.unwrap, $1`], [`WhileUntil Expression THEN Expression`, `$2, yy.Block.wrap($4), $1`], [`WhileUntil ( Expression ) Expression`, `$3, yy.Block.wrap($5), $1`], [`WhileUntil Expression Block`, `$2, $3.unwrap, $1`], [`Loop WhileUntil Expression`, `$3, $1.unwrap, $2`], [`Loop NEWLINE WhileUntil Expression`, `$4, $1.unwrap, $3`], [`Expression WhileUntil Expression`, `$3, yy.Block.wrap($1), $2`]]);
u(`IfUnless`, [[`IF`], [`UNLESS`]]);
u(`Else`, [[`ElseOtherwise Block`, `$2`], [`ElseOtherwise Expression`, `$2`], [`ElseOtherwise Statement`, `$2`], [`ElseOtherwise THEN Block`, `$3`]]);
u(`IfBlock`, [[`IfUnless ( Expression ) Expression`, `$3, $5, $1`], [`IfUnless ( Expression ) Statement`, `$3, $5, $1`], [`IfUnless Expression { Expression }`, `$2, $4, $1`], [`IfUnless Expression { Statement }`, `$2, $4, $1`], [`IfUnless Expression THEN Expression`, `$2, $4, $1`], [`IfUnless Expression THEN Statement`, `$2, $4, $1`], [`IfUnless Expression THEN { Expression }`, `$2, $5, $1`], [`IfUnless Expression THEN { Statement }`, `$2, $5, $1`], [`IfUnless Expression Block`, `$2, $3, $1`], [`IfUnless Expression THEN Block`, `$2, $4, $1`]]);
u(`Value`, [[`Assignable`], [`Parenthetical`], [`Literal`], [`Invocation`], [`Function`], [`New`], [`This`], [`Super`], [`SUCH`]]);
u(`Invocation`, [[`Value FUNC_EXISTS TypeArguments? Arguments`, `$1, $4, $3.unwrap`, {
  soak: true
}], [`Value <( TypeArguments )> Arguments`, `$1, $5, $3.setLoc(@2, @4)`], [`Value Arguments`, `$1, $2`], [`Value FUNC_EXISTS TypeArguments? String`, `$1, $4, $3.unwrap`, {
  templ: true,
  soak: true
}], [`Value <( TypeArguments )> String`, `$1, $5, $3.setLoc(@2, @4)`, {
  templ: true
}], [`Value String`, `$1, $2`, {
  templ: true
}], [`SUPER FUNC_EXISTS Arguments`, `$1, $3`, {
  soak: true
}], [`SUPER <( TypeArguments )> Arguments`, `$1, $5, $3.setLoc(@2, @4)`], [`SUPER Arguments`, `$1, $2`]]);
u(`Arguments`, [[`CALL_START CALL_END`, `/* */`], [`CALL_START ArgList OptComma CALL_END`, `$2`], [`CALL_START INDENT ArgList OptComma OUTDENT CALL_END`, `$3`, {
  indented: true
}]]);
u(`ArgList`, [[`Arg`], [`ArgList , Arg`, `...$1.contents, $3`], [`ArgList OptComma NEWLINE Arg`, `...$1.contents, @3.generated, $4`], [`ArgList OptComma INDENT ArgList OptComma OUTDENT`, `...$1.contents, false, ...$4.contents`]]);
u(`Arg`, [[`Expression`], [`... Expression`, `$2`, {
  expansion: true
}], [`Expression ...`, `$1`, {
  expansion: true
}]]);
u(`New`, [[`NEW Expression`, `$2`]]);
u(`Super`, [[`SUPER . PROPERTY`, `Object.assign([$3], { loc: @3 })`], [`SUPER INDEX_START PROPERTY INDEX_END`, `$3`]]);
u(`This`, [[`THIS`]]);
u(`Parenthetical`, [[`( Expression )`, `$2`], [`( Body )`, `$2`], [`( INDENT Body OUTDENT )`, `$3`]]);
u(`OptComma`, [[``], [`,`]]);
u(`Object`, [[`{ }`, `[]`], [`{ PropList OptComma }`, `$2`, {
  indentOf: 1
}], [`{ INDENT PropList OUTDENT }`, `$3`, {
  indented: true
}]]);
grammar.PropList = [[`PropObj`, `$$ = [$1]`], [`PropList , PropObj`, `$$ = $1.push($3) && $1`], [`PropList OptComma NEWLINE PropObj`, `$$ = $1.push(@3.generated, $4) && $1`], [`PropList OptComma INDENT PropList OUTDENT`, `$$ = $1.concat(false, ...[$4])`]];
grammar.ParamPropList = [[``, `$$ = []`], [`ParamPropObj`, `$$ = [$1]`], [`ParamPropList , ParamPropObj`, `$$ = $1.push($3) && $1`], [`ParamPropList OptComma NEWLINE ParamPropObj`, `$$ = $1.push($4) && $1`], [`ParamPropList OptComma INDENT ParamPropObj OUTDENT`, `$$ = $1.push($4) && $1`]];
grammar.PropObj = [[`Function`, `$$ = $1`], [`ClassFunction`, `$$ = $1`], [`PROPERTY : Expression`, `$$ = [$1, $3, [@1, @3]]`], [`PROPERTY : Block`, `$$ = [$1, yy.Array.from($3), [@1, @3, true]]`], [`PROPERTY : INDENT Expression OUTDENT`, `$$ = [$1, $4, [@1, @5, true]]`], [`AlphaNum : Expression`, `$$ = [$1, $3, [@1, @3]]`], [`AlphaNum : Block`, `$$ = [$1, yy.Array.from($3), [@1, @3, true]]`], [`AlphaNum : INDENT Expression OUTDENT`, `$$ = [$1, $4, [@1, @5, true]]`], [`[ Expression ] : Expression`, `$$ = [$2, $5, [@1, @5]]`], [`[ Expression ] : INDENT Expression OUTDENT`, `$$ = [$2, $6, [@1, @6, true]]`], [`[ Expression ] : Block`, `$$ = [$2, yy.Array.from($5), [@1, @5, true]]`], [`PROPERTY :`, `$$ = [$1, false, [@1, @2]]`], [`... PROPERTY :`, `$$ = [$2, false, [@1, @3], true]`], [`PROPERTY : ...`, `$$ = [$1, false, [@1, @3], true]`], [`Identifier`, `$$ = [$1[1], false, [@1, @1]]`], [`Assignment`, `$$ = $1`], [`... Value`, `$$ = $2`], [`Value ...`, `$$ = $1`]];
grammar.ParamPropObj = [[`PROPERTY : ParamAssignable`, `$$ = [$1,$3,,,@1]`], [`PROPERTY :`, `$$ = [$1,,,,@1]`], [`PROPERTY : Defaults Expression`, `$$ = [$1,,$4,,@1]`], [`ParamIdentifier`, `$$ = $1`], [`ParamIdentifier :`, `$$ = $1`], [`ParamIdentifier Defaults Expression`, `$$ = [$1,,$3]`], [`... PROPERTY :`, `$$ = [$2,,,true,@2]`], [`PROPERTY : ...`, `$$ = [$1,,,true,@1]`]];
u(`Literal`, [[`AlphaNum`], [`Regex`], [`UNDEFINED`], [`INFINITY`], [`BOOL`], [`NULL`], [`NAN`]]);
u(`AlphaNum`, [[`String`], [`NUMBER`]]);
u(`String`, [[`STRING`], [`StringWithInterpolations`]]);
u(`JSX`, [[`JSX_START Interpolations JSX_END`, `$2, $1`]]);
u(`StringWithInterpolations`, [[`STRING_START Interpolations STRING_END`, `$2, $1`]]);
u(`Interpolations`, [[`Interpolation`, `$1`], [`Interpolations Interpolation`, `...$1.contents, $2`], [`Interpolations INDENT Interpolations OUTDENT`, `...$1.contents, 1, ...$3.contents, -1`]]);
u(`Interpolation`, [[`INTERPOLATION_START Expression INTERPOLATION_END`, `$2`], [`String`]]);
u(`Regex`, [[`REGEX`], [`RegexWithInterpolations`]]);
u(`RegexWithInterpolations`, [[`REGEX_START RegexInterpolations REGEX_END`, `$2, $3`]]);
u(`RegexInterpolations`, [[`RegexInterpolation`, `$1`], [`RegexInterpolations RegexInterpolation`, `...$1.contents, $2`]]);
u(`RegexInterpolation`, [[`INTERPOLATION_START Expression INTERPOLATION_END`, `$2`], [`Regex`]]);
u(`ClassFunctionPrelude`, [[`ClassFunctionTag`], [`ClassFunctionPrelude ClassFunctionTag`, `...$1.addTag($2)`]]);

// you can declare a function in any order now
// with this we solve the error of many "function" tags that are not supposed to be there
// but the lexer itself can add them
// anyway, they will be checked by the collector, if there is a `get` and it collects later a `set`, it will pop an error. 
u(`ClassFunctionTag`, [[`FUNCTION`, `$1, @1`], [`STATIC`, `$1, @1`], [`GET`, `$1, @1`], [`SET`, `$1, @1`], [`ASYNC`, `$1, @1`]]);
u(`FunctionPrelude`, [[`FunctionTag`], [`FunctionPrelude FunctionTag`, `...$1.addTag($2)`]]);

// you can declare a function in any order now
// with this we solve the error of many "function" tags that are not supposed to be there
// but the lexer itself can add them
// anyway, they will be checked by the collector, if there is a `get` and it collects later a `set`, it will pop an error. 
u(`FunctionTag`, [[`FUNCTION`, `$1, @1`], [`ASYNC`, `$1, @1`]]);

// Name and parameters to take in consideration
u(`FunctionInterlude`, [[`<( TypeArguments )>`, `{ generics: $2.setLoc(@1, @2) }`], [`IDENTIFIER TypeArguments?`, `{ id: $1, generics: $2.unwrap }`, {
  last: 1
}], [`IDENTIFIER TypeArguments? Params`, `{ id: $1, params: $3, generics: $2.unwrap }`], [`IDENTIFIER TypeArguments? WITH`, `{ id: $1, generics: $2.unwrap }`], [`IDENTIFIER TypeArguments? WITH Params`, `{ id: $1, generics: $2.unwrap, params: $4 }`], [`TypeArguments? Params`, `{ generics: $1.unwrap, params: $2 }`, {
  first: 2
}], [`TypeArguments? WITH`, `{ generics: $1.unwrap }`, {
  first: 2
}], [`TypeArguments? WITH Params`, `{ generics: $1.unwrap, params: $3 }`, {
  first: 2
}]]);

// Order of executions
u(`FunctionPostlude`, [[`Expression`, `yy.Block.wrap($1).setLoc(@1)`], [`Statement`, `yy.Block.wrap($1).setLoc(@1)`], [`Block`, `$1.unwrap.setLoc(@1)`, {
  typeOf: 0
}], [`THEN Block`, `$2.unwrap.setLoc(@1, @2)`, {
  typeOf: 1
}], [`THEN Expression`, `yy.Block.wrap($2).setLoc(@2)`, {
  typeOf: 1
}], [`THEN Statement`, `yy.Block.wrap($2).setLoc(@2)`, {
  typeOf: 1
}]]);
u(`Function`, [[`FunctionPrelude FunctionInterlude? FUNC_DIRECTIVE? FunctionPostlude?`, `$1, $2.unwrap || {}, $4.unwrap, $3.unwrap`, {
  last: 1
}]]);
u(`FunctionInterlude?`, [[``, `undefined`], [`FunctionInterlude`]]);
u(`FunctionPostlude?`, [[``, `undefined`], [`FunctionPostlude`]]);
u(`FUNC_DIRECTIVE?`, [[``, `undefined`], [`FUNC_DIRECTIVE`]]);
u(`ClassFunction`, [[`ClassFunctionPrelude FunctionInterlude`, `$1, $2, yy.Block.wrap()`], [`ClassFunctionPrelude FunctionInterlude FunctionPostlude`, `$1, $2, $3`], [`FunctionInterlude`, `new yy.ClassFunctionPrelude(null), $1, yy.Block.wrap()`], [`FunctionInterlude FunctionPostlude`, `new yy.ClassFunctionPrelude(null), $1, $2`]]);
u('TypeArguments?', [['', 'undefined'], ['<( TypeArguments )>', '$2'], ['<( INDENT TypeArguments OUTDENT )>', '$3']]);
u(`Params`, [[`PARAM_START PARAM_END`, `[]`, {
  typeOf: 2
}], [`PARAM_START ParamList PARAM_END`, `$2.setLoc(@1, @3)`, {
  typeOf: 3
}]]);
u(`ParamList`, [[`Param`, `$1`], [`ParamList , Param`, `...$1.addParam($3)`], [`ParamList OptComma NEWLINE Param`, `...$1.addParam($4)`], [`ParamList OptComma INDENT ParamList OptComma OUTDENT`, `...$1.addParams($4.contents)`]]);
u(`Param`, [[`ParamAssignable`]]);
u(`Assign`, [[`Assignment`, `$1`]]);
u(`Assignment`, [[`Assignable AssignKeyword Expression`, `$1, $3, $2`], [`Assignable AssignKeyword INDENT Expression OUTDENT`, `$1, $4, $2`], [`Assignable AssignKeyword NEWLINE Expression`, `$1, $4, $2`], [`Assignable AssignKeyword Block`, `$1, yy.Array.from($3), $2`]]);
u(`AssignKeyword`, [[`AS`, `@1.origin`], [`AT`], [`FROM`]]);
u(`Assignable`, [[`Identifier`], [`Object`], [`Array`], [`Value Access`, `$1, $2`, {
  typeOf: 2
}], ['Expression IN Expression', `$3, $1`]]);
u('Defaults', [['AS'], ['DEFAULTS']]);
u(`ParamAssignable`, [[`ParamIdentifier`], [`ParamObject`], [`ParamObject Defaults Expression`], [`ParamArray`], [`ParamArray Defaults Expression`]]);
u(`ParamObject`, [[`{ ParamPropList }`, `$2`, {
  typeOf: 3
}], ['{ }', '[]', {
  typeOf: 0
}]]);
grammar.ParamAssignable[2][1] = `$$ = new yy.ParamAssignable('ParamObject', $1.defaults($3)).setLocation(@1, @3)`;
grammar.ParamAssignable[4][1] = `$$ = new yy.ParamAssignable('ParamArray', $1.defaults($3)).setLocation(@1, @3)`;
u(`Identifier`, [[`IDENTIFIER`]]);
u(`ParamIdentifier`, [[`IDENTIFIER`, `$1`], [`... IDENTIFIER`, `$2`, {
  expansion: true,
  typeOf: 2
}], [`IDENTIFIER ...`, `$1`, {
  expansion: true
}], [`IDENTIFIER Defaults Expression`, `$1,,$3`], [`THIS . PROPERTY`, `$3, true`, {
  typeOf: 3
}], [`THIS . PROPERTY Defaults Expression`, `$3,true,$5`, {
  typeOf: 3
}], [`THIS . PROPERTY ...`, `$3, true`, {
  expansion: true,
  typeOf: 3
}], [`... THIS . PROPERTY`, `$4, true`, {
  expansion: true,
  typeOf: 4
}], [`THIS`, `$1,,,true`]]);
u(`Access`, [[`. PROPERTY`, `Object.assign([$2], { loc: @2 }), @1.origin === '?.'`, {
  typeOf: 2
}], [`INDEX_START Expression INDEX_END`, `$2`, {
  typeOf: 3
}]]);
u(`ParamArray`, [[`[ ]`, `/* */`, {
  typeOf: 0
}], [`[ ParamArrayList OptVoids ]`, `$2`, {
  typeOf: 4
}], [`[ ParamArrayList OptVoids ]`, `$2`, {
  typeOf: 4
}]]);
u(`Array`, [[`[ ]`, `/* */`, {
  checkGenerated: 1
}], [`[ ArrayList OptVoids ]`, `...$2`, {
  checkGenerated: 1
}], [`[ INDENT ArrayList OptVoids OUTDENT ]`, `...$3`, {
  indented: true,
  checkGenerated: 1
}]]);
grammar.ParamArrayList = [[`ParamArrayArg`, `$$ = [...$1]`], [`ParamArrayList , ParamArrayArg`, `$$ = $1.concat($3)`], [`ParamArrayList OptComma NEWLINE ParamArrayArg`, `$$ = $1.concat($4)`]];
grammar.ArrayList = [[`ArrayArg`, `$$ = [...$1]`], [`ArrayList , ArrayArg`, `$$ = $1.concat($3)`], [`ArrayList OptComma INDENT ArrayList OptVoids OUTDENT`, `$$ = $1.concat(false, $4)`], [`ArrayList OptComma NEWLINE ArrayArg`, `$$ = $1.concat(@3.generated, $4)`]];
grammar.ParamArrayArg = [[`ParamAssignable`, `$$ = [$1]`], [`Voids ParamAssignable`, `$$ = [...$1, $2]`]];
grammar.ArrayArg = [[`... Expression`, `$$ = [Object.assign($2, { expansion: true })]`], [`Expression ...`, `$$ = [Object.assign($1, { expansion: true })]`], [`Expression`, `$$ = [$1]`], [`Voids Expression`, `$$ = [...$1, $2]`]];
grammar.OptVoids = [[``, `$$ = undefined`], [`Voids`, `$$ = $1`]];
grammar.Voids = [[`,`, `$$ = [null]`], [`, Voids`, `$$ = [null, ...$1]`], [`, NEWLINE Voids`, `$$ = [null, ...$2]`]];
u(`Statement`, [[`Return`], [`BREAK Identifier`, `$2`], [`BREAK`], [`CONTINUE Identifier`, `$2`], [`CONTINUE`], [`Import`], [`Export`], [`Declare`], [`THROW Expression`, `$2`], [`THROW INDENT Expression OUTDENT`, `$3`], [`DELETE Expression`, `$2`], [`Type`], [`Interface`]]);
u(`Interface`, [['INTERFACE Identifier TypeArguments? IntExtends? InterfaceBody', '$2, $3, $5, $4.unwrap'], ['INTERFACE Identifier TypeArguments? IntExtends? INDENT InterfaceBody OUTDENT', '$2, $3, $6, $4.unwrap']]);
u('IntExtends?', [['', 'undefined'], ['EXTENDS ExtendsNames', '$2']]);
u('ClassImplements?', [['', 'undefined'], ['IMPLEMENTS ExtendsNames', '$2']]);
u('ExtendsNames', [['ExtendsNames , ExtendsName', '...$1.contents, $3'], ['ExtendsNames OptComma NEWLINE ExtendsName', '...$1.contents, $4'], ['ExtendsName']]);
u('ExtendsName', [['Identifier TypeArguments?', '$1, $2.unwrap', {
  last: 1
}]]);
u(`InterfaceBody`, [['', '[]'], ['{ }', '[]'], ['InterfaceBody OptComma NEWLINE InterfaceBody', '[...$1.unwrap, ...$4.unwrap]'], ['{ InterfaceProperties }', '$2.contents'], ['{ INDENT InterfaceProperties OUTDENT }', '$3.contents'], ['InterfaceProperties', '$1.contents'], ['INDENT InterfaceProperties OUTDENT', '$2.contents']]);
u(`InterfaceProperties`, [['InterfaceProperty'], ['InterfaceProperties , InterfaceProperty', '...$1.contents, $3'], ['InterfaceProperties OptComma NEWLINE InterfaceProperty', '...$1.contents, $4'], ['InterfaceProperties OptComma INDENT InterfaceProperties OUTDENT', '...$1.contents, ...$4.contents'], ['InterfaceProperties , { InterfaceProperties }', '...$1.contents, ...$4.contents'], ['InterfaceProperties OptComma NEWLINE { InterfaceProperties }', '...$1.contents, ...$5.contents'], ['InterfaceProperties OptComma INDENT { InterfaceProperties } OUTDENT', '...$1.contents, ...$5.contents'], ['InterfaceProperties OptComma INDENT { INDENT InterfaceProperties OUTDENT } OUTDENT', '...$1.contents, ...$6.contents']]);
u('InterfaceProperty', [
// READONLY
['READONLY Identifier IntTypeSentence?', '$2, $3.unwrap || @2.type, { readonly: true }', {
  last: 2
}], ['READONLY PROPERTY : InlineType', 'new yy.Identifier(null, $2).setLoc(@2), $4, { readonly: true }'], ['READONLY [ Identifier ] IntTypeSentence?', '$3, $5.unwrap || @4.type, { readonly: true, indexed: true }', {
  last: 4
}], ['READONLY [ { PROPERTY : TypeSentence } ] IntTypeSentence?', 'new yy.Identifier(null, $4).setLoc({ ...@4, type: { nodes: $6, loc: @6 } }), $9.unwrap || @8.type, { readonly: true, indexed: true }', {
  last: 8
}],
// NEW
['NEW TypeArguments? Params IntTypeSentence?', 'null, $4.unwrap || @3.type, { news: true, params: $3, args: $2.unwrap }', {
  last: 3
}],
// Methods
['IntTypeSpecifiers Identifier TypeArguments? Params IntTypeSentence?', '$2, $5.unwrap || @4.type, { ...$1.unwrap, params: $4, args: $3 }', {
  first: 2,
  last: 4
}], ['Identifier TypeArguments? Params IntTypeSentence?', '$1, $4.unwrap || @3.type, { params: $3, args: $2 }', {
  last: 3
}],
// Raw properties
['Identifier IntTypeSentence?', '$1, $2.unwrap || @1.type, {}', {
  last: 1
}], ['PROPERTY : InlineType', 'new yy.Identifier(null, $1).setLoc(@1), Object.assign($3, { optional: @2.origin === "?:" })'], ['[ Identifier ] IntTypeSentence?', '$2, $4.unwrap || @3.type, { indexed: true }', {
  last: 3
}], ['[ { PROPERTY : TypeSentence } ] IntTypeSentence?', 'Object.assign(new yy.Identifier(null, $3).setLoc({ ...@3, type: { nodes: $5, loc: @5 } }), { optional: @4.origin === "?:" }), $8.unwrap || @7.type, { indexed: true }', {
  last: 7
}]]);

// Most of properties from an interface don't need a type annotation so we keep them optional
u('IntTypeSentence?', [['', 'undefined'], [': InlineType', 'Object.assign($2, { optional: @1.origin === "?:" })'], [': INDENT TypeSentence OUTDENT', 'Object.assign($3, { optional: @1.origin === "?:" })'], [': NEWLINE InlineType', 'Object.assign($3, { optional: @1.origin === "?:" })']]);
u(`IntTypeSpecifiers`, [[`GET`, `{ getter: true }`], [`SET`, `{ setter: true }`]]);
u(`Type`, [[`TYPE TypeDeclaration`, `$2`], [`TYPE INDENT TypeDeclaration OUTDENT`, `$3`], [`TYPE NEWLINE TypeDeclaration`, `$3`]]);
u(`TypeDeclaration`, [[`Identifier TypeArguments? AS InlineType`, `$1, $4, $2.unwrap`], [`Identifier TypeArguments? AS INDENT TypeSentence OUTDENT`, `$1, $5, $2.unwrap`], [`Identifier TypeArguments? AS NEWLINE TypeSentence`, `$1, $5, $2.unwrap`]]);
u(`TypeSentence`, [[`TypeValue`], [`TYPE_JOIN`], [`TypeSentence TypeValue`, `...$1.contents, $2`], [`TypeSentence TYPE_JOIN`, `...$1.contents, $2`], [`TypeSentence INDENT TypeSentence OUTDENT`, `...$1.contents, 1, ...$3.contents, -1`], [`TypeSentence NEWLINE TypeValue`, `...$1.contents, 0, $3`], [`TypeSentence NEWLINE TYPE_JOIN`, `...$1.contents, 0, $3`]]);
u(`TypeValue`, [[`TypeArray`], [`TypeObject`], [`Literal`], [`Identifier`], [`VOID`], [`TAG`], ['TypeWithArguments'], [`TypeAccess`], [`TypeFunction`], [`TypeofKeyof`], [`TypeWrapped`]]);
u(`TypeofKeyof`, [[`KEYOF TypeValue`, `$2, $1`], [`TYPEOF TypeValue`, `$2, $1`]]);
u(`TypeWrapped`, [[`( TypeSentence )`, '$2'], [`( INDENT TypeSentence OUTDENT )`, '$3', {
  indented: true
}]]);
u(`TypeAccess`, [[`TypeValue INDEX_START TypeSentence INDEX_END`, `$1, $3`], [`TypeValue INDEX_START INDENT TypeSentence OUTDENT INDEX_END`, `$1, $3`, {
  indented: true
}], [`TypeValue . PROPERTY`, `$1, new yy.String('STRING', "'" + $3 + "'").setLoc(@3)`], [`TypeValue IN TypeValue`, `$3, new yy.TypeSentence('TypeValue', $1).setLoc(@1)`]]);
u(`TypeFunction`, [[`Params FUNC_DIRECTIVE InlineType`, `$1, $3`], [`FUNC_DIRECTIVE InlineType`, `new yy.Params(null, []), $2`], [`NEW Params FUNC_DIRECTIVE InlineType`, `$2, $4, $1`], [`NEW FUNC_DIRECTIVE InlineType`, `new yy.Params(null, []), $3, $1`]]);
u('TypeWithArguments', [['TypeValue INDEX_START INDEX_END', '{ isArray: true, type: $1 }'], ['Identifier <( TypeArguments )>', '{ type: $1, arguments: $3 }'], ['Identifier <( INDENT TypeArguments OUTDENT )>', '{ type: $1, arguments: $4 }']]);
u('TypeArguments', [['TypeArgument'], ['TypeArguments , TypeArgument', '...$1.contents, $3'], ['TypeArguments OptComma NEWLINE TypeArgument', '...$1.contents, $4'], ['TypeArguments OptComma INDENT TypeArgument OUTDENT', '...$1.contents, $4']]);
u('TypeArgument', [['Identifier', '$1'], ['Identifier EXTENDS Identifier', '$1, $3'], ['TypeWithArguments']]);
u(`InlineType`, [[`TypeValue`], [`TYPE_JOIN`], [`InlineType TypeValue`, `...$1.contents, $2`], [`InlineType TYPE_JOIN`, `...$1.contents, $2`], [`InlineType INDENT TypeSentence OUTDENT`, `...$1.contents, 1, ...$3.contents, -1`]]);
u(`TypeObject`, [[`{ }`, '/* */'], [`{ TypeObjProps }`, `...$2.contents`], [`{ INDENT TypeObjProps OUTDENT }`, `...$3.contents`, {
  indented: true
}]]);
u(`TypeObjProps`, [[`TypeObjProp`], [`TypeObjProps , TypeObjProp`, `...$1.contents, $3`], [`TypeObjProps OptComma NEWLINE TypeObjProp`, `...$1.contents, @3.generated && 1 || 0, $4`], [`TypeObjProps OptComma INDENT TypeObjProps OUTDENT`, `...$1.contents, 2, ...$4.contents`]]);
u(`TypeObjProp`, [[`Identifier`, `$1`], [`PROPERTY : InlineType`, `$1, $3, @2.origin === '?:'`], [`PROPERTY : NEWLINE InlineType`, `$1, $4, @2.origin === '?:'`], [`PROPERTY : INDENT TypeSentence OUTDENT`, `$1, $4, @2.origin === '?:'`], [`PROPERTY :`, `$1, , @2.origin === '?:'`], [`[ PROPERTY : TypeSentence ] : InlineType`, `$2, $7, , { isDynamicKey: true, keyType: $4 }`], [`[ PROPERTY : TypeSentence ] : NEWLINE InlineType`, `$2, $8, , { isDynamicKey: true, keyType: $4 }`], [`[ PROPERTY : TypeSentence ] : INDENT TypeSentence OUTDENT`, `$2, $8, , { isDynamicKey: true, keyType: $4 }`], [`[ Identifier ] : InlineType`, `$2, $5, , { isDynamicKey: true, keyType: @2.type }`], [`[ Identifier ] : NEWLINE InlineType`, `$2, $6, , { isDynamicKey: true, keyType: @2.type }`], [`[ Identifier ] : INDENT TypeSentence OUTDENT`, `$2, $6, , { isDynamicKey: true, keyType: @2.type }`]]);
u(`TypeArray`, [[`[ TypeArrayItems ]`, `...$2.contents`], [`[ INDENT TypeArrayItems OUTDENT ]`, `...$3.contents`, {
  indented: true
}]]);
u(`TypeArrayItems`, [['InlineType'], [`TypeArrayItems OptComma NEWLINE InlineType`, `...$1.contents, @3.generated && 1 || 0, $4`], [`TypeArrayItems OptComma INDENT TypeSentence OUTDENT`, `...$1.contents, 2, $4`], [`TypeArrayItems , InlineType`, `...$1.contents, $3`]]);
u(`Declare`, [[`DeclarationKeyword Declarations`, `{ keyword: $1, statements: $2 }, [@1, @2]`], [`DeclarationKeyword INDENT Declarations OUTDENT`, `{ keyword: $1, statements: $3, indented: true }, [@1, @3]`]]);
u(`DeclarationKeyword`, [[`VAR`], [`LET`], [`CONST`]]);
u(`Declarations`, [[`Declaration`, `$1.unwrap`], [`Declarations , Declaration`, `...$1.contents, $3.unwrap`], [`Declarations OptComma NEWLINE Declaration`, `...$1.contents, @3.generated, $4.unwrap`], [`Declarations OptComma INDENT Declarations OUTDENT`, `...$1.contents, false, ...$4.contents`]]);
u(`Declaration`, [['Assignable'], [`Assignable AssignKeyword Expression`, `new yy.Assignment('Assignable AssignKeyword Expression', $1, $3, $2).setLoc(@1, @3)`], [`Assignable AssignKeyword INDENT Expression OUTDENT`, `new yy.Assignment('Assignable AssignKeyword INDENT Expression OUTDENT', $1, $4, $2).setLoc(@1, @5)`], [`Assignable AssignKeyword Block`, `new yy.Assignment('Assignable AssignKeyword Block', $1, yy.Array.from($3), $2).setLoc(@1, @3)`]]);
u(`Return`, [[`RETURN`, `undefined`], [`RETURN Expression`, `$2`], [`RETURN INDENT Expression OUTDENT`, `$3`], [`RETURN INDENT Body OUTDENT`, `$3`]]);
u(`Import`, [[`IMPORT ImportList FROM STRING`, `{ _imports: $2, _from: $4 }`], [`IMPORT Identifier FROM STRING`, `{ _default: $2, _from: $4 }`], [`IMPORT Identifier OptSeparator ImportList FROM STRING`, `{ _default: $2, _imports: $4, _from: $6 }`]]);
u(`OptSeparator`, [[``, `undefined`], [`,`, `undefined`], [`OptComma NEWLINE`, `1`]]);
u(`Export`, [[`EXPORT ExportList`, `{ list: $2 }`], [`EXPORT INDENT ExportList OUTDENT`, `{ list: $3 }`], [`EXPORT DEFAULT Expression`, `{ defaults: $3 }`], [`EXPORT INDENT DEFAULT Expression OUTDENT`, `{ defaults: $4 }`], [`EXPORT Declare`, `{ declarations: $2 }`], [`EXPORT INDENT Declare OUTDENT`, `{ declarations: $3 }`], [`EXPORT Exportable`, `{ exportable: $2.unwrap }`], [`EXPORT INDENT Exportable OUTDENT`, `{ exportable: $3.unwrap }`]]);
u(`ImportList`, [[`Identifier`], [`* AS Identifier`, `$3`, {
  _isAll: true
}], [`{ ImportNames OptComma }`, `$2`], [`{{ INDENT ImportNames OptComma OUTDENT }}`, `$3`]]);
u(`ExportList`, [[`{ ExportNames }`, `$2`], [`{{ INDENT ExportNames OUTDENT }}`, `$3`]]);
u(`ExportNames`, [[`ExportName`, `$1.contents`], [`ExportNames , ExportName`, `...$1.contents, $3.contents`], [`ExportNames OptComma NEWLINE ExportName`, `...$1.contents, $4.contents`]]);
u(`ExportName`, [[`PROPERTY :`, `new yy.Identifier(0, $1).setLoc(@1)`], [`PROPERTY : Identifier`, `new yy.Identifier(0, $1).setLoc(@1), $3`], [`PROPERTY : AS Identifier`, `new yy.Identifier(0, $1).setLoc(@1), $4`], [`Identifier`], [`Identifier AS DEFAULT`, `$1,,true`], [`Identifier AS Identifier`, `$1,$3`]]);
u(`Exportable`, [[`Class`], [`Function`]]);
u(`ImportNames`, [[`ImportName`, `$1.contents`], [`ImportNames , ImportName`, `...$1.contents, $3.contents`], [`ImportNames OptComma NEWLINE ImportName`, `...$1.contents, $4.contents`]]);
u(`ImportName`, [[`PROPERTY :`, `new yy.Identifier(0, $1).setLoc(@1), , [@1, @2]`], [`PROPERTY : Identifier`, `new yy.Identifier(0, $1).setLoc(@1), $3`], [`PROPERTY : AS Identifier`, `new yy.Identifier(0, $1).setLoc(@1), $4`], [`Identifier AS Identifier`, `$1, $3`], [`DEFAULT AS Identifier`, `(new yy.Identifier(null, 'default')).setLoc(@1), $3`], [`Identifier`]]);
function wrap(source) {
  let [from, to] = source.split(' ');
  wrapped[`${from}(${to})`] = {
    from,
    to
  };
  grammar[`${from}(${to})`] = [[to, '$$ = $1']];
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (grammar);

/***/ }),

/***/ "./lib/helpers.js":
/*!************************!*\
  !*** ./lib/helpers.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RelicError: () => (/* binding */ RelicError),
/* harmony export */   errorToString: () => (/* binding */ errorToString),
/* harmony export */   guessIndentation: () => (/* binding */ guessIndentation),
/* harmony export */   red: () => (/* binding */ red),
/* harmony export */   resolvePath: () => (/* binding */ resolvePath),
/* harmony export */   supportsColors: () => (/* binding */ supportsColors),
/* harmony export */   throwSyntaxError: () => (/* binding */ throwSyntaxError),
/* harmony export */   updateSyntaxError: () => (/* binding */ updateSyntaxError),
/* harmony export */   yellow: () => (/* binding */ yellow)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "?d87b");
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");


class RelicError extends SyntaxError {
  constructor(err, {
    code,
    location,
    type,
    filename,
    intermediate,
    noFileHeader
  }) {
    super(err);
    this.location = location;
    this.src = location.src;
    this.toString = errorToString;
    this.code = code;
    this.stack = this.toString();
    this.type = type;
    this.filename = filename;
    this.intermediate = intermediate;
    this.noFileHeader = noFileHeader;
  }
}
function throwSyntaxError(err, code, filename) {
  err = new RelicError(err.message, {
    location: err.location,
    code,
    type: err.type || 'error',
    filename,
    intermediate: err.intermediate,
    noFileHeader: err.noFileHeader
  });
  if (err.isEditor) {
    return err.toString();
  } else throw filename ? err.toString() : err;
}
function errorToString() {
  let filename, errorLine;
  if (!this.location || typeof this.code !== "string") {
    return Error.prototype.toString.call(this);
  }
  let {
    first_column,
    first_line,
    last_column,
    last_line
  } = this.location;
  if (!this.filename || this.filename.startsWith('<anonymous')) {
    filename = '[stdin]';
  } else {
    filename = this.filename || '[stdin]';
  }
  let errMessage = this.noFileHeader ? this.message : `${red(filename)}:${first_line}${red(':')}${first_column}${red(' ->')} ${this.type}: ${this.message}`;
  if (this.code.length) {
    errorLine = this.code;
    if (last_line && first_line < last_line) {
      last_line = first_line;
      last_column = errorLine.length + 1;
    }
    let start = first_column - 1,
      end = last_column - 1,
      highlight = (start ? " ".repeat(start) : "") + "^".repeat(Math.abs(end - start || 1));
    errorLine = errorLine.slice(0, start) + red(errorLine.slice(start, end)) + errorLine.slice(end);
    if (typeof this.intermediate === 'object') {
      errorLine = errorLine.split('');
      errorLine.splice(...Object.values(this.intermediate), '(...)');
      errorLine = errorLine.join('');
      highlight = highlight.split('');
      highlight.splice(...Object.values(this.intermediate), '     ');
      highlight = highlight.join('');
    }
    errMessage += `
${errorLine}
${highlight}
`;
  }
  return errMessage;
}
function updateSyntaxError(error, code, filename) {
  if (error.toString === errorToString) {
    typeof error.code !== "string" && (error.code = code.split(/\n/g)[error.location.first_line - 1]);
    !error.filename && (error.filename = filename);
    error.stack = error.toString();
    error.type = error.type || 'error';
  }
  return error.toString();
}
function supportsColors() {
  try {
    return process.stdout.isTTY && !process.env.NODE_DISABLE_COLORS;
  } catch {}
}
function red(str) {
  return supportsColors() ? `\x1B[0;31m${str}\x1B[0m` : str;
}
function yellow(str) {
  return supportsColors() ? `\x1B[0;33m${str}\x1B[0m` : str;
}
function guessIndentation(script) {
  let lines = script.split(/\n/g);
  let linesCount = Math.min(lines.length, 100);
  let linesIndented = 0;
  let previousLineText = "";
  let previousLineIndentation = 0;
  let defaultTabSize = 2;
  const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7];
  const MAX_ALLOWED_TAB_SIZE_GUESS = 8;
  let spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  let tmp = {};
  for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {
    let currLineLength = lines[lineNumber - 1].length;
    let currLineText = lines[lineNumber - 1];
    let currHasContent = false;
    let currLineIndentation = 0;
    let currLineSpacesCount = 0;
    for (let j = 0, lenJ = currLineLength; j < lenJ; j++) {
      let charCode = currLineText.charCodeAt(j);
      if (charCode === 32) {
        currLineSpacesCount++;
      } else {
        currHasContent = true;
        currLineIndentation = j;
        break;
      }
    }
    if (!currHasContent) continue;
    if (currLineSpacesCount > 1) {
      linesIndented++;
    }
    spacesDiff(previousLineText, previousLineIndentation, currLineText, currLineIndentation, tmp);
    if (tmp.looksLikeAlignment) {
      if (defaultTabSize === tmp.spacesDiff) {
        continue;
      }
    }
    let currSpacesDiff = tmp.spacesDiff;
    if (currSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {
      spacesDiffCount[currSpacesDiff]++;
    }
    previousLineText = currLineText;
    previousLineIndentation = currLineIndentation;
  }
  let tabSize = 2;
  let tabSizeScore = 0.1 * linesCount;
  ALLOWED_TAB_SIZE_GUESSES.forEach(possibleTabSize => {
    let possibleTabSizeScore = spacesDiffCount[possibleTabSize];
    if (possibleTabSizeScore > tabSizeScore) {
      tabSizeScore = possibleTabSizeScore;
      tabSize = possibleTabSize;
    }
  });
  if (tabSize === 8 && spacesDiffCount[8] > 0 && spacesDiffCount[4] > 0) {
    console.log(spacesDiffCount[4], spacesDiffCount[8]);
    tabSize = 4;
  }
  if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0) {
    tabSize = 2;
  }
  return {
    tabSize
  };
}
function resolvePath(dir, dname, attempts = 0) {
  if ((0,path__WEBPACK_IMPORTED_MODULE_0__.isAbsolute)(dir)) {
    return dir;
  } else {
    let filename = (0,path__WEBPACK_IMPORTED_MODULE_0__.join)(dname, dir);
    if (!(0,fs__WEBPACK_IMPORTED_MODULE_1__.existsSync)(filename) && attempts < 3) {
      if (!filename.endsWith('.rc')) {
        return resolvePath(dir + '.rc', dname, ++attempts);
      } else if (!filename.endsWith('.trc')) {
        return resolvePath(dir.slice(0, -3) + '.trc', dname, ++attempts);
      }
      return filename;
    } else return filename;
  }
}

function spacesDiff(a, aLen, b, bLen, result) {
  result.spacesDiff = 0;
  result.looksLikeAlignment = false;
  let i;
  for (i = 0; i < aLen && i < bLen; i++) {
    let aCharCode = a.charCodeAt(i);
    let bCharCode = b.charCodeAt(i);
    if (aCharCode !== bCharCode) {
      break;
    }
  }
  let aSpacesCount = 0;
  for (let j = i; j < aLen; j++) {
    aSpacesCount++;
  }
  let bSpacesCount = 0;
  for (let j = i; j < bLen; j++) {
    bSpacesCount++;
  }
  let spacesDiff = Math.abs(aSpacesCount - bSpacesCount);
  result.spacesDiff = spacesDiff;
  if (spacesDiff > 0 && 0 <= bSpacesCount - 1 && bSpacesCount - 1 < a.length && bSpacesCount < b.length) {
    if (b.charCodeAt(bSpacesCount) !== 32 && a.charCodeAt(bSpacesCount - 1) === 32) {
      if (a.charCodeAt(a.length - 1) === 44) {
        // This looks like an alignment desire: e.g.
        // const a = b + c,
        //       d = b - c;
        result.looksLikeAlignment = true;
      }
    }
  }
  return;
}
if (typeof require === "function" && typeof module !== "undefined") {
  module.exports = {
    RelicError,
    throwSyntaxError,
    errorToString,
    updateSyntaxError,
    supportsColors,
    red,
    yellow,
    guessIndentation,
    resolvePath
  };
}

/***/ }),

/***/ "./lib/lexer.js":
/*!**********************!*\
  !*** ./lib/lexer.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ "./lib/helpers.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ "./index.js");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ "?d87b");
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");




class Lexer {
  constructor(script, options = {}) {
    if (typeof script !== "string" || typeof options !== "object") {
      return;
    }
    this.position = options.startPosition || 0;
    this.indentLevel = 0;
    this.tokens = [];
    this.names = [];
    this.filename = options.filename || '<anonymous>';
    this.dirname = options.dirname || '';
    this.sdir = options.isInclude ? options.sdir : this.dirname;
    this.tabSize = options.tabSize || 2;
    this.skipped = -1;
    this.assignLine = -1;
    this.forLine = -1;
    this.funcLine = -1;
    this.paramLine = false;
    this.isSimulation = typeof options.cb === "function";
    this.stages = [{
      label: 'Root',
      type: "indent",
      contains: [],
      indent: 0,
      id: 0
    }];
    this.forStage = [];
    this.explicit = [];
    this.comments = [];
    this.isInterpolation = options.isInterpolation;
    this.isELSON = options.isELSON;

    // the current line:column
    this.cursor = options.cursor || {
      x: 1,
      y: 1
    };
    // whether to update column position if last token didn't manually
    this.forceCursorAtX = false;
    this.cantImport = options.cantImport ? options.cantImport : [this.filename];
    script = script.replace(/\r\n/g, '\n') + "\n";
    this.code = script;
    var i = 0;
    while (this.chunk = script.slice(i)) {
      if (this.isSimulation && options.cb(this, i)) {
        break;
      }
      let float = this.float;
      var consumed = this.isELSON ? this.Separator() || this.Whitespace() || this.Comment() || this.String() || this.KeywordStatement() || this.Number() || this.Literal() || this.Identifier() : this.Separator() || this.Whitespace() || this.Comment() || this.JSX() || this.String() || this.importPath() || this.Regex() || this.Assign() || this.AssignKeyword() || this.ImportExport() || this.KeywordStatement() || this.Type() || this.Number() || this.Literal() || this.Identifier();
      if (!consumed) {
        let msg = "unexpected token " + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.red)(this.chunk[0]);
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
          message: msg,
          location: {
            first_line: this.cursor.y,
            first_column: this.cursor.x,
            last_column: this.cursor.x + 1,
            last_line: this.cursor.y,
            src: this.filename ? (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename) : '<anonymous>'
          },
          type: 'SyntaxError'
        });
      }
      if (!this.forceCursorAtX) {
        this.cursor.x += consumed;
      }
      this.forceCursorAtX = false;
      if (this.isInterpolation && this.prev()[0] === "INTERPOLATION_END") {
        this.tokens.pop();
        break;
      }
      if (float && /IDENTIFIER|PROPERTY|INDEX_END/.test(this.prev()[0])) {
        this.prev()[2].type = this.float;
        this.float = null;
      } else if (float && this.prev()[0] === ":" && this.tokens.length > 1 && /IDENTIFIER|PROPERTY|INDEX_END/.test(this.tokens[this.tokens.length - 2][0])) {
        this.tokens[this.tokens.length - 2][2].type = this.float;
        this.float = null;
      }
      i = i + consumed;
    }
    this.closeTo(0);
    this.close();
    if (this.tokens.length === 1 && this.tokens[0][0] == "NEWLINE") {
      this.tokens = [];
    }
    this.fix();
    this.length = i;
    if (typeof fs__WEBPACK_IMPORTED_MODULE_3__.existsSync === "function" && !options.isDefinitions && this.filename && this.filename !== "<anonymous>") {
      let deff = this.filename.split('.').slice(0, -1).join('.') + '.d.rc';
      let deft = (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.dirname, deff);
      if ((0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(deft)) {
        let {
          comments
        } = new Lexer((0,fs__WEBPACK_IMPORTED_MODULE_3__.readFileSync)(deft, {
          encoding: 'utf-8'
        }), {
          filename: deff,
          dirname: this.dirname,
          isDefinitions: true
        });
        this.comments.unshift(...comments.map(c => {
          [c[2].last_column, c[2].last_line] = [-1, -1];
          return c;
        }));
      }
    }
    if ((typeof process !== "undefined" && process.argv.includes("-t") || options.streamTokens) && !this.isInterpolation) console.log(this.tokens);
  }
  Type() {
    let ref;
    if (ref = /^<([:?])?/.exec(this.chunk)) {
      let canAdd;
      if (ref[1] === undefined) {
        if (!this.Callable.includes(this.prev()[0])) return;
        if (this.prev().spaced) return;
        canAdd = true;
      }
      let index = 1,
        chevrons = [];
      while (this.chunk.charAt(index)) {
        index++;
        if (this.chunk.charAt(index) === ">" && !chevrons.length) break;else if (this.chunk.charAt(index) === ">") {
          chevrons.pop();
        } else if (this.chunk.charAt(index) === "<") {
          chevrons.push(1);
        }
      }
      let reg = /^<([:?])?(.+)>$/;
      let part = reg.exec(this.chunk.slice(0, index + 1));
      if (!part) return;
      let [input, optional, type] = part;
      optional = optional === '?';
      let tokens,
        nodes = (() => {
          let retv;
          try {
            retv = _index_js__WEBPACK_IMPORTED_MODULE_1__["default"].compile(`type PARTIAL = ${type}`, {
              cursor: {
                x: this.cursor.x - 13,
                y: this.cursor.y
              },
              filename: this.filename,
              dirname: this.dirname,
              sdir: this.sdir,
              nodes: true,
              startPosition: this.position - 1
            });
          } catch (_) {}
          tokens = retv.tokens;
          return retv.nodes;
        })();
      if (!nodes) {
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
          message: 'Invalid type',
          location: {
            first_column: this.cursor.x + 2,
            first_line: this.cursor.y,
            last_line: this.cursor.y,
            last_column: this.cursor.x + 2 + type.length,
            src: this.filename ? (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename) : '<anonymous>'
          },
          type: 'SyntaxError'
        }, this.code.split('\n')[this.cursor.y - 1]);
      }
      let typeToken = {
        value: type.trim(),
        nodes: nodes.visit(1, 1, 0, 1, 1, 1, 2),
        optional,
        loc: {
          first_column: this.cursor.x,
          first_line: this.cursor.y,
          last_line: this.cursor.y,
          last_column: this.cursor.x + input.length
        }
      };
      if (canAdd) {
        let pair = this.position + 1;
        this.token('<(', '<', {
          pair,
          loc: {
            ...typeToken.loc,
            first_line: typeToken.loc.last_line,
            first_column: typeToken.loc.last_column + 1
          }
        });
        this.tokens.push(...tokens.slice(3));
        this.token(')>', '>', {
          pair,
          loc: {
            ...typeToken.loc,
            last_line: typeToken.loc.first_line,
            last_column: typeToken.loc.first_column + 1
          }
        });
      } else if (this.stage().typeKwd) {
        if (this.uncontinuous.includes(this.prev()[0])) {
          if (this.isPossibleArray()) {
            this.createImplicitArray();
          }
          this.token('NEWLINE', 0, {
            generated: true
          });
        }
        this.token('TAG', typeToken);
      } else if (this.prev()[0] && /IDENTIFIER|PROPERTY|INDEX_END|PARAM_END/.test(this.prev()[0])) {
        this.prev()[2].type = typeToken;
      } else if (this.prev()[0] === ":" && this.tokens.length > 1 && /IDENTIFIER|PROPERTY|INDEX_END/.test(this.tokens[this.tokens.length - 2][0])) {
        this.tokens[this.tokens.length - 2][2].type = typeToken;
        this.float = null;
      } else this.float = typeToken;
      this.isTypeScript = true;
      return input.length;
    } else if ((ref = /^:=/.exec(this.chunk)) || (ref = /^[&|?:](:)/.exec(this.chunk)) || (ref = /^:/.exec(this.chunk)) && this.prev().spaced && (this.stage().quotedIf === undefined || !this.stage().quotedIf.length)) {
      let i = ref[0].length - 1,
        symbols = [],
        str = ref[0],
        virtualLoc = {
          x: this.cursor.x + i,
          y: this.cursor.y
        },
        offset = 0;
      let inStrictType;
      while (++i) {
        if (!this.chunk.charAt(i)) break;
        virtualLoc.x++;
        let char = this.chunk.charAt(i),
          z;
        if (/[<[{(]/.test(char)) {
          symbols.push(char);
        } else if (/^[\s ]+/.test(char) && str.trim() === ref[0]) {
          str += " ";
          offset++;
          continue;
        } else if ((z = /^\s*(\|(?!\|)|&(?!&))\s*/.exec(this.chunk.slice(i))) || (z = /^\s*(typeof|keyof|new)\s+/.exec(this.chunk.slice(i)))) {
          str += z[0];
          i += z[0].length - 1;
          continue;
          // support function types as "(x) => typeof Colors[number]"
        } else if (/\)\s*$/.test(str) && (z = /^\s*[=-]>\s*/.exec(this.chunk.slice(i)))) {
          str += z[0];
          i += z[0].length - 1;
          continue;
        } else if (/[^\w)\]}>]/.test(char) && !symbols.length || /[)\]}>]/.test(char) && !symbols.length) break;
        if (/^[)\]}>]/.test(char)) {
          let closure = {
            '>': '<',
            '}': '{',
            ']': '[',
            ')': '('
          }[char];
          if (symbols.pop() !== closure) {
            let msg = "unexpected token " + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.red)(char);
            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
              message: msg,
              location: {
                first_line: virtualLoc.y,
                first_column: virtualLoc.x,
                last_column: virtualLoc.x + 1,
                last_line: virtualLoc.y,
                src: this.filename ? (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename) : '<anonymous>'
              },
              type: 'SyntaxError'
            }, this.code.split("\n")[virtualLoc.y - 1]);
          }
        }
        str += char;
      }
      if (symbols.length) {
        let msg = "unmatched " + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.red)(symbols.pop()) + ` at end of ${!this.chunk[i] ? 'input' : 'line'}`;
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
          message: msg,
          location: {
            first_line: virtualLoc.y,
            first_column: virtualLoc.x,
            last_column: virtualLoc.x + 1,
            last_line: virtualLoc.y,
            src: this.filename ? (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename) : '<anonymous>'
          },
          type: 'SyntaxError'
        }, this.code.split("\n")[virtualLoc.y - 1]);
      }
      let reg = /^([&:?!|])?:(=)?(.+)/;
      if (inStrictType) str = str.replace(/^[&:?!|]/, '&:');
      let part = reg.exec(str);
      if (!part) return;
      let [input, optional, returns, type] = part;
      let len = type.length;
      optional = optional === '?';
      let nodes = (() => {
        let retv;
        try {
          retv = _index_js__WEBPACK_IMPORTED_MODULE_1__["default"].compile(`type PARTIAL = ${type}`, {
            cursor: {
              x: this.cursor.x - 13 + (offset ? offset - 1 : 0),
              y: this.cursor.y
            },
            filename: this.filename,
            dirname: this.dirname,
            sdir: this.sdir,
            nodes: true
          }).nodes;
        } catch (_) {}
        return retv;
      })();
      if (!nodes) {
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
          message: 'Invalid type',
          location: {
            first_column: this.cursor.x + 2,
            first_line: this.cursor.y,
            last_line: this.cursor.y,
            last_column: this.cursor.x + 2 + len,
            src: this.filename ? (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename) : '<anonymous>',
            sdir: this.sdir
          },
          type: 'SyntaxError'
        }, this.code.split('\n')[this.cursor.y - 1]);
      }
      let typeToken = {
        value: type.trim(),
        optional,
        nodes: nodes.visit(1, 1, 0, 1, 1, 1, 2),
        loc: {
          first_column: this.cursor.x,
          first_line: this.cursor.y,
          last_line: this.cursor.y,
          last_column: this.cursor.x + input.length
        }
      };
      if (returns) {
        let stage = this.stages.length - this.stages.map(i => i).reverse().findIndex(s => s.type === "indent" || s.type === "explicit");
        this.close(undefined, undefined, true);
        if (!["indent", "explicit", "indent&call"].includes(this.stage().type)) {
          this.closeTo(stage, true);
        }
        if (this.prev()[0] === "WITH") {
          this.token('PARAM_START', '(', {
            generated: true
          });
          this.token('PARAM_END', ')', {
            generated: true
          });
        }
        if ((this.prev()[0] === "PARAM_END" || this.prev()[0] === ")>") && !this.stage().typeKwd) {
          this.token('THEN', 'then', {
            generated: true,
            origin: ':=, possibly missing function body',
            last_column: this.cursor.x + 2
          });
        }
      }
      if (this.prev()[0] && /(VAR)?IDENTIFIER|PROPERTY|INDEX_END|\}|\]|PARAM_END|TH(EN|IS)/.test(this.prev()[0])) {
        this.prev()[2].type = typeToken;
      } else if (this.prev()[0] === ":" && this.tokens.length > 1 && /(VAR)?IDENTIFIER|PROPERTY|INDEX_END/.test(this.tokens[this.tokens.length - 2][0])) {
        this.tokens[this.tokens.length - 2][2].type = typeToken;
        this.float = null;
      } else {
        let msg = 'Value expected before type reference';
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
          message: msg,
          location: {
            first_line: this.cursor.y,
            first_column: this.cursor.x,
            last_line: this.cursor.y,
            last_column: this.cursor.x,
            src: this.filename ? (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename) : '<anonymous>'
          },
          type: 'SyntaxError'
        }, this.code.split("\n")[this.cursor.y - 1]);
      }
      this.isTypeScript = true;
      return i;
    }
  }
  AssignKeyword() {
    let reg;
    if (reg = /^(const|var|let|local|type|interface)\s/.exec(this.chunk)) {
      let token = reg[1],
        tag = token;
      if (token === "local") tag = "let";
      if (!["POSTFOR", "FOR"].includes(this.prev()[0])) {
        if (token !== "type" && token !== "interface") {
          this.stage().assignKwd = token;
        } else {
          this.stage().typeKwd = token;
          this.stage().typeKwdOrigin = true;
          this.isTypeScript = true;
        }
      } else {
        this.forAssignLine = this.cursor.y;
      }
      this.token(tag.toUpperCase(), token, {
        $$accept: token !== "type"
      });
      return token.length;
    }
  }
  ImportExport() {
    let ref;
    if (ref = /^(import|export)\s/.exec(this.chunk)) {
      let [, token] = ref;
      if (this.prev()[0] == ".") {
        this.token('PROPERTY', token);
      } else {
        this.token(token.toUpperCase(), token);
        this.opLine = token;
        this.opLevel = this.stages.length;
        this.portLine = this.cursor.y;
      }
      return token.length;
    }
  }
  MatchJSX(c) {
    let Allowed = /\/|[^\x00-\x7F\xA0-\xBF\xD7\xF7]|[a-z$_\d]/i,
      Strict = /:|\.|-|=|"|'/;
    if (/^<(?:(\/)?(((?:[^\x00-\x7F\xA0-\xBF\xD7\xF7]|[a-z$_\d])(?:[^\x00-\x7F\xA0-\xBF\xD7\xF7]|[a-z$_\d:\-])*)|>))/i.test(c)) {
      let consumed = "<",
        chunk = c,
        i = 1,
        leading = ['>'],
        cursor = {
          x: 0,
          y: 0
        },
        leadingPos = [cursor],
        spaced,
        tag = "",
        char,
        isEscaped;
      while ((char = chunk.charAt(i)) && leading.length) {
        let accept;
        if (char === '\n') {
          cursor.y++;
          cursor.x = 0;
        }
        cursor.x++;
        if (!isEscaped && char == leading[leading.length - 1]) {
          consumed += leading.pop();
          leadingPos.pop();
          i++;
          continue;
        }
        if (!isEscaped && leading.includes(char) && leading[leading.length - 1] !== char) {
          return {
            errorMsg: `unexpected token ${char}`,
            coords: cursor
          };
        }
        var isSpace = /\s/.test(char);
        if (!spaced && !isSpace && char !== "/" && (Allowed.test(char) || /:|\./.test(char))) {
          tag += char;
          // don't accept any other char as the ID
        } else if (!spaced && !isSpace && char !== "/") {
          spaced = true;
        }
        if (isSpace) {
          accept = true;
          spaced = true;
        }
        if (!isEscaped && char === "\\") {
          accept = true;
          isEscaped = true;
        }
        if (/'|"|\{/.test(char) && !isEscaped && leading.length === 1) {
          accept = true;
          leading.push({
            "{": "}"
          }[char] || char);
          leadingPos.push(cursor);
        }
        isEscaped = false;
        let Previous = consumed.charAt(consumed.length - 1);
        if (/\s/.test(Previous)) {
          Previous = "";
        }
        if (accept || leading.length > 1 || Allowed.test(char) || Allowed.test(Previous) && Strict.test(char) || char == "-" && Previous == "-") {
          consumed += char;
          i++;
        } else return {
          errorMsg: `unexpected token ${char} in JSX element`,
          coords: cursor
        };
      }
      if (leading.length) return {
        errorMsg: `missing ${leading.pop()} in JSX element`,
        coords: leadingPos.pop()
      };
      return {
        match: consumed,
        tag
      };
    } else return {};
  }
  JSX() {
    let reg = this.MatchJSX(this.chunk);
    if (reg.match && (!this.prev().length || this.Opening.includes(this.prev()[0]) || ['AS', 'AT', 'FROM', 'DEFAULTS', ':', 'NEWLINE'].includes(this.prev()[0]) || /*[...this.Callable, ...this.postfixeables].includes(this.prev()[0]) &&*/this.prev().spaced)) {
      if ("IDENTIFIER SUCH SUPER PROPERTY ] INDEX_END CALL_END ) } SYMBOL_EXISTS )>".split(' ').includes(this.prev()[0]) && this.prev().spaced) {
        let b = this.skipped === this.indentLevel;
        if (b && this.inExplicit()) {
          this.skipped.pop();
        }
        if (this.prev()[0] === "SYMBOL_EXISTS") {
          this.prev()[0] = "FUNC_EXISTS";
        }
        this.token('CALL_START', '(', {
          generated: true
        });
        ++this.indentLevel;
        this.insertStage('call', 'implicit', 1);
      } else if (this.uncontinuous.includes(this.prev()[0]) && this.prev().spaced) {
        if (this.isPossibleArray()) {
          this.createImplicitArray();
        }
        this.token('NEWLINE', 0, {
          generated: true
        });
      }
      let leading = [],
        position = this.position,
        pairs = [],
        i = 0,
        chunk = this.chunk,
        char = "",
        prevChar = "",
        fragments = [],
        lastFragment = i,
        cursor = {
          ...this.cursor
        };
      let indentLevel = this.indentLevel;
      let leadingPos = [cursor];
      while (char = chunk.charAt(i)) {
        let onTop = !['"', "'"].includes(pairs[pairs.length - 1]);
        if (char === "\n") {
          cursor.x = 0;
          cursor.y++;
        }
        let indentMatch = new RegExp("^(\\n[\\s]*?)+((\\t| {" + this.tabSize + "})+|)?"),
          indentValue;
        if (indentValue = indentMatch.exec(chunk.slice(i))) {
          let [input,, indent] = indentValue;
          let check;
          while (check = new RegExp("^\\n((\\t| {" + this.tabSize + "})+|)").exec(chunk.slice(i + input.length))) {
            input += check[0];
            indent = check[1];
          }
          let newlines = input.split('').filter(n => n == "\n").length;
          if (typeof indent == "undefined") {
            indent = 0;
          } else indent = indent.split(new RegExp(" {" + this.tabSize + "}|\t", "g")).slice(1).length;

          // Anyway, we update it before everything else
          cursor.y += newlines;
          cursor.x = input.split('\n').pop().length + 1;
          if (i - lastFragment > 0) fragments.push(this._token('STRING', chunk.slice(lastFragment, i)));
          if (indent > indentLevel) {
            var tag = "INDENT";
            while (indentLevel !== indent) {
              ++indentLevel;
            }
            fragments.push(this._token('INDENT', input, {
              $$accept: true,
              pair: position,
              indent: true
            }));
          } else if (indent < indentLevel) {
            --indentLevel;
            fragments.push(this._token('OUTDENT', indent));
          }
          position++;
          i += input.length;
          lastFragment = i;
          continue;
        }
        if (char === "<" && onTop) {
          let {
            tag,
            match,
            errorMsg,
            coords
          } = this.MatchJSX(chunk.slice(i));
          if (errorMsg) {
            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
              message: errorMsg,
              location: {
                first_line: cursor.y + coords.y,
                first_column: cursor.x + coords.x,
                last_column: cursor.x + coords.x + 1,
                last_line: cursor.y + coords.y,
                src: (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename)
              },
              type: 'error'
            });
          } else {
            let selfClosing = /\/\s*>$/.test(match) && tag,
              matchedClosing = /^<\//.test(match);
            if (selfClosing && matchedClosing) {
              (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
                message: 'a JSX element may close itself, or may close another element, but not both',
                location: {
                  first_line: cursor.y,
                  first_column: cursor.x,
                  last_column: cursor.x + match.length,
                  last_line: cursor.y,
                  src: (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename)
                },
                type: 'error'
              });
            } else {
              if (matchedClosing) {
                let last = leading.pop();
                if (tag !== last) {
                  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
                    message: last ? `expected <${last}> to be closed before closing <${tag}>` : `<${tag}> must be opened first before closing it`,
                    location: {
                      first_line: cursor.y,
                      first_column: cursor.x,
                      last_column: cursor.x + match.length,
                      last_line: cursor.y,
                      src: (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename)
                    },
                    type: 'error'
                  });
                }
              } else if (!selfClosing) {
                leading.push(tag);
                leadingPos.push({
                  ...cursor
                });
              }
            }
          }
        }
        cursor.x++;
        i++;
        if (char === "{" && onTop) {
          let tokens, length, isTypeScript;
          ({
            tokens,
            length,
            isTypeScript
          } = new Lexer(chunk.slice(i), {
            isInterpolation: true,
            cursor
          }));
          fragments.push(this._token('STRING', chunk.slice(lastFragment, i - 1)), this._token('INTERPOLATION_START', '{'), ...tokens, this._token('INTERPOLATION_END', '}'));
          lastFragment = i + length + 1;
          prevChar = '}';
          i += length + 1;
          if (isTypeScript) this.isTypeScript = true;
          continue;
        }
        if (char === "'" || char === '"') {
          if (!pairs.length) pairs.push(char);else if (pairs[pairs.length - 1] === char) pairs.pop();
        }
        prevChar = char;
        if (char === '>' && onTop && !leading.length) {
          fragments.push(this._token('STRING', chunk.slice(lastFragment, i)));
          break;
        }
      }
      if (leading.length) {
        cursor = leadingPos.pop();
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
          message: `missing closing </${leading.pop()}>`,
          location: {
            first_line: cursor.y,
            first_column: cursor.x,
            last_column: cursor.x,
            last_line: cursor.y,
            src: (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename)
          },
          type: 'error'
        });
      }
      let pair = this.position + 1;
      this.tokens.push(this._token('JSX_START', '', {
        pair
      }), ...fragments, this._token('JSX_END', '', {
        pair
      }));
      return i;
    }
    return 0;
  }
  Literal() {
    let ref, reg, isColon;
    if (this.isELSON) {
      reg = /^(\[|\{|\}|\]|:|,|-?>|=>?|[*-])/;
      isColon = /^(:|=>?|-?>)/.test(this.chunk);
    } else {
      reg = /^([=!]==|=[<>=]|->|([+-/%!^]|[<>*&|]{1,2})=|[*<>]{1,2}|\|{1,2}|&{1,2}|;|:(?!:)|\.\.\.|\??\.|\?{1,2}|@|\,|\-{1,2}|\+{1,2}|\^|\/|\[|\]|\{|\}|\(|\)|\!|~|=)/;
    }
    if (ref = reg.exec(this.chunk)) {
      let [input, token] = ref,
        pair,
        origin,
        output = true;
      if (isColon) {
        if (!/]|}/.test(this.prev()[0])) this.prev().spaced = false;
        origin = token;
        token = ":";
      }
      if (this.isELSON && /^[*-]$/.test(token)) {
        if (this.prev()[0] === "NEWLINE" && this.prev().isNext2GenArr) {
          this.tokens.splice(-2, 2, this._token('NEWLINE', 0, {
            generated: true
          }));
          this.storeBefore(['array', this.position]);
        } else {
          if (this.isPossibleArray()) {
            this.createImplicitArray(this.prev()[0] === 'INDENT');
          } else if (!["NEWLINE", "INDENT"].includes(this.prev()[0])) {
            this.token('NEWLINE', 0);
          }
        }
        return 1;
      }
      if (!/\.(\.\.)?/.test(token) && (this.prev()[0] === ',' || this.prev()[0] === "NEWLINE" && this.prev().comma) && this.inImplicitObj()) {
        let comma = this.tokens.pop();
        this.closeImplicitObjects(false, true);
        this.tokens.push(comma);
      }
      if (!this.isELSON && /\{|\[|\.(\.\.)?/.test(token) && (token === "." && !this.prev()[0] || ["IDENTIFIER", "PROPERTY", "SYMBOL_EXISTS"].includes(this.prev()[0]) && this.prev().spaced && !(/^\s*(\n|;)/.test(this.chunk.slice(token.length)) && this.opLine) || this.prev()[0] && !["IDENTIFIER", "PROPERTY", "]", "INDEX_END", "STRING_END", "STRING", "REGEX", "REGEX_END", ".", ")", "CALL_END", "}", "THIS", "SUCH", "SUPER", "OUTDENT"].includes(this.prev()[0]))) {
        if (!/\{ *\n/.test(this.chunk) & this.prev() && this.prev()[0] && "IDENTIFIER SUCH SUPER PROPERTY ] INDEX_END ) CALL_END } SYMBOL_EXISTS".split(' ').includes(this.prev()[0])) {
          let b;
          if (this.prev()[0] === "IDENTIFIER" && (this.inClass() && !(b = this.skipped === this.indentLevel) || this.assertTokens("CLASS IDENTIFIER", "CLASS IDENTIFIER <( .+ )>") !== undefined)) {
            this.token('PARAM_START', '(', {
              generated: true,
              pair: this.position
            });
            this.paramLine = true;
            this.prev().stageId = this.store(['param', this.position]);
            this.prev().fromClass = this.inClass();
          } else if (!this.stage().typeKwd) {
            if (b) {
              this.skipped.pop();
            }
            if (this.inClass() && this.opLine) {
              this.opLine = false;
              this.opLevel = -1;
            }
            if (this.prev()[0] === "SYMBOL_EXISTS") {
              this.prev()[0] = "FUNC_EXISTS";
            }
            this.token('CALL_START', '(', {
              generated: true,
              pair: this.position
            });
            ++this.indentLevel;
            this.insertStage('call', 'implicit', 1);
          }
        } else if (!/\{ *\n/.test(this.chunk) && this.opLine && this.prev() && (this.prev()[0] == "WITH" || this.prev()[0] === "WITHIN") || this.prev()[0] === ")>" && this.funcLine === this.cursor.y && !this.stages.find(s => s.contains.find(c => c.includes("param"))) || this.assertTokens('CLASS IDENTIFIER') !== undefined) {
          this.token('PARAM_START', '(', {
            generated: true,
            pair: this.position
          });
          this.paramLine = true;
          this.prev().pair = this.indentLevel;
          this.prev().stageId = this.store(['param', this.position]);
        }
        if (token === ".") this.token('THIS', 'this', {
          generated: true
        });
      }
      if (token == ";" && (this.forLine !== this.cursor.y || this.forStage[this.forStage.length - 1] !== this.stages.length)) {
        let stage = this.stages.length - this.stages.map(i => i).reverse().findIndex(s => s.type === "indent" || s.type === "explicit");
        this.close();
        if (!["indent", "explicit", "indent&call"].includes(this.stage().type)) {
          this.closeTo(stage);
        }
        if (this.stage().typeKwd && this.inExplicit() && this.prev()[0] !== ",") {
          this.token(',', ',', {
            generated: true
          });
        }
        this.token('NEWLINE', Math.max((/^\n+/.exec(this.chunk.slice(1)) || [""])[0].length - 1, 0), {
          origin: ';',
          generated: true
        });
        return 1;
      }
      if (token === ":" && this.trueStage().label === "switch" && this.opLine && /\s*\n/.test(this.chunk.slice(1))) {
        return 1;
      } else if (token === ":" && !this.prev().spaced && [']', 'STRING', 'STRING_END'].includes(this.prev()[0]) && !(this.currExplicit() === "}")) {
        let tk = [];
        if (this.prev()[0] === "STRING") {
          tk = [this.tokens.pop()];
        } else if (["STRING_END", "]"].includes(this.prev()[0])) {
          let id = this.tokens.findIndex(t => t[0] === this.prev()[0].replace('END', 'START').replace(']', '[') && t.pair === this.prev().pair);
          tk = this.tokens.splice(id, this.tokens.length - id);
          if (this.prev()[0] === "READONLY") {
            tk.unshift(this.tokens.pop());
          }
        }
        if (!this.stage().contains.find(o => o[0] === "object")) {
          tk = tk.map(t => ++t.lvl && t);
          if (this.prev()[0] == "NEWLINE" && this.prev()[1] === 0 && (this.prev().isNext2GenObj || (this.tokens.slice(-2)[0] || [])[0] === "}")) {
            let brace = this.tokens.slice(-2)[0];
            let stageId = this.tokens.slice(-2)[0].stageId;
            this.tokens.splice(this.tokens.length - 2, 2);
            this.tokens.push(this._token('NEWLINE', 0, {
              inImplicitObj: true
            }));
            this.storeAt(stageId, ['object', brace ? brace.pair : this.position]);
          } else {
            this.tokens.push(this._token('{', '{', {
              generated: true,
              pair: this.position
            }));
            this.stage().lastValue = this.prev().stageId = this.store(['object', this.position]);
          }
        } else {
          if (this.prev()[0] === ":") {
            this.tokens.push(this._token('{', '{', {
              generated: true,
              pair: this.position
            }));
            this.prev().stageId = this.store(['object', this.position]);
          }
        }
        this.tokens = [...this.tokens, ...tk];
      } else if (token === ":" && this.assertTokens('CLASS IDENTIFIER <( .+ )>') !== undefined) {
        this.token('EXTENDS', 'extends', {
          generated: true
        });
        return 1;
      } else if (token === ":" && this.prev().spaced && this.stage().quotedIf && this.stage().quotedIf.length) {
        let stage = this.stages.length - this.stages.map(i => i).reverse().findIndex(s => s.type === "indent" || s.type === "explicit");
        this.close(false, 0, true);
        if (!["indent", "explicit", "indent&call"].includes(this.stage().type)) {
          this.closeTo(stage, true);
        }
      }
      let Open = ["(", "[", "{"],
        Close = [")", "]", "}"],
        prev = this.prev(),
        insertThen;
      let x;
      if (this.explicit.find(explicit => explicit[0] === ")>") || this.stage().typeKwd || this.funcLine === this.cursor.y || this.assertTokens('CLASS', 'CLASS IDENTIFIER', 'CLASS IDENTIFIER WITH') !== undefined || (x = this.prev()[0] === "WITH" || this.prev()[0] === "WITHIN")) {
        Open.push('<');
        Close.push('>');
      }
      var _ref, closure;
      if ((_ref = Open.indexOf(token)) > -1) {
        if (token === "(" && ![...this.Opening, "NEWLINE"].includes(prev && prev[0]) && (prev && ["FUNCTION", "WITH", "WITHIN", ...this.Callable].includes(prev[0]) || this.assertTokens('CLASS IDENTIFIER') !== undefined || this.stage().typeKwd === "interface")) {
          let z;
          if (this.funcLine === this.cursor.y || this.prev()[0] === "WITH" || this.prev()[0] === "WITHIN" || this.prev()[0] === ")>" && this.funcLine === this.cursor.y && !this.stages.find(s => s.contains.find(c => c.includes("param"))) || this.assertTokens('CLASS IDENTIFIER') !== undefined) {
            _ref = "PARAM_END";
            token = "PARAM_START";
          } else if ((this.inClass() || this.stage().typeKwd === "interface") && (this.prev()[0] === "IDENTIFIER" || this.prev()[0] === ")>" || this.prev().spaced && (this.prev()[0] === "WITH" || this.prev()[0] === "WITHIN") && (!this.stage().typeKwd && this.funcLine === this.cursor.y || this.stage().typeKwd === "interface") && !this.stages.find(s => s.contains.find(c => c.includes("param"))) || (z = !this.prev()[2].generated && ["INDENT", "NEWLINE"].includes(this.prev()[0])))) {
            _ref = "PARAM_END";
            token = "PARAM_START";
            if (z) this.token("WITH", "with", {
              generated: true,
              spaced: true
            });
          } else if (this.Callable.includes(this.prev()[0])) {
            if (this.currExplicit() === "}" && this.stage().label === undefined && this.prev()[0] === "IDENTIFIER" && /^(NEWLINE|INDENT|,|\{)$/.test(this.tokens.slice(-2)[0][0])) {
              token = "PARAM_START";
              _ref = "PARAM_END";
              if (!this.opLine) {
                this.opLine = "function";
                this.opLevel = this.stages.length;
                this.funcLine = this.cursor.y;
              }
            } else {
              if (this.prev()[0] === "SYMBOL_EXISTS") {
                this.prev()[0] = "FUNC_EXISTS";
              }
              if (this.prev()[0] === "IMPORT") {
                this.prev()[0] = "IDENTIFIER";
              }
              token = "CALL_START";
              _ref = "CALL_END";
            }
          } else {
            _ref = ")";
          }
        } else if (!this.isELSON && token === "[" && !this.prev().spaced && this.indexables.includes(this.prev()[0])) {
          token = "INDEX_START";
          _ref = "INDEX_END";
        } else if (!this.isELSON && token === "[" && !this.prev().spaced && this.prev()[0] === "." && this.tokens.slice(-2)[0] && this.tokens.slice(-2)[0][0] === "THIS" && this.tokens.slice(-2)[0][2].generated) {
          this.tokens.pop();
          token = "INDEX_START";
          _ref = "INDEX_END";
        } else if (token === "<") {
          if (x) {
            this.funcLine = this.cursor.y;
            this.opLevel = this.stages.length;
            this.opLine = 'function';
          }
          _ref = ")>";
          token = "<(";
        } else {
          _ref = Close[_ref];
        }
        if (token !== "{" && !/^\{ *\n/.test(this.chunk) && token !== "PARAM_START" && token !== "<(" && (this.prev()[0] === "WITH" || this.prev()[0] === "WITHIN" || this.prev()[0] === ")>" && this.funcLine === this.cursor.y && !this.stages.find(s => s.contains.find(c => c.includes('param'))))) {
          this.token('PARAM_START', '(', {
            generated: true,
            pair: this.position
          });
          if (!this.opLine) {
            this.opLine = 'function';
            this.opLevel = this.stages.length;
          }
          this.paramLine = true;
          this.prev().stageId = this.store(['param', this.position]);
        } else if (token !== "(" && token !== "CALL_START" && token !== "<(" && !(this.stage().typeKwd && token === "{") && !this.opLine && "SUCH SUPER IDENTIFIER PROPERTY ] INDEX_END CALL_END ) } SYMBOL_EXISTS".split(' ').includes(this.prev()[0]) && this.prev().spaced && !this.paramLine) {
          let b = this.skipped === this.indentLevel;
          if (b && this.inExplicit()) {
            this.skipped.pop();
          }
          if (this.prev()[0] === "SYMBOL_EXISTS") {
            this.prev()[0] = "FUNC_EXISTS";
          }
          this.token('CALL_START', '(', {
            generated: true,
            pair: this.position
          });
          ++this.indentLevel;
          this.insertStage('call', 'implicit', 1);
        }
        let inExplicit = this.inExplicit();
        let cc = /^(WHILE|UNTIL|WITH|WITHIN|CATCH|FOR)$/.test(this.prev()[0]) && !this.prev().cc && token === "(";
        if (cc) {
          this.prev().cc = true;
          output = false;
        }
        if (token == "{" && (this.funcLine === this.cursor.y || this.opLine && !inExplicit) && [...this.postfixeables.slice(0, 8), "THEN"].includes(this.prev()[0])) {
          if (!(this.prev()[0] === "DEFAULTS") && !(this.prev()[0] === ",") && !(this.prev()[0] === ":")) {
            this.close();
            this.closeTo(this.opLevel);
            if (this.funcLine === this.cursor.y) this.funcLine = -1;
            if (this.prev()[0] !== "THEN" && this.inClass()) {
              this.token("THEN", "", {
                generated: true
              });
            }
          }
        }
        this.explicit.push([_ref, this.indentLevel, pair = output ? this.position + 1 : this.position, this.stages.length, cc]);
        let prevStage = this.stage(),
          prevTrueStage = this.trueStage();
        this.insertStage('explicit', _ref, 0);
        if (prevStage.typeKwd || prevTrueStage.typeKwd) {
          this.stage().typeKwd = prevStage.typeKwd || prevTrueStage.typeKwd;
        }
      } else if (Close.includes(token)) {
        let __ = this.rmNL();
        let $ref = token;
        if (token === ")" && this.currExplicit() === "CALL_END") $ref = "CALL_END";else if (token === "]" && this.currExplicit() === "INDEX_END") $ref = "INDEX_END";else if (token === ")" && this.currExplicit() === "PARAM_END") {
          $ref = "PARAM_END";
          this.paramLine = false;
        } else if (token === "}" && this.currExplicit() === "}}") $ref = token = "}}";else if (token === "}" && !this.explicit.length && this.isInterpolation) {
          $ref = token = "INTERPOLATION_END";
        } else if (token === ">") {
          $ref = token = ")>";
        }
        if (this.explicit.slice(-1)[0] && this.currExplicit() === $ref || $ref === "INTERPOLATION_END") {
          let _lv = $ref === "INTERPOLATION_END" ? 0 : this.explicit.slice(-1)[0][3];
          this.close();
          this.closeTo(_lv);
          this.rmNL();
          closure = this.explicit.pop() || $ref;
          if (Array.isArray(closure) && closure[4]) insertThen = true;
        } else {
          if (!this.explicit.length) {
            throw "unexpected " + token;
          } else {
            throw `${this.cursor.y}:${this.cursor.x}` + " missing " + this.currExplicit();
          }
        }
      }
      if ("[()]".split("").includes(token)) {
        switch (token) {
          case "(":
          case "[":
            {
              if (token === "(" && ![...this.Opening, "NEWLINE"].includes(prev[0]) && (!prev || ["FUNCTION", "WITH", "WITHIN"].includes(prev[0]) || !prev.spaced)) {
                if (this.funcLine === this.cursor.y || this.prev()[0] === "WITH" || this.prev()[0] === "WITHIN" || this.assertTokens('CLASS IDENTIFIER') !== undefined) {
                  if (this.funcLine === this.cursor.y) this.funcLine = -1;
                  token = "PARAM_START";
                  this.paramLine = true;
                } else if (this.inClass() && (this.prev()[0] === "IDENTIFIER" || this.prev().spaced && (this.prev()[0] === "WITH" || this.prev()[0] === "WITHIN") || !this.prev()[2].generated && ["INDENT", "NEWLINE"].includes(this.prev()[0]))) {
                  token = "PARAM_START";
                  this.paramLine = true;
                } else if ("SUCH SUPER IDENTIFIER PROPERTY ] INDEX_END CALL_END ) } SYMBOL_EXISTS".split(" ").includes(this.prev()[0])) {
                  if ((this.inExplicit() || this.currExplicit() === "}" && this.stage().label === undefined) && this.prev()[0] === "IDENTIFIER" && /^(NEWLINE|INDENT|,|\{)$/.test(this.tokens.slice(-2)[0][0])) {
                    token = "PARAM_START;";
                  } else {
                    if (this.prev()[0] === "SYMBOL_EXISTS") {
                      this.prev()[0] = "FUNC_EXISTS";
                    }
                    token = "CALL_START";
                  }
                } else token = "(";
              } else if (!this.isELSON && token === "[" && !this.prev().spaced && this.indexables.includes(this.prev()[0])) {
                token = "INDEX_START";
              } else if (!this.isELSON && token === "[" && !this.prev().spaced && this.prev()[0] === "." && this.tokens.slice(-2)[0] && this.tokens.slice(-2)[0][0] === "THIS" && this.tokens.slice(-2)[0][2].generated) {
                token = "INDEX_START";
              }
              break;
            }
            ;
          case ')':
          case ']':
            {
              token = closure[0];
              break;
            }
            ;
        }
        ;
      }
      if (token === ",") {
        if (this.stage().label !== ")") {
          this.rmNL();
        } else {
          if (this.stage().label === ")" && !this.stage().contains.length && ![this.forLine, this.funcLine, this.portLine].includes(this.cursor.y)) {
            token = "NEWLINE";
          }
        }
      }
      if (token === "|" && this.prev()[0] === "NEWLINE" && !this.prev()[2].generated && this.prev()[1] < 2 && !this.stage().typeKwd) {
        this.rmNL();
        output = false;
        input = /^(\|\s*)/.exec(this.chunk)[0];
      }
      if ((token === "|" || token === "&") && this.stage().typeKwd) {
        token = "TYPE_JOIN";
      }
      if (/^(\^|[&|]{1,2}|\+|\-|\*|\/|\%|[<>]{2,3})=/.test(token)) {
        origin = token;
        token = 'MATH_BIN';
      }
      if (/^(===?|!==?|[><]=?)$/.test(token) && /^(&&|AND)$/.test(this.prev()[0])) {
        this.prev()[2].origin = this.prev()[1];
        this.prev()[0] = "COMPOUND_AND"; // If not in a When or Multicondition rule, it will throw anyways.
      }
      if (token === "/") {
        token = "DIVISION";
        origin = "/";
      }
      if (/^([-=]>|=)$/.test(token)) {
        switch (this.prev()[0]) {
          case "]":
          case "}":
            {
              let lp = this.tokens.map(t => t[0] === (this.prev()[0] === "]" ? "[" : "{") && t.pair).lastIndexOf(this.prev().pair),
                Param = this.tokens.slice(lp);
              this.tokens.splice(lp, Param.length, this._token('PARAM_START', '(', {
                generated: true
              }), ...Param, this._token('PARAM_END', ')', {
                generated: true
              }));
              break;
            }
            ;
          default:
            {
              let x;
              if ("THIS . PROPERTY" === this.tokens.slice(-3).map(i => i[0]).join(" ") && this.tokens.slice(-3)[0].generated) {
                x = 3;
              } else if (this.prev()[0] === "IDENTIFIER") {
                x = 1;
              }
              if (x) {
                this.tokens.splice(this.tokens.length - x, 0, this._token('PARAM_START', '(', {
                  generated: true
                }));
                this.token('PARAM_END', ')', {
                  generated: true
                });
              } else {
                if (this.prev()[0] === ')') {
                  let brace = this.prev();
                  this.tokens.forEach(token => {
                    token.pair === brace.pair && (token[0] = {
                      "(": "PARAM_START",
                      ")": "PARAM_END"
                    }[token[0]]);
                  });
                } else if (this.prev()[0] !== "PARAM_END") {
                  if (this.uncontinuous.includes(this.prev()[0]) && this.isPossibleArray()) {
                    this.createImplicitArray();
                  }
                  if (this.uncontinuous.includes(this.prev()[0])) {
                    if (!['NEWLINE', 'INDENT', 'CALL_START', 'INDEX_START', '[', '{'].includes(this.prev()[0])) {
                      this.token('NEWLINE', 0, {
                        generated: true
                      });
                    }
                    this.token('PARAM_START', '(', {
                      generated: true
                    });
                    this.token('PARAM_END', ')', {
                      generated: true
                    });
                  }
                }
              }
              break;
            }
        }
        ;
        if (!this.opLine) {
          this.opLine = "FUNC_DIRECTIVE";
          this.opLevel = this.stages.length;
        }
        token = "FUNC_DIRECTIVE";
      }
      if (token === "?" && ["SUCH", "SUPER", "IDENTIFIER", "PROPERTY", "]", "INDEX_END", "CALL_END", ")", "}"].includes(this.prev()[0]) && !this.prev().spaced) {
        token = "SYMBOL_EXISTS";
        origin = "?";
      } else if (token === "?") {
        (this.stage().contains[this.stage().contains.length - 1] || {}).break = true;
      }
      if (token === "?.") {
        origin = token;
        token = ".";
      }
      if (token === "?") {
        if (!this.stage().quotedIf) this.stage().quotedIf = [];
        this.stage().quotedIf.push(1);
      }
      if (token === ':') {
        if (!this.stage().quotedIf) this.stage().quotedIf = [];
        this.stage().quotedIf.pop();
      }
      if (token === "::" && !this.prev().spaced && ["IDENTIFIER", "PROPERTY", "]", ")", "}", "CALL_END", "INDEX_END", "}", "THIS", "SUCH"].includes(this.prev()[0]) && !/^\s+/.test(this.chunk.slice(input.length))) {
        return 0;
      }

      // if (insertThen) {
      //   this.token('THEN', 'then', { generated: true });
      //   this.prev().canBlock = true;
      //   output = false;
      //   this.opLine = false;
      //   this.opLevel = -1;
      // }

      if (output) {
        if (/^([<>=!]=|[!=]==|>{1,3}|<{1,2}|\*{1,2}|\^|%|&{1,2}|\|{1,2}|\?|:|DIVISION|MATH_BIN|\}|\]|,|\)|INDEX_END|CALL_END|PARAM_END)$/.test(token)) {
          this.rmNL();
        }
        this.token(token, input, {
          pair: pair ? pair : closure && closure[2] || undefined,
          origin
        });
      }
      if (token === "PARAM_START") this.paramLine = true;
      if (token === "PARAM_END") this.paramLine = false;
      if (token === "(") this.prev().$$accept = true;
      if (token === "," || token === "..." && this.isPossibleArray()) {
        if ((this.forLine !== this.cursor.y || this.forLineArrayGen) && this.isPossibleArray()) {
          this.createImplicitArray(undefined, token === "...");
        } else if (this.forLine === this.cursor.y) {
          if (this.prev()[0] === ",") this.prev().$$accept = true;
          this.forLineArrayGen = true;
        }
      }
      if (token === "," && this.stage().assignKwd) {
        this.stage().seenEquals = false;
      }
      return input.length;
    }
  }
  Number() {
    let ref,
      exp = /^(0b[01](?:_?[01])*n?|^0o[0-7](?:_?[0-7])*n?|^0x[\da-f](?:_?[\da-f])*n?|^\d+n|^-?(?:\d(?:_?\d)*)?\.?(?:\d(?:_?\d)*)+(?:e[+-]?(?:\d(?:_?\d)*)+)?)(:)?/i;
    if (exp.test(this.chunk)) {
      let [, match, colon] = exp.exec(this.chunk),
        tag;
      if (match.startsWith(".") && !this.prev().spaced) return;
      if (colon) return; // pass to Identifier instead

      if (this.prev()[0] === ".") {
        match = match.indexOf(".") > -1 ? match.slice(0, match.indexOf(".")) : match;
        this.tokens.pop();
        this.token("INDEX_START", "[", {
          generated: true
        });
        this.token("NUMBER", match);
        this.token("INDEX_END", "]", {
          generated: true
        });
        this.prev()[2].first_column = this.cursor.x + match.length;
        return match.length;
      } else {
        if ("SUCH SUPER IDENTIFIER PROPERTY ] INDEX_END CALL_END ) } SYMBOL_EXISTS".split(' ').includes(this.prev()[0]) && this.prev().spaced) {
          let b = this.skipped === this.indentLevel;
          if (b && this.inExplicit()) {
            this.skipped.pop();
          }
          if (this.prev()[0] === "SYMBOL_EXISTS") {
            this.prev()[0] = "FUNC_EXISTS";
          }
          this.token('CALL_START', '(', {
            generated: true
          });
          ++this.indentLevel;
          this.insertStage('call', 'implicit', 1);
        } else if (this.uncontinuous.includes(this.prev()[0]) && this.prev().spaced) {
          if (this.isPossibleArray()) {
            this.createImplicitArray();
          }
          this.token('NEWLINE', 0, {
            generated: true
          });
        }
        let comma;
        if ((comma = this.prev()[0] === ",") && this.inImplicitObj()) {
          let i = this.stage().contains.findIndex(s => s[0] === "object");
          this.close(false, i);
          if (this.isPossibleArray()) {
            this.createImplicitArray();
          }
          this.token('NEWLINE', 0, {
            isNext2GenObj: true,
            generated: true
          });
        }
        if (parseInt(match) === 2e308) {
          tag = "INFINITY";
        } else {
          tag = "NUMBER";
        }
      }
      this.token(tag, match);
      return match.length;
    }
  }
  Whitespace() {
    if (/^( )+/.test(this.chunk)) {
      this.prev().spaced = true;
      return /^( )+/.exec(this.chunk)[0].length;
    }
  }
  Identifier() {
    let isNumber,
      reg = this.isELSON ? /^()((?:[^\x00-\x7F]|[a-z$_])(?:[^\x00-\x7F]|[a-z$_\d])*)(\s*(:|=>?|-?>))/i : /^(::)?((?:[^\x00-\x7F]|[a-z$_])(?:[^\x00-\x7F]|[a-z$_\d])*)(\??:(?!:))?/i,
      numReg = this.isELSON ? /^()(0b[01](?:_?[01])*n?|^0o[0-7](?:_?[0-7])*n?|^0x[\da-f](?:_?[\da-f])*n?|^\d+n|^(?:\d(?:_?\d)*)?\.?(?:\d(?:_?\d)*)+(?:e[+-]?(?:\d(?:_?\d)*)+)?)(\s*(:|=>?|-?>))/i : /^(::)?(0b[01](?:_?[01])*n?|^0o[0-7](?:_?[0-7])*n?|^0x[\da-f](?:_?[\da-f])*n?|^\d+n|^(?:\d(?:_?\d)*)?\.?(?:\d(?:_?\d)*)+(?:e[+-]?(?:\d(?:_?\d)*)+)?)(\??:(?!:))?/i;
    if (reg.test(this.chunk) || numReg.test(this.chunk) && (isNumber = true)) {
      let [input, proto, token, colon] = (!isNumber ? reg : numReg).exec(this.chunk),
        tag,
        isExtend,
        optionalSymbol;
      if (colon === "?:" && !this.stage().typeKwd && !this.paramLine) {
        colon = false;
        input = token;
      } else if (colon === "?:") {
        optionalSymbol = colon;
      }
      if (proto) {
        [['.'], ['PROPERTY', 'prototype'], ['.']].forEach(([t, v = t]) => {
          this.token(t, v, {
            generated: true,
            origin: '::'
          });
        });
      }
      let prev = this.prev();
      if (this.isELSON && !colon) return;
      if (prev && prev[0] && prev.spaced && "SUCH SUPER IDENTIFIER PROPERTY ] CALL_END ) } SYMBOL_EXISTS )>".split(' ').includes(prev[0]) || this.stage().typeKwd === "interface" && this.prev()[0] === "NEW") {
        if (this.isELSON) return;
        let b;
        if ((prev[0] === "IDENTIFIER" || prev[0] === ")>") && this.inClass() && !(b = this.skipped === this.indentLevel) || this.funcLine === this.cursor.y || this.assertTokens("CLASS IDENTIFIER", "CLASS IDENTIFIER <( .+ )>") !== undefined || this.stage().typeKwd === "interface") {
          this.token('PARAM_START', '(', {
            generated: true,
            pair: this.position
          });
          if (!this.stage().typeKwd && !this.opLine) {
            this.opLine = 'function';
            this.opLevel = this.stages.length;
          }
          this.paramLine = true;
          this.prev().stageId = this.store(['param', this.position]);
          this.prev().fromClass = this.inClass();
        } else {
          if (b && this.inExplicit()) {
            this.skipped.pop();
          }
          if (this.inClass() && this.opLine) {
            this.opLine = false;
            this.opLevel = -1;
          }
          if (this.prev()[0] === "SYMBOL_EXISTS") {
            this.prev()[0] = "FUNC_EXISTS";
          }
          prev = this.token('CALL_START', '(', {
            generated: true
          });
          ++this.indentLevel;
          this.insertStage('call', 'implicit', 1);
        }
      } else if (this.opLine && prev && (prev[0] == "WITH" || prev[0] == "WITHIN")) {
        this.token('PARAM_START', '(', {
          generated: true,
          pair: this.position
        });
        this.paramLine = true;
        this.prev().stageId = this.store(['param', this.position]);
      }
      if (this.prev()[0] === ".") {
        tag = "PROPERTY";
      } else {
        tag = "IDENTIFIER";
        if (this.uncontinuous.includes(this.prev()[0]) && this.prev().spaced) {
          if (this.isELSON) return;
          if (this.isPossibleArray()) {
            this.createImplicitArray();
          }
          this.token('NEWLINE', 0, {
            generated: true
          });
        }
        if (colon && this.prev()[0] === "CLASS") {
          colon = false;
          isExtend = true;
        }
      }
      let i;
      if (tag == "IDENTIFIER" && !colon && this.prev()[0] == "," && (i = this.stage().contains.findIndex(s => s[0] === "object")) > -1) {
        this.tokens.pop();
        this.closeImplicitsTo(i, false);
        if (this.isPossibleArray()) {
          // flaghere
          this.createImplicitArray();
        }
        this.token('NEWLINE', 0, {
          isNext2GenObj: true,
          generated: true
        });
      }
      if (tag === "IDENTIFIER" && !colon && this.prev().comma && this.isPossibleArray()) {
        if (["indent", "unfinished"].includes(this.stage().type)) {
          // flaghere
          this.createImplicitArray();
        }
      }
      if (!colon && tag === "IDENTIFIER" && (token === "this" || token === "such" || token === "super" || token === "function")) {
        tag = token.toUpperCase();
      }
      let b = this.trueStage().label === "switch" && (this.opLine || /^(default|otherwise|else)$/.test(token)) && /^\s*(\{\s*)?\n/.test(this.chunk.slice(input.length));
      this.token(tag, token);
      if ((tag == "IDENTIFIER" || tag == "VARIDENTIFIER" || tag == "THIS" || tag == "SUCH" || tag == "SUPER" || this.assertTokens('THIS . PROPERTY') !== undefined && this.tokens.slice(-3)[0][2].generated && this.paramLine) && colon && (this.inExplicit() && /^(A[ST]|FROM|:|\[|\(|PARAM_START|DEFAULTS)$/.test(prev[0]) || (!this.inExplicit() || this.currExplicit() !== "}") && (this.currExplicit() !== "}" || this.stage().label !== undefined)) && !b) {
        if (!this.stage().contains.find(o => o[0] === "object")) {
          let prev = this.tokens.pop();
          ++prev.lvl;
          prev[0] = "PROPERTY";
          if (this.prev()[0] == "NEWLINE" && this.prev()[1] === 0 && (this.prev().isNext2GenObj || (this.tokens.slice(-2)[0] || [])[0] === "}")) {
            let brace = this.tokens.slice(-2)[0];
            let stageId = this.tokens.slice(-2)[0].stageId;
            this.tokens.splice(this.tokens.length - 2, 2);
            this.tokens.push(this._token('NEWLINE', 0, {
              inImplicitObj: true
            }), prev);
            this.storeAt(stageId, ['object', brace ? brace.pair : this.position]);
          } else {
            let prevs = [prev];
            if (this.prev()[0] === "..." || this.prev()[0] === "READONLY") {
              prevs = [this.tokens.pop(), ...prevs];
            } else if (this.assertTokens('THIS .') !== undefined) {
              prevs = [...this.tokens.splice(this.tokens.length - 2, 2), ...prevs];
            }
            this.tokens.push(this._token('{', '{', {
              generated: true,
              pair: this.position
            }), ...prevs);
            this.stage().lastValue = this.prev().stageId = this.store(['object', this.position]);
          }
        } else {
          let prev = this.tokens.pop();
          prev[0] = "PROPERTY";
          let prevs = [prev];
          if (this.prev()[0] === "...") {
            prevs = [this.tokens.pop(), ...prevs];
          } else if (this.assertTokens('THIS .') !== undefined) {
            prevs = [...this.tokens.splice(this.tokens.length - 2, 2), ...prevs];
          }
          if (this.prev()[0] === ":") {
            this.tokens.push(this._token('{', '{', {
              generated: true,
              pair: this.position
            }), ...prevs);
            this.prev().stageId = this.store(['object', this.position]);
          } else this.tokens = [...this.tokens, ...prevs];
        }
        this.token(':', ':', {
          first_column: this.cursor.x + input.length - 1,
          last_column: this.cursor.x + input.length,
          origin: optionalSymbol
        });
        colon = false;
      }
      if (tag === "IDENTIFIER" && /^(yes|no)$/.test(token)) {
        if (/^(yes|no)$/.test(token)) {
          this.prev()[2].origin = token;
          this.prev()[1] = token === "yes" ? "true" : "false";
          this.prev()[0] = "BOOL";
        }
      }
      if (["SWITCH", "FOR", "UNLESS", "WHILE", "FUNCTION"].includes(tag)) {
        if (tag === "FUNCTION") {
          this.funcLine = this.cursor.y;
        }
        this.opLine = tag.toLowerCase();
        this.opLevel = this.stages.length;
        if (this.tokens.slice(-2)[0] && /^(A[ST]|FROM|:)$/.test(this.tokens.slice(-2)[0][0])) {
          (this.stage().contains[this.stage().contains.length - 1] || [{}])[0].break = true;
        }
      }
      if (colon && !b) {
        this.prev()[0] = "PROPERTY";
        this.token(':', ':', {
          first_column: this.cursor.x + input.length - 1,
          last_column: this.cursor.x + input.length,
          origin: optionalSymbol
        });
      } else if (colon) {
        if (tag === "IDENTIFIER" && /^(default|otherwise|else)$/.test(token)) {
          this.prev()[2].origin = this.prev()[1];
          this.prev()[0] = "DEFAULT";
          this.opLevel = this.trueStageLevel() + 1;
          this.opLine = "default";
        }
      } else if (isExtend) {
        this.token('EXTENDS', 'extends', {
          generated: true
        });
      }
      if (!this.names.includes(token)) {
        this.names.push(token);
      }
      return input.length;
    }
  }
  KeywordStatement() {
    // every keyword below, either as JavaScript's or Relic's ones, have their own tag
    // since Relic is literate-like script, we reserve a bunch of keywords
    let reg = this.isELSON ? /^(true|false|yes|no|null|nil|undefined)(:)?(?!(?:[^\x00-\x7F]|[a-zA-Z$_])(?:[^\x00-\x7F]|[a-zA-Z$_\d])*)/ : /^(into|as|and|or|plus|includes|has|function\*?|[gs]et|static|i[fn]|of|or|not|true|false|undefined|nil|null|new|delete|return|void|yield|await|async|either|do|with(?:in)?|whil(?:e|st)|for|whe(?:n|ther)|unless|until|else|loop|has|try|catch|finally|otherwise|then|exists|class(?:\*)?|extends|implements|typeof|keyof|instanceof|is\s+not|is(?:nt)?|defaults?|continue|break|switch|case|when|on|throw|readonly|debugger|using)(:(?!:))?(?!(?:[^\x00-\x7F]|[a-zA-Z$_])(?:[^\x00-\x7F]|[a-zA-Z$_\d])*)/;
    if (reg.test(this.chunk) || !this.isELSON && ((reg = /^(@)\s*/).test(this.chunk) || (reg = /^(with(?:in)?(?=[([{<]))/).test(this.chunk)) || (reg = /^(=(?!(?:>|=)))/).test(this.chunk)) {
      let output = true,
        input,
        [, token, colon] = reg.exec(this.chunk),
        origin;
      input = token;
      if (this.prev()[0] == "." && token !== "=") {
        this.token('PROPERTY', token.split(' ')[0]);
        return this.prev()[1].length;
      } else {
        if (colon) {
          return;
        }
        if (this.inClass() && /^[gs]et(;|\s|:)?$/.test(token) && !["NEWLINE", "INDENT"].includes(this.prev()[0])) {
          return;
        }
        if (token === "readonly" && this.stage().typeKwd !== "interface" || token === "new" && this.stage().typeKwd === "interface") return;
      }
      token = token.split(' ').join('');
      if (token == "extending") {
        origin = token;
        token = 'extends';
      }
      if (token === "isnot" || token === "isn't") {
        origin = token;
        token = "isnt";
      }
      ;
      if (token === "function*") {
        token = "function";
        origin = "function*";
      }
      if (token === "=" && [")", "PARAM_END"].includes(this.prev()[0])) return;
      if (token === "default" && !(this.inSwitch() && this.portLine !== this.cursor.y && this.prev()[0] === "NEWLINE") || token === "=" || token === "as") {
        this.rmNL();
        origin = token;
        token = "defaults";
      } // when an assign word (either 'default', 'as' or '=') that is inside a parameter scope, will be transformed into defaults

      if ((token === "otherwise" || token === "else") && this.inSwitch() && this.prev()[0] === "NEWLINE") {
        [origin, token] = [token, 'default'];
      }
      if (token === "defaults" && !this.paramLine) {
        token = "default";
        origin = origin || "defaults";
        if (this.prev()[0] === ":") {
          this.tokens.pop();
        }
        if (this.prev()[0] === "PROPERTY") {
          this.prev()[0] = "IDENTIFIER";
        } else {
          this.rmNL();
        }
      }
      if (token === "otherwise") {
        [token, origin] = ["else", token];
      }
      if (token === "nil") {
        [origin, token] = [token, 'null'];
      }
      if (token === "yes") {
        [origin, token] = [token, 'true'];
      }
      if (token === "no") {
        [origin, token] = [token, 'false'];
      }
      if (token === "class*") {
        [origin, token] = [token, 'class'];
      }
      if ((this.prev()[0] === "," || this.prev()[0] === ":" && ["defaults"].includes(token) && origin !== "=") && this.inImplicitObj()) {
        let pop;
        if (this.prev()[0] === ",") pop = this.tokens.pop();
        this.closeImplicitObjects(!!pop && token !== "defaults", true);
      }
      if (token === "either") {
        this.stage().eitherLine = this.cursor.y;
        if (this.inSwitch()) {
          this.opLine = token;
          this.opLevel = this.stages.length;
        }
      }
      if (["and", "or", "in", "of", "is", "isnt", "extends", "implements"].includes(token)) {
        this.rmNL();
        let z;
        if (["in", "of"].includes(token) && this.forLine === this.cursor.y) {
          origin = token;
          token = "for_" + token;
          this.forLine = -1;
          this.forAssignLine = -1;
          z = this.forLineArrayGen;
          delete this.forLineArrayGen;
          this.forStage.pop();
        }
        let stage = this.stages.length - this.stages.map(i => i).reverse().findIndex(s => s.type === "indent" || s.type === "explicit");
        this.close();
        if (!["indent", "explicit", "indent&call"].includes(this.stage().type)) {
          this.closeTo(stage);
        }
        if ((this.prev()[0] === "]" || z) && token === "for_in") {
          token = "for_as"; // don't mind me, this has to be done.
        }
        if (token === "or" && this.stage().eitherLine === this.cursor.y) token = "either_or";
      }
      if (!this.isELSON && (this.postfixeables.includes(this.prev()[0]) && 'if switch case when within while whilst class new delete await async do for until loop unless @ whether function plus includes has true false undefined null catch finally try'.split(' ').includes(token) || token === "with" && this.prev()[0] && ["PROPERTY", "INDEX_END", "}", "}}", "CALL_END", "SUPER", "SUCH"].includes(this.prev()[0]))) {
        if (!["RETURN", "BREAK", "CONTINUE", "STRING", "STRING_END", "NUMBER", "UNDEFINED", "NULL", "BOOL", "THIS", "REGEX", "REGEX_END", "INFINITY"].includes(this.prev()[0]) && (!["if", "when", "on", "whilst", "for", "unless", "while", "until", "return", "break", "loop", "continue", "function", "plus", "includes", "has", "else", "finally", "catch"].includes(token) || token === "case" && !this.inSwitch())) {
          if (this.prev()[0] === "SYMBOL_EXISTS") {
            this.prev()[0] = "FUNC_EXISTS";
          }
          this.token('CALL_START', '(', {
            generated: true
          });
          ++this.indentLevel;
          this.insertStage('call', 'implicit', 1);
        } else if (["if", "for", "unless", "while", "until", "else", "catch", "finally", "when", "on", "whilst", "includes", "has", "plus"].includes(token) || token === "case" && this.inSwitch()) {
          let stage = this.stages.length - this.stages.map(i => i).reverse().findIndex(s => s.type === "indent" || s.type === "explicit");
          this.close();
          if (!["indent", "explicit", "indent&call"].includes(this.stage().type)) {
            this.closeTo(stage);
          }
          let origin;
          if (["catch", "finally"].includes(token)) {
            this.opLine = token;
            this.opLevel = this.stages.length;
          }
          if (token === "for") {
            this.forLine = this.cursor.y;
            this.forStage[this.forStage.length] = this.stages.length;
          }
          if (token === "while" && this.forLine === this.cursor.y) {
            token = "whilst";
            origin = 'while';
          }
          if (this.inSwitch() && this.prev()[0] === "NEWLINE" && (token === "when" || token === "case" || token === "on")) this.stage().eitherLine = this.cursor.y;
          if (!this.inSwitch() && token == "when" && this.prev()[0] == "]" && this.prev()[2].generated && this.forLine === this.cursor.y) {
            this.tokens = this.tokens.filter(t => {
              return !(/\[|\]/.test(t[0]) && t.pair == this.prev().pair);
            });
          }
          this.rmNL();
          this.token({
            if: "POSTIF",
            unless: "POSTUNLESS",
            for: "POSTFOR",
            while: "POSTWHILE",
            until: "POSTUNTIL",
            case: "POSTCASE",
            on: "POSTCASE",
            when: this.forLine === this.cursor.y ? "WHEN" : "POSTCASE"
          }[token] || token.toUpperCase(), token, {
            $$accept: true,
            origin
          });
          return token.length;
        } else if (this.uncontinuous.includes(this.prev()[0]) && this.prev().spaced) {
          if (this.isPossibleArray()) {
            this.createImplicitArray();
          }
          this.token('NEWLINE', 0, {
            generated: true
          });
          (this.stage().contains[this.stage().contains.length - 1] || {}).break = true;
        }
      } else if (!this.isELSON && [":", "=", "AS", "FROM", "AT"].includes(this.prev()[0]) && ["if", "unless", "switch", "for", "while", "try", "with", "within", "either", "async", "until"].includes(token)) {
        (this.stage().contains[this.stage().contains.length - 1] || []).break = true;
      }
      if (["case", "or", "on", "if", "when"].includes(token) && this.inSwitch() && this.prev()[0] === "OR") {
        this.prev()[0] = "COMPOUND_OR";
        this.prev()[2].origin = "OR";
      }
      if (token === "case" && !this.inSwitch() || token === "whether") {
        token = "!";
        this.token('!', '!', {
          origin: 'case'
        });
      }
      if (token == "if" || token == "switch" || token == "case" || token == "on" || token == "when" || token == "while" || token == "class" || token == "with" || token == "within" || token == "function" || token == "else" || token == "otherwise" || token == "return" || token == "unless" || token == "until" || token == "loop" || token == "for" || token == "try" || token == "catch" || token == "async" || token == "finally" || token == "using" || !this.inClass() && this.stage().typeKwd !== "interface" && /[gs]et/.test(token)) {
        if (!this.opLine || this.opLine === "else" || this.opLine === "otherwise") {
          // What do we know?
          if (!/[gs]et/.test(token)) {
            this.opLine = token;
            this.opLevel = this.stages.length;
          } else {
            return;
          }
        }
        if (token == "function") {
          this.funcLine = this.cursor.y;
        }
        if (token == "async" && this.funcLine !== this.cursor.y) {
          this.funcLine = this.cursor.y;
        }
        if (token === "for") {
          this.forLine = this.cursor.y;
        }
        if ((token === "with" || token === "within") && undefined === this.assertTokens("CLASS IDENTIFIER", "CLASS IDENTIFIER <( .+ )>")) {
          let travel = this.assertTokens(`IDENTIFIER <( .+ )>`, `IDENTIFIER`, `<( .+ )>`);
          let crop = travel !== undefined ? this.popTokens(travel) : [];
          let _prevTag = () => this.prev()[0];
          while (/ASYNC|[GS]ET|STATIC/.test(_prevTag())) {
            crop.unshift(this.tokens.pop());
          }
          if ("FUNCTION" !== _prevTag()) {
            this.token(`FUNCTION`, `function`, {
              generated: true,
              origin: token
            });
          }
          if (crop.length) this.tokens.push(...crop);
        }
      }
      if (token == "else" || token == "otherwise" || token == "then" || token === "into" || token == "or" || token == "in" || token == "either_or" || token == "and" || token == "catch" || token == "finally") {
        this.rmNL();
      }
      let _type;
      if (token == "then" && this.opLine && this.opLevel === this.trueStageLevel()) {
        this.rmNL();
        this.close();
        this.closeTo(this.opLevel);
        this.actExp = this.opLine;
        this.opLine = false;
        this.opLevel = -1;
        if (this.actExp === "if" && this.prev()[0] !== ")") {
          let lookup = [...this.tokens].reverse().findIndex(t => {
            return t[0] === "IF" && this.stage().id === t.stage;
          });
          if (lookup > -1) {
            let rearrange = this.popTokens(this.tokens.length - lookup);
            let pair = this.position + 1;
            this.token('(', '(', {
              generated: true,
              pair
            });
            this.tokens.push(...rearrange);
            this.token(')', ')', {
              generated: true,
              pair
            });
          }
        }
        if (this.prev()[0] === "THEN") {
          if (this.prev()[2].generated) {
            _type = this.tokens.pop()[2].type;
          }
          this.tokens.pop();
        }
      } else if (token === "then" || token === "into") {
        this.closeTo(this.trueStageLevel());
        origin = token;
        token = 'CHAIN';
      }
      if (/^(true|false|null|undefined)$/.test(token)) {
        this.token(/true|false/.test(token) ? "BOOL" : token.toUpperCase(), token.trim(), {
          origin
        });
      } else if (output) {
        this.token(token.trim().toUpperCase(), token.trim(), {
          origin,
          $$accept: token !== "!"
        });
        if (_type) this.prev()[2].type = _type;
      }
      return input.length;
    }
  }
  Assign() {
    let reg = /^((?:at|from|as)(:)?\s|=(?!(?:=|>)))/;
    if (reg.test(this.chunk)) {
      let [, token, colon] = reg.exec(this.chunk),
        len = token.length,
        origin,
        wordlenght;
      token = token.trim();
      wordlenght = token.length;
      if (token === "=" && ["PARAM_END", ")"].includes(this.prev()[0])) {
        return;
      }
      if (token == "=" || token == "as") {
        if (this.paramLine) {
          return;
        }
        if (token == "=") {
          if (this.prev()[0] === ":") {
            this.tokens.pop();
            if (this.prev()[0] === "PROPERTY" && (this.tokens.slice(-2)[0] || [])[0] !== ".") {
              this.prev()[0] = "IDENTIFIER";
            }
          }
          origin = token;
          token = "as";
        } else if (this.prev()[0] === "DEFAULTS") {
          this.prev()[0] = "DEFAULT";
        } else if (this.prev()[0] === "EXPORT") {
          origin = token;
          token = "default";
        }
      } else {
        if (this.prev()[0] == "." && !colon) {
          this.token('PROPERTY', token);
          return len;
        } else {
          if (colon) {
            return;
          }
        }
      }
      this.rmNL();
      let ch = token === "as" && (this.portLine === this.cursor.y || this.stage().type === "indent" && (this.stage().label === "import" || this.stage().label === "export"));
      if (!origin) {
        if (!ch) this.closeImplicitObjects();
        this.assignLine = -1;
        if (token !== 'as' && this.forLine === this.cursor.y) {
          this.forLine = -1;
          this.forAssignLine = -1;
          delete this.forLineArrayGen;
          token = "for_" + token;
          this.close(false);
        }
      }

      // as from, as at...
      if (token !== "as" && !origin && this.prev()[0] === "AS") {
        this.tokens.pop();
        origin = "as " + token;
      }
      this.token(token.toUpperCase(), token, {
        origin,
        $$accept: origin !== "=" || this.stage().typeKwd || this.inClass()
      });
      if (this.inClass()) {
        this.skipped = this.indentLevel;
      }
      if (this.stage().assignKwd) this.stage().seenEquals = true;
      return wordlenght;
    }
  }

  // We treat newlines and semicolons here. If a newline is followed by a tab or at least 4 spaces, or if the prev token's tag is unfinished, it's called indent. 
  Separator() {
    let reg = new RegExp("^(\\n[\\s]*?)+((\\t| {" + this.tabSize + "})+|)?");
    if (reg.test(this.chunk)) {
      let [input,, indent] = reg.exec(this.chunk),
        unfinished = this.isUnfinished();
      let check;
      while (check = new RegExp("^\\n((\\t| {" + this.tabSize + "})+|)").exec(this.chunk.slice(input.length))) {
        input += check[0];
        indent = check[1];
      }
      let newlines = input.split('').filter(n => n == "\n").length;
      if (typeof indent == "undefined") {
        indent = 0;
      } else indent = indent.split(new RegExp(" {" + this.tabSize + "}|\t", "g")).slice(1).length;
      let currPosition = {
        ...this.cursor
      }; // We don't use 'this.cursor' directly to avoid inconsistences

      // Anyway, we update it before everything else
      currPosition.y += newlines;
      currPosition.x = input.split('\n').pop().length + 1;
      const updatePosition = () => {
        this.cursor.y = currPosition.y;
        this.cursor.x = currPosition.x;
        this.forceCursorAtX = true;
      };
      if (this.inClass() && this.prev()[0] === "PROPERTY") {
        if (this.opLine) {
          this.opLine = false;
          this.opLevel = -1;
        }
      }
      if (this.opLine) {
        this.closeTo(this.opLevel, true);
        this.rmNL();
        this.actExp = this.opLine;
        this.opLine = false;
        this.opLevel = -1;
        this.forceIndent = true;
        if (this.funcLine === this.cursor.y) this.funcLine = -1;
      }
      var aligned = input.split('\n').pop().slice((this.trueStage().indent - 1) * this.tabSize) + /^\s*/.exec(this.chunk.slice(input.length))[0],
        seemsLikeAligned = true;
      if (!this.inTrueExplicit() && this.trueStage().assignKwd && aligned.length === this.trueStage().assignKwd.length + 1) {
        this.closeToIndent(false, this.trueStage().indent);
      }
      if (indent == this.indentLevel) {
        if (this.prev()[0] === "{" && this.actExp) {
          this.explicit[this.explicit.length - 1][0] = "}}";
          this.prev()[0] = "{{";
        }
        this.actExp = false;
        let comma;
        if (this.prev()[0] === "," || this.prev()[0] === "NEWLINE" && this.prev().comma) comma = this.tokens.pop();
        let dontMerge, nlloc;
        if (this.prev()[0] === "NEWLINE") {
          newlines += (nlloc = this.tokens.pop())[1];
        }
        if (newlines > 1) {
          this.close();
          dontMerge = true;
        } else {
          if (this.inClass()) {
            this.close();
          } else this.closeImplicitObjects(false, !!comma, !!comma);
          dontMerge = false;
        }
        if (this.stage().typeKwd && this.stage().typeKwdOrigin && this.assertTokens("TYPE IDENTIFIER AS") === undefined) {
          this.stage().typeKwd = "";
          this.stage().typeKwdOrigin = false;
        }
        this.stage().quotedIf = undefined;
        this.skipped = -1;
        let addNewlines = !this.Unfinished.includes(this.prev()[0]),
          /*
          dontMerge = (/]|}/.test(this.prev()[0]) || (this.prev().isNext2GenArr && this.prev().comma) || this.prev().isNext2GenObj) && newlines > 1,*/
          bool = this.stage().contains.length;
        if (comma) {
          this.rmNL();
        }
        if (addNewlines && newlines && bool) {
          this.token('NEWLINE', Math.max(newlines - 1, 0), {
            isNext2GenObj: !dontMerge && this.prev()[0] === "}" && this.prev()[2].generated,
            isNext2GenArr: !dontMerge && this.prev()[0] === "]" && this.prev()[2].generated,
            $$accept: !dontMerge
          });
        }
        if (addNewlines && this.prev()[0] !== "NEWLINE" && this.prev()[0] !== "INDENT") {
          this.token('NEWLINE', Math.max(newlines - 1, 0), {
            isNext2GenObj: !dontMerge && this.prev()[0] === "}" && this.prev()[2].generated,
            isNext2GenArr: !dontMerge && this.prev()[0] === "]" && this.prev()[2].generated,
            $$accept: true
          });
        }
        if (dontMerge) {
          this.prev().$$accept = true;
          delete this.prev().isNext2GenArr;
          delete this.prev().isNext2GenObj;
        }
        this.prev().comma = !!comma;
        if (newlines > 1 && this.stage().assignKwd) this.stage().assignKwd = "";
        if (this.inClass() && !this.opLine) {
          this.opLine = 'function';
          this.opLevel = this.stages.length;
        }
        if (bool) {
          this.prev().inImplicitObj = true;
        }
        if (this.stage().assignKwd) {
          this.stage().seenEquals = false;
        }
        if (this.prev()[0] === "NEWLINE" && nlloc) {
          Object.assign(this.prev()[2], {
            first_column: nlloc[2].first_column,
            first_line: nlloc[2].first_line
          });
        }
        updatePosition();
        return input.length;
      } else if (indent > this.indentLevel) {
        let bool;
        if (this.stage().contains.map(i => i[0]).includes('object') && this.prev()[0] !== ":") {
          bool = true;
        }
        if (this.actExp && this.prev()[0] !== "OUTDENT" && this.prev()[0] !== "NEWLINE" && !bool && this.prev()[0] !== "IF" && this.prev()[0] !== "SWITCH" && this.prev()[0] !== "WHILE" && this.prev()[0] !== "[" && this.prev()[0] !== "{" && this.prev()[0] !== "(" && this.prev()[0] !== ":" && !/^(A[ST]|FROM)$/.test(this.prev()[0])) {
          this.close(false, 0, true);
          let t;
          if (this.inClass()) {
            if (this.prev()[0] !== "PARAM_END" && this.prev()[0] !== "WITH" && this.prev()[0] !== "WITHIN" && this.prev()[0] == "IDENTIFIER") {
              this.token('WITH', 'with', {
                generated: true
              });
            }
          }
          if (this.inClass()) {
            t = true;
          }
          let indents = 0;
          while (this.indentLevel !== indent) {
            ++this.indentLevel;
            ++indents;
          }
          if (this.actExp === "if" && ![")", "THEN"].includes(this.prev()[0])) {
            let lookup = [...this.tokens].reverse().findIndex(t => {
              return t[0] === "IF" && this.stage().id === t.stage;
            });
            if (lookup > -1) {
              let rearrange = this.popTokens(this.tokens.length - lookup);
              let pair = this.position + 1;
              this.token('(', '(', {
                generated: true,
                pair
              });
              this.tokens.push(...rearrange);
              this.token(')', ')', {
                generated: true,
                pair
              });
            }
            this.token('THEN', 'then', {
              generated: true
            });
          }
          this.token('INDENT', input, {
            $$accept: true,
            pair: this.position + 1
          });
          this.insertStage('indent', this.actExp, indents);
          if (t && this.actExp !== "function") {
            while (this.prev()[0] === "NEWLINE") {
              this.tokens.pop();
            }
            this.opLine = this.actExp = 'function';
            this.opLevel = this.stages.length;
          } else this.actExp = false;
        } else {
          var tag = "INDENT",
            inArrayLevel = this.stage().contains.map(i => i[0]).includes('array'),
            inTypeStatement = this.stage().typeKwd,
            inAssignChain = !inTypeStatement && !!this.stage().assignKwd,
            output = true;
          let t,
            type = 'indent';
          let indents = 0;
          while (this.indentLevel !== indent) {
            ++this.indentLevel;
            ++indents;
          }
          let close = true;
          if (this.prev()[0] === "{" && this.actExp || this.prev()[0] === "{" && this.tokens[this.tokens.length - 2] && this.tokens[this.tokens.length - 2].canBlock) {
            this.explicit[this.explicit.length - 1][0] = "}}";
            this.prev()[0] = "{{";
          } else if ("IDENTIFIER SUCH SUPER PROPERTY ] INDEX_END CALL_END ) } SYMBOL_EXISTS".split(' ').includes(this.prev()[0]) && !this.actExp && !inAssignChain && !this.stage().typeKwd) {
            if (!this.inClass() || !(this.assertTokens("THIS . PROPERTY") === undefined || this.prev()[0] === "IDENTIFIER")) {
              if (this.prev()[0] === "SYMBOL_EXISTS") {
                this.prev()[0] = "FUNC_EXISTS";
              }
              tag = "CALL_START";
              type = "call";
              close = false;
            } else if (!["WITH", "PARAM_END"].includes(this.prev()[0])) {
              this.token("PARAM_START", "(", {
                generated: true
              });
              this.token("PARAM_END", ")", {
                generated: true
              });
            }
          } else if (!this.actExp && /^AT|AS|FROM|:$/.test(this.prev()[0])) {
            close = false;
          }
          if (close) this.close(false, 0, true);
          if ([inArrayLevel, inAssignChain].includes(true)) {
            if (this.prev()[0] === "NEWLINE") {
              this.tokens.pop();
            }
          }
          if (output) {
            this.insertStage(type === "call" ? "indent&call" : type, type === "call" ? "implicit" : this.actExp, indents);
            if (inAssignChain) {
              this.stage().assignKwd = inAssignChain;
            }
            if (inTypeStatement) {
              this.stage().typeKwd = inTypeStatement;
            }
            if (this.inClass()) {
              while (this.prev()[0] === "NEWLINE") {
                this.tokens.pop();
              }
              this.opLine = 'function';
              this.opLevel = this.stages.length;
            }
          }
          this.token(tag, input, {
            $$accept: true,
            pair: this.position,
            indent: true
          });
          this.actExp = false;
        }
        updatePosition();
        this.skipped = -1;
        return input.length;
      } else if (indent < this.indentLevel) {
        while (this.prev()[0] == "NEWLINE") {
          this.tokens.pop();
        }
        let comma;
        if (this.prev()[0] === ",") this.tokens.pop();
        this.closeToIndent(indent);
        if (!this.stage().contains.length || !(this.stage().type === "explicit")) {
          if (this.stage().type === "call") {
            this.close();
          }
          if (newlines > 1) {
            // we can add up to 2 newlines
            this.token('NEWLINE', Math.max(newlines - 1, 0), {
              $$accept: true
            });
          }
        }
        let dontMerge;
        if (newlines > 1) {
          this.close();
          dontMerge = true;
          this.stage().assignKwd = "";
        } else {
          this.closeImplicitObjects(false, !!comma, !!comma);
          dontMerge = false;
        }
        if (this.stage().typeKwdOrigin) {
          this.stage().typeKwd = "";
          this.stage().typeKwdOrigin = false;
        }
        if (this.prev()[0] !== "NEWLINE" && this.prev()[0] !== "INDENT") {
          this.token('NEWLINE', Math.max(newlines - 1, 0), {
            isNext2GenObj: this.prev()[0] === "}" && this.prev()[2].generated,
            isNext2GenArr: this.prev()[0] === "]" && this.prev()[2].generated,
            $$accept: !(/}|]/.test(this.prev()[0]) && !this.prev()[2].generated)
          });
        }
        this.prev().comma = !!comma;
        this.actExp = false;
        if (this.inClass()) {
          this.opLine = this.actExp = 'function';
          this.opLevel = this.stages.length;
        }
        this.skipped = -1;
        updatePosition();
        return input.length;
      }
      updatePosition();
      return input.length;
    }
  }
  Regex() {
    let match = /^(\/)((?:\n|.|[$#]\{(?:.|\n)+\})*)(?<!\\)\1/.exec(this.chunk);
    if (Array.isArray(match)) {
      let [input, slash, exp] = match,
        flags = "";
      let i = 1,
        chunk = this.chunk,
        char = "",
        prevChar = "",
        fragments = [],
        lastFragment = i,
        isInsideSet = false;
      while (char = chunk.charAt(i)) {
        if (char === slash && !isInsideSet && (prevChar !== "\\" || chunk.charAt(Math.max(0, i - 2)) === "\\")) {
          i++;
          if (flags = /^[gimsy]+/.exec(chunk.slice(i))) {
            flags = flags[0];
            i += flags.length;
          }
          break;
        }
        if (char === "[" && prevChar !== "\\") {
          isInsideSet = true;
        } else if (char === "]" && isInsideSet && prevChar !== "\\") {
          isInsideSet = false;
        }
        if (char === "{" && /[$#]/.test(prevChar) && (chunk.charAt(Math.max(0, i - 2)) !== "\\" || chunk.charAt(Math.max(0, i - 3)) === "\\")) {
          let tokens, length, isTypeScript;
          ({
            tokens,
            length,
            isTypeScript
          } = new Lexer(chunk.slice(i + 1), {
            isInterpolation: true,
            cursor: this.cursor,
            filename: this.filename
          }));
          fragments.push(this._token('REGEX', chunk.slice(lastFragment, i - 1)), this._token('INTERPOLATION_START', '${'), ...tokens, this._token('INTERPOLATION_END', '}'));
          lastFragment = i + length + 2;
          prevChar = '}';
          i += length + 2;
          if (isTypeScript) this.isTypeScript = true;
          continue;
        }
        i++;
        prevChar = char;
      }
      if (chunk.slice(lastFragment, i - 1)) fragments.push(this._token('REGEX', chunk.slice(lastFragment, i - 1)));
      if ("IDENTIFIER SUCH SUPER PROPERTY ] INDEX_END CALL_END ) } SYMBOL_EXISTS )>".split(' ').includes(this.prev()[0]) && this.prev().spaced) {
        let b = this.skipped === this.indentLevel;
        if (b && this.inExplicit()) {
          this.skipped.pop();
        }
        if (this.prev()[0] === "SYMBOL_EXISTS") {
          this.prev()[0] = "FUNC_EXISTS";
        }
        this.token('CALL_START', '(', {
          generated: true
        });
        ++this.indentLevel;
        this.insertStage('call', 'implicit', 1);
      }
      switch (fragments.length) {
        case 1:
          {
            fragments[0][1] = `/${fragments[0][1]}${flags ? flags : "/"}`;
            fragments[0][2].last_column += 2 + (flags && flags.length - 1 || 0);
            this.tokens.push(fragments[0]);
            break;
          }
          ;
        default:
          this.tokens.push(this._token('REGEX_START', slash), ...fragments, this._token('REGEX_END', flags));
          break;
      }
      return this.chunk.slice(0, i).length;
    }
  }
  importPath() {
    let reg = /^(([a-zA-Z]:[\/\\])?((?:(\w+|\.{1,2})[\/\\])+\w*(\.\w+)*|(?:(\w+|\.{1,2})[\/\\])*\w+(\.\w+)+)|\.)/i;
    if (reg.test(this.chunk) && this.prev()[0] === "IMPORT" && this.prev().spaced) {
      let match = reg.exec(this.chunk);
      if (!match[0]) return;
      if (typeof fs__WEBPACK_IMPORTED_MODULE_3__.existsSync !== 'function') {
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
          message: 'Unable to load imports in browser compiler. This function should only be used when bundling.',
          location: {
            first_line: this.cursor.y,
            first_column: this.cursor.x,
            last_column: this.cursor.x + match[0].length,
            last_line: this.cursor.y,
            src: (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename)
          },
          type: 'error'
        }, this.code.split("\n")[this.cursor.y - 1]);
      }
      let file = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.resolvePath)(match[0], this.dirname),
        dirname = (0,path__WEBPACK_IMPORTED_MODULE_2__.dirname)(file);
      if (fileIsDir(file)) {
        file = (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(file, 'index.rc');
      }
      if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(file)) {
        let msg = "file not found";
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
          message: msg,
          location: {
            first_line: this.cursor.y,
            first_column: this.cursor.x,
            last_column: this.cursor.x + match[0].length,
            last_line: this.cursor.y,
            src: (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename)
          },
          type: 'error'
        }, this.code.split("\n")[this.cursor.y - 1]);
      } else if (this.cantImport.includes((0,path__WEBPACK_IMPORTED_MODULE_2__.relative)(file, this.sdir))) {
        let msg = "prevented endless loop from import";
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
          message: msg,
          location: {
            first_line: this.cursor.y,
            first_column: this.cursor.x,
            last_column: this.cursor.x + match[0].length,
            last_line: this.cursor.y,
            src: (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename)
          },
          type: 'error'
        }, this.code.split("\n")[this.cursor.y - 1]);
      }
      let source = (0,fs__WEBPACK_IMPORTED_MODULE_3__.readFileSync)(file, {
        encoding: 'utf-8'
      });
      let Include = new Lexer(source, {
        isInclude: true,
        filename: (0,path__WEBPACK_IMPORTED_MODULE_2__.relative)(this.sdir, file),
        sdir: this.dirname,
        dirname,
        cantImport: this.cantImport.concat((0,path__WEBPACK_IMPORTED_MODULE_2__.relative)(file, this.sdir))
      });
      this.portLine = -1;
      this.opLevel = -1;
      this.opLine = false;
      this.tokens.pop();
      this.tokens.push(...Include.tokens);
      this.comments = [...this.comments, ...Include.comments].filter(Boolean);
      return match[0].length;
    }
  }
  String() {
    let match = /^("|'|`)((?:\n|.|[$#]\{(?:.|\n)+\})*)(?<!\\)(\1)/.exec(this.chunk),
      sling = /^\\([^\s\n]+)/.exec(this.chunk);
    if (match) {
      let [input, quote, string] = match,
        cursor = {
          ...this.cursor
        };
      cursor.x++; // we count the quote token;
      let i = 1,
        chunk = this.chunk,
        char = "",
        prevChar = "",
        fragments = [],
        lastFragment = i,
        isPaired;
      function isNotEscaped(to_index = 0) {
        let sReg = /(\\+)$/.exec(chunk.slice(0, i - to_index));
        if (!sReg) return true;
        let [, slashes] = sReg;
        if (slashes.length % 2) return false;else return true;
        return;
      }
      while (char = chunk.charAt(i)) {
        if (char === "\n") {
          cursor.x = 0;
          cursor.y++;
        }
        cursor.x++;
        if (char === quote && isNotEscaped()) {
          i++;
          isPaired = true;
          break;
        }
        let hashsymbol;
        if (!this.isELSON && char === "{" && ((hashsymbol = /\$|#/.test(prevChar)) && isNotEscaped(1) || isNotEscaped())) {
          let tokens, length, isTypeScript;
          ({
            tokens,
            length,
            isTypeScript
          } = new Lexer(chunk.slice(i + 1), {
            isInterpolation: true,
            cursor
          }));
          fragments.push(this._token('STRING', chunk.slice(lastFragment, i - +hashsymbol)), this._token('INTERPOLATION_START', '${'), ...tokens, this._token('INTERPOLATION_END', '}'));
          lastFragment = i + length + 2;
          prevChar = '}';
          i += length + 2;
          if (isTypeScript) this.isTypeScript = true;
          continue;
        }
        i++;
        prevChar = char;
      }
      if (!isPaired) {
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
          message: 'This string needs to be closed',
          location: {
            first_line: this.cursor.y,
            first_column: this.cursor.x,
            last_column: this.cursor.x + match[0].length,
            last_line: this.cursor.y,
            src: (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename)
          },
          type: 'error'
        }, this.code.split("\n")[this.cursor.y - 1]);
      }
      if (chunk.slice(lastFragment, i - 1)) fragments.push(this._token('STRING', chunk.slice(lastFragment, i - 1)));
      if ("IDENTIFIER SUCH SUPER PROPERTY ] INDEX_END CALL_END ) } SYMBOL_EXISTS )>".split(' ').includes(this.prev()[0]) && this.prev().spaced) {
        let b = this.skipped === this.indentLevel;
        if (b && this.inExplicit()) {
          this.skipped.pop();
        }
        if (this.prev()[0] === "SYMBOL_EXISTS") {
          this.prev()[0] = "FUNC_EXISTS";
        }
        this.token('CALL_START', '(', {
          generated: true
        });
        ++this.indentLevel;
        this.insertStage('call', 'implicit', 1);
      } else if (this.uncontinuous.includes(this.prev()[0]) && this.prev().spaced) {
        if (this.isPossibleArray()) {
          this.createImplicitArray();
        }
        this.token('NEWLINE', 0, {
          generated: true
        });
      }
      switch (fragments.length) {
        case 0:
          this.token('STRING', quote.repeat(2));
          break;
        case 1:
          {
            if (this.prev()[0] === "IMPORT") {
              if (typeof fs__WEBPACK_IMPORTED_MODULE_3__.existsSync !== "function") {
                (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
                  message: 'Unable to load imports in browser compiler. This function should only be used when bundling.',
                  location: {
                    first_line: this.cursor.y,
                    first_column: this.cursor.x,
                    last_column: this.cursor.x + fragments[0][1].length + 2,
                    last_line: this.cursor.y,
                    src: (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename)
                  },
                  type: 'error'
                }, this.code.split("\n")[this.cursor.y - 1]);
              }
              let file = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.resolvePath)(fragments[0][1], this.dirname),
                dirname = (0,path__WEBPACK_IMPORTED_MODULE_2__.dirname)(file);
              if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(file)) {
                let msg = "file not found: " + file;
                (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
                  message: msg,
                  location: {
                    first_line: this.cursor.y,
                    first_column: this.cursor.x,
                    last_column: this.cursor.x + fragments[0][1].length + 2,
                    last_line: this.cursor.y,
                    src: (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename)
                  },
                  type: 'error'
                }, this.code.split("\n")[this.cursor.y - 1]);
              } else if (this.cantImport.includes((0,path__WEBPACK_IMPORTED_MODULE_2__.relative)(file, this.sdir))) {
                let msg = "prevented endless loop from import";
                (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
                  message: msg,
                  location: {
                    first_line: this.cursor.y,
                    first_column: this.cursor.x,
                    last_column: this.cursor.x + match[0].length,
                    last_line: this.cursor.y,
                    src: (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(this.sdir, this.filename)
                  },
                  type: 'error'
                }, this.code.split("\n")[this.cursor.y - 1]);
              }
              let source = (0,fs__WEBPACK_IMPORTED_MODULE_3__.readFileSync)(file, {
                encoding: 'utf-8'
              });
              let Include = new Lexer(source, {
                isInclude: true,
                filename: (0,path__WEBPACK_IMPORTED_MODULE_2__.relative)(this.sdir, file),
                sdir: this.dirname,
                dirname,
                cantImport: this.cantImport.concat((0,path__WEBPACK_IMPORTED_MODULE_2__.relative)(file, this.sdir))
              });
              this.portLine = -1;
              this.opLevel = -1;
              this.opLine = false;
              this.tokens.pop();
              this.tokens.push(...Include.tokens);
              this.comments = [...this.comments, ...Include.comments].filter(Boolean);
              if (Include.isTypeScript) this.isTypeScript = true;
              break;
            }
            this.tokens.push(Object.assign(fragments[0], {
              1: `${quote}${fragments[0][1]}${quote}`,
              2: {
                ...fragments[0][2],
                last_column: fragments[0][2].last_column + 2
              }
            }));
            break;
          }
        default:
          {
            let pair = this.position + 1;
            this.tokens.push(this._token('STRING_START', quote, {
              pair
            }), ...fragments, this._token('STRING_END', quote, {
              pair,
              loc: {
                last_column: cursor.x,
                last_line: cursor.y
              }
            }));
            break;
          }
      }
      return i;
    } else if (sling) {
      let [input, string] = sling;
      string = string.replace(/(?:\\*)"|\\+/g, function (s) {
        let slashes = (/^\\+/.exec(s) ?? [])[0],
          qt = s.endsWith('"');
        if (qt) {
          if (!slashes || slashes.length % 2 === 0) {
            return s.slice(0, -1) + '\\"';
          }
          return s;
        } else {
          if (slashes.length % 2 === 0) {
            return s;
          } else return s + '\\';
        }
      });
      if ("IDENTIFIER SUCH SUPER PROPERTY ] INDEX_END CALL_END ) } SYMBOL_EXISTS )>".split(' ').includes(this.prev()[0]) && this.prev().spaced) {
        let b = this.skipped === this.indentLevel;
        if (b && this.inExplicit()) {
          this.skipped.pop();
        }
        if (this.prev()[0] === "SYMBOL_EXISTS") {
          this.prev()[0] = "FUNC_EXISTS";
        }
        this.token('CALL_START', '(', {
          generated: true
        });
        ++this.indentLevel;
        this.insertStage('call', 'implicit', 1);
      } else if (this.uncontinuous.includes(this.prev()[0]) && this.prev().spaced) {
        if (this.isPossibleArray()) {
          this.createImplicitArray();
        }
        this.token('NEWLINE', 0, {
          generated: true
        });
      }
      this.token('STRING', `"${string}"`, {
        loc: {
          first_column: this.cursor.x,
          first_line: this.cursor.y,
          last_line: this.cursor.y,
          last_column: this.cursor.x + input.length
        }
      });
      return input.length;
    }
  }
  Comment() {
    let match = /^([{#][:?])/.exec(this.chunk) || /^(#|\/\/)/.exec(this.chunk) || /^(\/\*)/.exec(this.chunk);
    if (!match) return 0;
    let BlockComment, LineComment, DefComment;
    BlockComment = match[0] === "/*";
    DefComment = /[{#][:?]/.test(match[0]);
    LineComment = !BlockComment && !DefComment;
    let end;
    let Comment;
    if (BlockComment) {
      let pair = /\*\//g.exec(this.chunk);
      if (!pair) {
        return 0;
      }
      Comment = this._token("COMMENT", this.chunk.slice(2, pair.index));
      this.cursor.y = Comment[2].last_line;
      this.cursor.x = Comment[2].last_column;
      this.forceCursorAtX = true;
      this.comments.push({
        ...Comment,
        inline: false,
        id: this.comments.length,
        addNewlines: (/^\n*/.exec(this.chunk.slice(pair.index + 2)) || [""])[0].length,
        loc: Comment[2]
      });
      return pair.index + 2;
    } else if (DefComment) {
      let i = 1,
        braces = [],
        pair = {};
      while (true) {
        i++;
        if (!this.chunk.charAt(i)) return 0;
        if (this.chunk.charAt(i) === "\n" && match[0][0] === "#") break;
        if (this.chunk.charAt(i) === "}") {
          if (!braces.length) {
            break;
          }
          braces.pop();
        }
        if (this.chunk.charAt(i) === "{") {
          braces.push(1);
        }
      }
      Comment = this._token("COMMENT", this.chunk.slice(2, i).trim().split('\n').map(s => s.trim()).join('\n'));
      this.cursor.y = Comment[2].last_line;
      this.cursor.x = Comment[2].last_column;
      this.forceCursorAtX = true;
      this.comments.push({
        ...Comment,
        jsdoc: true,
        id: this.comments.length,
        addNewlines: (/^\n*/.exec(this.chunk.slice(i + 1)) || [""])[0].length,
        loc: Comment[2]
      });
      return i + (match[0][0] === "#" ? 0 : 1);
    } else {
      let ref;
      let pair;
      if (match[0] === "#") {
        pair = (ref = /#/.exec(this.chunk.slice(1).split(/\n/)[0])) ? 2 + ref.index : false;
      }
      if (!pair) {
        pair = match[0].length + this.chunk.slice(match[0].length).split(/\n/)[0].length;
      }
      Comment = this._token("COMMENT", this.chunk.slice(match[0].length, ref ? pair - 1 : pair));
      this.comments.push({
        ...Comment,
        inline: ref ? false : true,
        id: this.comments.length,
        addNewlines: (/^\n*/.exec(this.chunk.slice(pair)) || [""])[0].length,
        loc: Comment[2]
      });
      return pair;
    }
  }
  _token(tag, value, {
    lvl,
    loc,
    origin,
    generated,
    inImplicitObj,
    isNext2GenArr,
    isNext2GenObj,
    $$accept,
    pair,
    cursor,
    ...info
  } = {}) {
    let token = [tag, value];
    token.lvl = typeof lvl == "undefined" ? this.indentLevel : lvl;
    token[2] = loc || {
      first_column: (cursor || this.cursor).x,
      first_line: (cursor || this.cursor).y,
      last_column: generated ? (cursor || this.cursor).x : '?',
      last_line: generated ? (cursor || this.cursor).y : (cursor || this.cursor).y + (typeof value === "string" ? (value !== "\n" ? value.split(/\n/) : value.repeat(2)).length - 1 : 1),
      indented: (this.prev()[2] || {}).indent,
      ...info
    };
    if (token[2].last_column === "?") {
      let comp = origin ? origin : value;
      if (token[2].last_line !== token[2].first_line) {
        token[2].last_column = typeof comp === "string" ? comp !== "\n" ? comp.split(/\n/).pop().length : token[2].first_column + 1 : token[2].first_column + 1;
      } else {
        token[2].last_column = token[2].first_column + (typeof comp === "string" ? comp.length : 1);
      }
    }
    if (origin) token[2].origin = origin;
    if (generated) token[2].generated = true;
    if (inImplicitObj) token.inImplicitObj = true;
    if (isNext2GenArr) token.isNext2GenArr = true;
    if (isNext2GenObj) token.isNext2GenObj = true;
    if ($$accept) token.$$accept = true;
    if (pair) token.pair = pair;
    token.stage = this.stage().id;
    token[2].src = this.filename;
    return token;
  }
  token(...args) {
    let token = this._token.apply(this, args);
    token.hash = this.position++;
    token.inImplicit = this.inImplicit();
    this.tokens[this.tokens.length] = token;
    return token;
  }
  createImplicitArray(inclusive, dotted) {
    let x, z;
    let i = this.tokens.map(i => i).reverse().findIndex(token => {
      if ((token[0] === "NEWLINE" || token.$$accept || ["AS", ":"].includes(token[0]) && dotted) && token.lvl === this.indentLevel) {
        if (token[0] === "NEWLINE") {
          if (token.isNext2GenObj && token.comma && !token.inImplicitObj) return;
          if (token.inImplicitObj) return;
        }
        if (token.isNext2GenArr) {
          z = token.lvl;
        }
        if (token[0] == "INDENT") {
          x = token.lvl;
        }
        return true;
      }
    });
    if (i > 0 - +!!inclusive) {
      i = this.tokens.length - i;
      if (!this.tokens[i]) {
        this.tokens.push(Object.assign(this._token('[', '[', {
          generated: true,
          pair: this.position
        }), {
          stageId: this.storeBefore(['array', this.position])
        }));
      } else if (typeof z === "undefined" && typeof x === "undefined" && this.tokens[i][0] !== "[") {
        this.tokens.splice(i, 0, Object.assign(this._token('[', '[', {
          generated: true,
          pair: this.position
        }), {
          stageId: this.storeBefore(['array', this.position])
        }));
      } else if (typeof z === "number") {
        let {
          stageId,
          hash
        } = this.tokens[i - 2];
        this.tokens.splice(i - 2, 1);
        this.storeAt(stageId, ['array', hash]);
      } else if (typeof x === "number") {
        if (this.tokens[i][0] !== "[") {
          this.tokens.splice(i, 0, Object.assign(this._token('[', '[', {
            generated: true,
            pair: this.position
          }), {
            stageId: this.storeBefore(['array', this.position])
          }));
        }
      }
    } else if (i === 0) {
      return;
    } else if (this.stage().contains.findIndex(y => y[0] === "array") === -1) {
      this.tokens.splice(0, 0, Object.assign(this._token('[', '[', {
        generated: true,
        pair: this.position
      }), {
        stageId: this.storeBefore(['array', this.position])
      }));
    }
  }
  fix() {
    if (this.explicit.length) {
      let explicit = this.currExplicit(),
        data = this.explicit.pop(),
        matching;
      matching = {
        ")": "(",
        "]": "[",
        "}": "{",
        "}}": "{{",
        ")>": "<(",
        CALL_END: "CALL_START",
        INDEX_END: "INDEX_START"
      }[explicit];
      explicit = {
        CALL_END: ")",
        INDEX_END: ")",
        ")>": ">",
        "}}": "}"
      }[explicit] || explicit;
      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
        message: `Missing "${explicit}" for this token`,
        location: this.tokens.find(t => t.pair === data[2] && t[0] === matching)[2]
      });
    }
    this.rmNL();
    while (this.tokens[0] && this.tokens[0][0] === "NEWLINE") this.tokens = this.tokens.slice(1);
  }
  Unfinished = 'get static set async new await do with within for when or else until loop try catch then whether case post_case if unless function var const let otherwise as from at import export class extends ? : [ { {{ ( call_start index_start ** division * ~ ^ % math_bin is isnt == === != !== <= >= < > << >> >>> func_exists . indent newline , throw yield && || & |'.split(' ').map(tag => tag.toUpperCase());
  inExplicit() {
    return this.stage().type === "explicit";
  }
  inTrueExplicit() {
    let stg = this.trueStage();
    return stg && ["indent", "explicit"].includes(stg.type);
  }
  currExplicit() {
    return this.explicit.slice(-1)[0] && this.explicit.slice(-1)[0][0];
  }
  rmNL() {
    let data = {};
    while (this.prev()[0] === "NEWLINE") {
      let t;
      for (let i in t = this.tokens.pop()) {
        if (!data[i]) data[i] = t[i];
      }
    }
    return data;
  }
  isPossibleArray() {
    return this.stage().type === "indent" && this.stage().label !== "import" && this.stage().label !== "export" && !this.stage().contains.length && !this.stage().assignKwd && this.stage().typeKwd !== "interface" && this.portLine !== this.cursor.y && this.forAssignLine !== this.cursor.y && !this.inExplicit() && !(this.currExplicit() && !this.paramLine && [undefined, 'Root'].includes(this.stage().label));
  }
  inImplicitObj() {
    return this.stage().contains.map(i => i[0]).includes('object');
  }
  inImplicit() {
    return !!this.stage().contains.length;
  }
  inClass() {
    return this.stage().label === "class";
  }
  inSwitch() {
    return this.stage().label === "switch";
  }
  stage() {
    return this.stages.slice(-1)[0];
  }
  insertStage(type, label, indent) {
    this.stages.push({
      type,
      label: label || undefined,
      indent,
      totalIndent: this.indentLevel,
      location: {
        ...this.cursor
      },
      contains: [],
      position: this.position,
      id: this.stage().id + 1
    });
  }
  store(child) {
    let len = this.stage().contains.length + 1;
    this.stage().contains.push([...child, len, this.cursor]);
    return len;
  }
  storeBefore(child) {
    let len = this.stage().contains.length + 1;
    this.stage().contains.unshift([...child, len, this.cursor]);
    return len;
  }
  storeAt(index, child) {
    let len = this.stage().contains.length + 1;
    this.stage().contains.splice(index, 0, [...child, len, this.cursor]);
    return len;
  }
  trueStageLevel() {
    let lvl = this.stages.length;
    for (let i = this.stages.length; i > 0; i--) {
      let stage = this.stages[i - 1];
      if (['explicit', 'indent'].includes(stage.type)) {
        lvl = i;
        break;
      }
    }
    return lvl;
  }
  trueStage() {
    return this.stages.filter(stage => ['explicit', 'indent'].includes(stage.type)).slice(-1)[0];
  }
  trueIndentOrExplicit() {
    if (this.explicit.length) {
      return this.explicit.slice(-1)[0][1];
    } else return this.trueStage().indent;
  }
  inExplicitCall() {
    let ref = this.explicit.slice(-1)[0];
    return Array.isArray(ref) ? /(CALL|PARAM)_END/.test(ref[0]) : false;
  }
  close(addNewlines, until = 0, fromOpline) {
    let {
        loc
      } = this.prev(),
      stage;
    while ((stage = this.stage()) && stage.contains.length >= until) {
      if (fromOpline && stage.contains.length && stage.contains[stage.contains.length - 1].break) return false;
      let stageId = stage.contains.length,
        implicit = stage.contains.pop();
      if (stageId === 0) break;
      switch (implicit[0]) {
        case "object":
          {
            this.rmNL();
            this.token("}", "}", {
              generated: true,
              pair: implicit[1]
            });
            this.prev().stageId = stageId;
            this.prev().loc = loc;
            addNewlines && this.token("NEWLINE", 0, {
              isNext2GenObj: true,
              generated: true
            });
            break;
          }
          ;
        case "array":
          {
            this.rmNL();
            this.token("]", "]", {
              generated: true,
              pair: implicit[1]
            });
            this.prev().stageId = stageId;
            this.prev().loc = loc;
            addNewlines && this.token("NEWLINE", 0, {
              isNext2GenArr: true,
              generated: true
            });
            break;
          }
          ;
        case "call":
        case "param":
        case "indent&call":
          {
            this.rmNL();
            this.token(`${implicit[0].replace("indent&", "").toUpperCase()}_END`, ")", {
              generated: true,
              pair: implicit[1]
            });
            this.prev().stageId = stageId;
            this.prev().loc = {
              ...loc,
              type: null
            };
            addNewlines && this.token("NEWLINE", 0, {
              generated: true
            });
            if (implicit[0] === "param") this.paramLine = false;
            break;
          }
      }
    }
    return true;
  }
  closeTo(to, fromOpline) {
    while (this.stages.length > to) {
      let br = this.close(false, 0, fromOpline);
      if (!br && fromOpline) return false;
      if (this.stage().label === "Root") break;
      let stage = this.stages.pop();
      if (stage.type === "indent") {
        this.token('OUTDENT', '', {
          pair: stage.position
        });
      } else if (stage.type === "call" || stage.type === "indent&call") {
        this.token('CALL_END', ')');
      }
      this.indentLevel -= stage.indent;
    }
  }
  closeToIndent(to) {
    while (this.indentLevel > to) {
      this.close();
      if (this.stage().label === "Root" || this.stage().type === "explicit") {
        break;
      }
      let stage = this.stages.pop();
      this.indentLevel -= stage.indent;
      if (stage.type === "indent") {
        this.token('OUTDENT', '', {
          pair: stage.position
        });
      } else if (stage.type === "call" || stage.type === "indent&call") {
        this.token('CALL_END', ')');
      }
    }
  }
  closeUntil(cb) {
    let last = this.stages.slice(-1)[0];
    while ( true && this.stages.length) {
      this.close();
      if (this.stage().label === "Root" || this.stage().type === "explicit") break;
      let stage = this.stages.pop();
      switch (stage.type) {
        case "indent":
          {
            this.token('OUTDENT', '', {
              pair: stage.position
            });
            break;
          }
          ;
        case "call":
        case "indent&call":
          {
            this.token('CALL_END', ')');
            break;
          }
          ;
      }
      if (cb(last)) break;
      last = this.stages.slice(-1)[0];
      this.indentLevel -= stage.indent;
    }
  }
  closeImplicitsTo(index, addNewlines) {
    let {
      loc
    } = this.prev();
    while (this.stage().contains.length > index) {
      let stageId = this.stage().contains.length,
        implicit = this.stage().contains.pop();
      if (!implicit) break;
      switch (implicit[0]) {
        case "object":
          {
            this.rmNL();
            this.token("}", "}", {
              generated: true,
              pair: implicit[1]
            });
            this.prev().stageId = stageId;
            this.prev().loc = loc;
            addNewlines && this.token("NEWLINE", 0, {
              isNext2GenObj: true,
              generated: true
            });
            break;
          }
          ;
        case "array":
          {
            this.rmNL();
            this.token("]", "]", {
              generated: true,
              pair: implicit[1]
            });
            this.prev().stageId = stageId;
            this.prev().loc = loc;
            addNewlines && this.token("NEWLINE", 0, {
              isNext2GenArr: true,
              generated: true
            });
            break;
          }
          ;
        case "call":
        case "param":
        case "indent&call":
          {
            this.rmNL();
            this.token(`${implicit[0].replace("indent&", "").toUpperCase()}_END`, ")", {
              generated: true,
              pair: implicit[1]
            });
            this.prev().stageId = stageId;
            this.prev().loc = {
              ...loc,
              type: null
            };
            addNewlines && this.token("NEWLINE", 0, {
              generated: true
            });
            break;
          }
      }
    }
  }
  closeImplicitObjects(addNewlines, suppressArrays, comma = false) {
    let currAction = this.stage().contains.slice(-1)[0] || [];
    while (/array|object/.test(currAction[0])) {
      let stageId = this.stage().contains.length;
      switch (currAction[0]) {
        case "object":
          {
            this.rmNL();
            this.token("}", "}", {
              generated: true,
              pair: currAction[1]
            });
            this.prev().stageId = stageId;
            addNewlines && this.token("NEWLINE", 0, {
              isNext2GenObj: true,
              generated: true
            });
            break;
          }
          ;
        case "array":
          {
            if (suppressArrays) return;
            this.rmNL();
            this.token("]", "]", {
              generated: true,
              pair: currAction[1]
            });
            this.prev().stageId = stageId;
            addNewlines && this.token("NEWLINE", 0, {
              isNext2GenArr: true,
              generated: true
            });
            break;
          }
          ;
      }
      this.stage().contains.pop();
      if (comma) this.prev().comma = true;
      currAction = this.stage().contains.slice(-1)[0] || [];
    }
  }
  isUnfinished() {
    return this.Unfinished.includes(this.prev()[0]);
  }
  postfixeables = 'THIS IDENTIFIER REGEX REGEX_END JSX_END PROPERTY ] } ) NUMBER CALL_END INDEX_END STRING_END STRING NpmPackage RETURN CONTINUE BREAK DEBUGGER SUCH SUPER SYMBOL_EXISTS ARGUMENT'.split(' ');
  indexables = 'THIS IDENTIFIER REGEX REGEX_END PROPERTY ] } ) CALL_END INDEX_END STRING_END STRING SUCH SUPER ARGUMENT'.split(' ');
  uncontinuous = 'STRING STRING_END JSX_END NUMBER UNDEFINED NULL BOOL THIS REGEX REGEX_END INFINITY TAG'.split(' ');
  Opening = '( { {{ [ INDEX_START CALL_START INDENT'.split(" ");
  Callable = "SUCH SUPER IDENTIFIER PROPERTY ] INDEX_END CALL_END ) } SYMBOL_EXISTS IMPORT )>".split(" ");
  prev() {
    return this.tokens[this.tokens.length - 1] || [];
  }
  indent() {
    return this.stage().indent;
  }
  assertTokens(...str) {
    if (str.length > 1) {
      var checks = [],
        assert;
      for (let query of str) {
        if (undefined !== (assert = this.assertTokens(query))) break;
      }
      return assert;
    } else {
      str = str[0];
    }
    let ord = str.split(/\s+/g),
      len = ord.length;
    let last_tag = '',
      last_token = [],
      i = this.tokens.length - 1,
      asserted = true;
    while (true) {
      let query = ord.pop(),
        token;
      if (!query) break;
      if (token = this.tokens[i]) {
        if (query === '.+') {
          let copyI = i,
            copyT;
          find: while (copyT = this.tokens[copyI]) {
            if (copyT.pair !== last_token.pair) {
              copyI--;
            } else {
              break find;
            }
          }
          i = copyI;
          continue;
        } else {
          let [tag] = token;
          if (query !== tag) {
            asserted = false;
            break;
          } else {
            i--;
            last_token = token;
            continue;
          }
        }
      } else {
        asserted = false;
        break;
      }
    }
    return asserted ? ++i : undefined;
  }
  popTokens(where) {
    return this.tokens.splice(where);
  }
}
function fileIsDir() {
  let subfolder;
  try {
    subfolder = readdirSync(path__WEBPACK_IMPORTED_MODULE_2__.join.apply(null, arguments));
  } catch (_) {}
  if (subfolder !== undefined) return true;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Lexer);
if (typeof module !== "undefined" && typeof require === "function") {
  module.exports = Lexer;
}

/***/ }),

/***/ "./lib/parser.js":
/*!***********************!*\
  !*** ./lib/parser.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Nodes: () => (/* binding */ Nodes),
/* harmony export */   Parser: () => (/* binding */ Parser)
/* harmony export */ });
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ "./lib/helpers.js");
/* harmony import */ var _sourcemaps_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sourcemaps.js */ "./lib/sourcemaps.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../index.js */ "./index.js");
/* harmony import */ var _grammar_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./grammar.js */ "./lib/grammar.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");




const Nodes = {};
class Parser {
  constructor(tree, options = {}) {
    this.nodes = tree;
    this.comments = options.isELSON || options.removeComments ? [] : options.comments;
    this.isELSON = options.isELSON;
    this.useVar = options.useVar;
    this.sourceMaps = options.sourceMaps;
    this.wrapSafe = options.wrapSafe;
    this.tsCheck = options.tsCheck;
    this.omitTypeScript = options.omitTypeScript;
    this.isTypeScript = options.isTypeScript;
    this.isJSX = options.isJSX;
    this.isRecomp = options.isRecomp;
    this.cout = options.cout;
    this.tabSize = options.outputTabSize || 2;
  }
  parse({
    scope
  }) {
    let sources, js, registry;
    sources = new _sourcemaps_js__WEBPACK_IMPORTED_MODULE_1__.Sources();
    registry = {
      sources: this.sourceMaps ? sources : undefined,
      scope: ['Root'],
      useVar: this.useVar,
      isELSON: this.isELSON,
      omitTypeScript: this.omitTypeScript,
      isRecomp: this.isRecomp,
      cout: this.cout,
      isTypeScript: this.isTypeScript,
      isJSX: this.isJSX,
      tabSize: this.tabSize
    };
    js = this.nodes.parse({
      comments: this.comments,
      registry,
      wrapSafe: this.wrapSafe,
      scope,
      tsCheck: this.tsCheck
    });
    return {
      js,
      sources,
      isTypeScript: registry.isTypeScript,
      isJSX: registry.isJSX
    };
  }
}
var Base;
Nodes.Base = Base = class Base extends Array {
  constructor(...args) {
    let rule;
    super(...args);
    this.setRule(args[0]);
  }
  get location() {
    return this.loc;
  }
  setRule(rule) {
    this.rule = rule;
    return this;
  }
  setTokens(...tokens) {
    this.tokens = {};
    for (var [token, loc] of tokens) {
      if (!loc) continue;
      if (!this.tokens[token]) this.tokens[token] = [];
      this.tokens[token].push(loc);
    }
    return this;
  }
  findToken(token) {
    if (!this.tokens) return;
    var tok = this.tokens[token];
    if (Array.isArray(tok)) {
      return tok[tok.length - 1];
    }
  }
  setLocation({
    first_line,
    first_column,
    ...first
  }, {
    last_line,
    last_column
  } = {}) {
    if (!last_line) ({
      last_line
    } = first);
    if (!last_column) ({
      last_column
    } = first);
    this.loc = {
      first_line,
      first_column,
      last_line,
      last_column,
      src: first.src,
      type: first.type
    };
    return this;
  }
  setLoc(...loc) {
    return this.setLocation(...loc);
  }
  get contents() {
    return Object.assign(this.slice(1), {
      loc: this.loc,
      rule: this.rule
    });
  }
  get unwrap() {
    return this.contents.length > 1 ? this.contents : this.contents[0];
  }
  unwraps(num) {
    let returns = this;
    while (num !== 0) {
      num--;
      returns = returns.unwrap;
    }
    return returns;
  }
  visit(...indexes) {
    var result = this;
    for (let index of indexes) {
      result = result[index];
    }
    return result;
  }
  get unwrapAll() {
    let res = this;
    while (res.unwrap instanceof Base) res = res.unwrap;
    return res;
  }
  unwrapUntil(cb) {
    let res = this,
      bool = false,
      id = 0;
    while (res && res.unwrap && !(bool = cb(res, id))) {
      res = res.unwrap;
      id++;
    }
    return bool ? res : false;
  }
  throwSyntaxError(message, location = this.loc) {
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
      message,
      location
    });
  }
};
Nodes.Access = class Access extends Base {
  parse(opts = {
    registry: {}
  }) {
    let {
      rule,
      unwrap: Access
    } = this;
    let output = "";
    switch (rule) {
      case ". PROPERTY":
        {
          output += (!opts.noDot ? '.' : '') + (opts.registry && opts.registry.sources ? opts.registry.sources.add(this.loc) : '') + Access[0];
          break;
        }
        ;
      case "INDEX_START Expression INDEX_END":
        {
          output += (opts.registry && opts.registry.sources ? opts.registry.sources.add(this.findToken('INDEX_START') || this.loc) : '') + "[" + Access.parse({
            ...opts,
            isValue: true
          }) + "]";
          break;
        }
    }
    return output;
  }
};
Nodes.AlphaNum = class AlphaNum extends Base {
  parse(opts) {
    switch (true) {
      case this.unwrap instanceof Nodes.String:
        return this.unwrap.parse(opts);
      default:
        {
          return this.unwrap;
        }
    }
  }
};
Nodes.Array = class Array extends Base {
  parse({
    that,
    $such,
    scope,
    addSemicolon,
    vars,
    varExistent,
    constants,
    prevLine,
    isCondition,
    isValue,
    tabs,
    wrap,
    isClass,
    isAssignment,
    ID,
    comments,
    lastNodeLocation,
    registry = {},
    isFrom,
    isObjProperty
  }) {
    let Arr = this.contents,
      {
        loc: initLoc
      } = Arr[0] || this,
      lastNode = initLoc;
    let output = "";
    output += "[";
    let x = this.indented,
      BeforeComments = "";
    for (let comment of comments.filter(c => c.loc.first_line < initLoc.first_line || c.loc.first_line === initLoc.first_line && c.loc.first_column < initLoc.first_column)) {
      if (registry[comment.id]) continue;
      let commentOutput = parseComment(comment, tabs + 1, true, registry);
      BeforeComments += commentOutput;
      x = true;
      registry[comment.id] = true;
    }
    let Spots = [],
      il = 0;
    for (let Spot of Arr) {
      let nl;
      il++;
      if (Spot instanceof Nodes.Statement) (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
        message: 'Unexpected statement',
        location: Spot.loc
      });
      if (Spot === null) {
        Spots.push(['', '']);
        continue;
      } else if (/boolean|undefined/.test(typeof Spot)) {
        if (!Spot) {
          x = true;
          Spots.push(['jump', '']);
        }
        continue;
      }
      let {
        childComments,
        matchedComments
      } = matchComments(lastNode, comments, Spot.loc);
      if (isAssignment) {
        if (!(Spot.unwrap instanceof Nodes.Value) && !(Spot.unwraps(2) instanceof Nodes.Assignment || Spot.unwraps(2) instanceof Nodes.Assignable)) {
          Spot.throwSyntaxError('Invalid left-hand assignment reference.');
        }
      }
      let test = (nl = Spot.rule === "Value" && Spot[1].rule === "Assignable") && Spot[1][1].rule === "Object" && isFrom;
      if (nl && ["Object", "Array", "Invocation"].includes(Spot[1][1].rule)) {
        nl = true;
        x = true;
      } else nl = false;
      let cO = "",
        it = Spot.parse({
          that,
          $such,
          scope,
          addSemicolon: [],
          vars,
          varExistent,
          constants,
          prevLine,
          isCondition,
          isValue: true,
          isParam: true,
          tabs: tabs + 1,
          wrap,
          isClass,
          isAssignment,
          ID,
          comments: childComments,
          lastNodeLocation,
          registry
        });
      if (test) {
        it = it.slice(2, -2);
      }
      if (Spot.unwraps(2).rule === "Value Access" && isFrom) {
        if (Spot.unwraps(2)[1].rule === "This") {
          it = `${Spot.unwraps(2)[2].parse({
            registry,
            noDot: true
          })}: ${it}`;
        } else {
          Spot.throwSyntaxError('Invalid left-hand assignment reference.');
        }
      }
      if (Spot.expansion) it = `...${it}`;
      if (matchedComments.length) {
        for (let comment of matchedComments) {
          if (registry[comment.id]) continue;
          cO = parseComment(comment, tabs + 1, true, registry);
          Spots.slice(-1)[0][1] += cO;
          registry[comment.id] = true;
          x = true;
        }
      }
      lastNode = Spot.loc;
      Spots.push([it, ""]);
      if (nl && il < Arr.length) {
        Spots.push(["jump", '\n' + tab(registry.tabSize, tabs + 1)]);
      }
    }
    let ll = Spots.filter(s => s[0] !== "jump").length;
    Spots = Spots.map(([s, c], i, r) => {
      let z = i !== r.length - 1 ? ", " : "";
      if (i === 0) {
        return s + z + (c && (x = true) && (c || "\n" + tab(registry.tabSize, tabs + 1)));
      } else if (s === "") return z + (c && (x = true) && c);else if (s === "jump") return (x = true) && (this.separate ? '\n' + tab(registry.tabSize, tabs + 1) : c);else if (r[i - 1] !== "") return s + z + (c && (x = true) && c);else return s + z + (c && (x = true) && c);
    }).join('').replace(/\s+\n/g, '\n');
    let b = false,
      AfterComments = "";
    for (let comment of comments.filter(c => c.loc.first_line >= lastNode.last_line)) {
      if (registry[comment.id]) continue;
      b = true;
      let commentOutput = parseComment(comment, tabs + 1, true, registry);
      if (comment.loc.first_line == lastNode.last_line) {
        let resource = AfterComments,
          trim = 0;
        while (/\n|\r| /.test(resource.charAt(resource.length - 1))) {
          resource = resource.slice(0, -1);
          trim++;
        }
        AfterComments = resource + " " + commentOutput;
      } else {
        AfterComments += commentOutput;
      }
      registry[comment.id] = true;
    }
    if (x && !BeforeComments && Spots.startsWith('{\n') && !(/\n\s*\}$/.test(Spots) && ll > 1)) {
      x = false;
      Spots = Spots.replace(new RegExp(`\\n(${" ".repeat(registry.tabSize)}){${tabs},}`, 'gm'), function (str) {
        var tb = str.slice(1);
        tb = tb.split(new RegExp(`(${" ".repeat(registry.tabSize)})`, 'g')).filter(t => t !== "").length;
        return '\n' + tab(registry.tabSize, tb - 1);
      });
    }
    if (x || b) output += "\n" + tab(registry.tabSize, tabs + 1);
    output += (BeforeComments + Spots + AfterComments).trim();
    if (b || x) output += "\n" + tab(registry.tabSize, tabs);
    output += "]";
    return output;
  }
  static from(Body) {
    let middleware = new Nodes.Array(null).setLoc(Body.loc);
    middleware.indented = true;
    middleware.separate = true;
    if (Body instanceof Nodes.Block) Body = Body.unwrap;
    let Lines = Body.unwrap;
    let i = 0,
      lineCount = 0;
    for (let Line of Lines) {
      i++;
      Line = Line.unwrap;
      lineCount++;
      middleware[middleware.length] = Line;
      if (i !== Lines.length) {
        middleware[middleware.length] = false;
      }
    }
    if (lineCount === 1) {
      return middleware[1];
    }
    let wrapped = new Nodes.Expression('Value', new Nodes.Value('Assignable', new Nodes.Assignable('Array', middleware).setLoc(Body.loc)).setLoc(Body.loc)).setLoc(Body.loc);
    return wrapped;
  }
};
Nodes.Assign = class Assign extends Base {
  parse({
    that,
    $such,
    scope,
    vars,
    varExistent,
    constants,
    constant,
    construct,
    isValue,
    prevLine,
    tabs,
    lineReturns,
    isCondition,
    isCompare,
    comments = [],
    lastNodeLocation,
    registry = {},
    ID = [],
    FiresSuper,
    FiresAwait,
    FiresYield,
    isStatement,
    addSemicolon,
    afterParse,
    metaComments,
    isClass,
    hasTypes = []
  } = {}) {
    let {
      rule,
      contents: Assign
    } = this;
    if (Assign.length == 1) Assign = Assign[0];
    let output = "",
      wrap,
      isModule;
    if (Assign[1].rule === "Object" || Assign[3][0] === "FROM") wrap = true;else if (Assign[1].rule === "Array" || Assign[3][0] === "AT") {
      output += registry.sources ? registry.sources.add(Assign[2].loc) : '';
    }
    output += Assign.parse({
      that,
      $such,
      scope,
      vars,
      varExistent,
      constants,
      constant,
      construct,
      isValue,
      prevLine,
      tabs,
      lineReturns,
      isCondition,
      isCompare,
      comments,
      lastNodeLocation,
      registry,
      ID,
      FiresSuper,
      FiresAwait,
      FiresYield,
      isStatement,
      addSemicolon,
      afterParse,
      metaComments,
      isClass,
      hasTypes
    });
    if (!Array.isArray(ID)) {
      ID = [ID];
    }
    if (constant) {
      for (let [id, loc] of ID) {
        if (id && vars && vars.includes(id)) {
          (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
            message: `'${id}' is already assigned as a variable`,
            location: loc
          });
        }
        constants.push(id.toString());
      }
    }
    for (let [id, loc] of ID) {
      if (id && !id.isProperty && vars && !vars.includes(id.toString()) && !constant && !isModule) {
        if (constants && constants.includes(id)) {
          (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
            message: `Assignment to constant variable.`,
            location: loc
          });
        }
        if (!isStatement) {
          vars.push(id.toString());
          if (!vars.__locations) vars.__locations = {};
          vars.__locations[id.toString()] = loc;
          scope.push(id.toString());
        }
      }
    }
    if (wrap && !isCondition && !isStatement) {
      output = [registry.sources ? registry.sources.add(Assign[2].loc) : '', "(", output, ")"].join("");
    }
    return output;
  }
};
Nodes.Assignable = class Assignable extends Base {
  isDestructor([KEYWORD]) {
    let state = 0,
      rule = this.rule;
    if (rule === "Object") {
      state++;
    }
    if (rule === "Array") {
      if (KEYWORD === "AS" && this.unwrap.loc.generated === undefined) state = 0;else state++;
    }
    return state > 0;
  }
  parse({
    that,
    $such,
    scope = [],
    addSemicolon,
    vars = [],
    constants = [],
    prevLine,
    isCondition,
    isValue,
    tabs,
    wrap,
    isClass,
    isLine,
    lineReturns,
    isAssignment,
    isOperation,
    isStatement,
    ID = [],
    func,
    scopedParams,
    method,
    isAssigned,
    comments = [],
    lastNodeLocation,
    registry = {},
    isFrom,
    isParam,
    varExistent,
    FiresSoak = [],
    isInvoked,
    isNarrow = false,
    isObjProperty,
    typeData = [],
    afterParse,
    metaComments = []
  } = {}) {
    let Assignable = this,
      rule = this.rule,
      id;
    let output = "",
      isProperty;
    switch (rule) {
      case "Identifier":
        {
          let $such = Assignable[1].parse({
            registry
          });
          if (isAssignment) {
            let metaType = this.loc.type ? {
                value: this.loc.type.nodes.parse({
                  registry
                }),
                loc: this.loc.type.nodes.loc
              } : undefined,
              vname = Assignable[1].parse();
            ID.push([vname, this.loc]);
            if (!metaType) {
              metaType = getDataOfMetaComments({
                metaComments,
                ID: vname,
                tabs,
                loc: this.loc,
                registry
              });
            } else {
              attachDescriptions(metaComments, [metaType], tabs, registry);
            }
            if (metaType) {
              typeData.push({
                ID: vname,
                ...metaType
              });
            }
          }
          output += $such;
          break;
        }
        ;
      case "ThisProperty":
        {
          isProperty = true;
          output += that && that[0] || "this";
          output += Assignable[1].parse({
            that,
            $such,
            scope,
            addSemicolon,
            vars,
            varExistent,
            constants,
            prevLine,
            isCondition,
            isValue,
            tabs,
            wrap,
            isClass,
            isAssignment,
            ID,
            isLine,
            lineReturns,
            comments,
            lastNodeLocation,
            registry
          });
          break;
        }
        ;
      case "Value Access":
        {
          let metaType = this.loc.type ? {
              value: this.loc.type.nodes.parse({
                registry
              }),
              loc: this.loc.type.nodes.loc
            } : undefined,
            _parent,
            _child;
          if (isAssignment && isStatement) {
            this.throwSyntaxError('Unexpected property', Assignable[2].loc);
          }
          let soak = Assignable[2][2];
          isProperty = true;
          let _refer = Assignable[1].parse({
            that,
            $such,
            scope,
            addSemicolon: [],
            vars,
            varExistent,
            constants,
            prevLine,
            isCondition,
            isValue: true,
            tabs,
            wrap,
            isClass,
            isLine,
            lineReturns,
            func,
            scopedParams,
            comments,
            lastNodeLocation,
            registry: {
              ...registry,
              sources: undefined,
              isRecomp: true
            },
            FiresSoak,
            isAssignment,
            isInvoked: true,
            isOperation,
            isParam,
            isNarrow
          });
          let s = Assignable[1].parse({
            that,
            $such,
            scope,
            addSemicolon: [],
            vars,
            varExistent,
            constants,
            prevLine,
            isCondition,
            isValue: true,
            tabs,
            wrap,
            isClass,
            isLine,
            lineReturns,
            func,
            scopedParams,
            comments,
            lastNodeLocation,
            registry,
            FiresSoak,
            isAssignment,
            isInvoked: true,
            isOperation,
            isParam,
            isNarrow
          });
          let Access = Assignable[2].parse({
            that,
            $such,
            scope,
            addSemicolon: [],
            vars,
            varExistent,
            constants,
            prevLine,
            isCondition,
            isValue,
            tabs,
            wrap,
            isClass,
            isAssignment,
            ID,
            isLine,
            comments,
            lastNodeLocation,
            registry,
            isParam,
            isNarrow,
            FiresSoak
          });
          let cantSoakLine = isAssignment || isOperation || isInvoked || isParam || isCondition || isNarrow;
          if (soak) {
            let _ref = FiresSoak[FiresSoak.length - 1],
              sym = "",
              isVerbose;
            if (_ref) {
              s = _ref[1] + _ref[2];
            } else {
              s = _refer;
            }
            if (Assignable[1].unwrap.rule !== 'Identifier') {
              isVerbose = true;
              _ref = Letter(scope, 's');
              vars.push(_ref);
              scope.push(_ref);
              sym += `(${_ref} = ${s})`;
            } else {
              sym = s;
              _ref = s;
            }
            s = `typeof ${sym} ${!isVerbose || cantSoakLine ? `!== "undefined" && ${_ref} ` : ''}!== null`;
            FiresSoak.push([s, _ref, Access]);
            s = _ref;
          }
          output += s + Access;
          if (isAssignment) {
            if (Assignable[1].rule === "Assignable" && /Identifier|Value Access|Expression IN Expression/.test(Assignable[1].unwrap.rule)) {
              _parent = _refer;
            }
            let prop = _parent + Access;
            if (!metaType) {
              metaType = getDataOfMetaComments({
                metaComments,
                ID: prop,
                tabs,
                loc: this.loc,
                registry
              });
            } else {
              attachDescriptions(metaComments, [metaType], tabs, registry);
            }
            if (metaType) {
              typeData.push({
                ID: prop,
                kind: 'access',
                ...metaType
              });
            }
          }
          if (soak && !cantSoakLine) {
            output = loadSoaks(output, {
              Soaks: FiresSoak,
              tabs,
              scope,
              vars,
              prevLine,
              registry,
              loc: this.loc
            });
            if (isValue) {
              output = `(${output})`;
            }
          }
          break;
        }
        ;
      case "Expression IN Expression":
        {
          let [Value, Accessor] = Assignable.contents;
          output += Value.parse({
            that,
            $such,
            scope,
            addSemicolon: [],
            vars,
            varExistent,
            constants,
            prevLine,
            isCondition,
            isValue: true,
            tabs,
            wrap,
            isClass,
            isAssignment,
            ID,
            isLine,
            lineReturns: false,
            comments,
            lastNodeLocation,
            registry
          });
          var noDot = false,
            Accs;
          if (Accessor.unwrap instanceof Nodes.Value && (Accessor.unwraps(2) instanceof Nodes.Assignable && (["IDENTIFIER", "Value Access"].includes(Accessor.unwraps(3).rule) || Accessor.unwraps(2).rule === "Array" && (noDot = true)) || Accessor.unwraps(2) instanceof Nodes.Invocation && (Accs = Accessor.unwraps(2)[1]) && Accs.unwrap instanceof Nodes.Assignable && (["IDENTIFIER", "Value Access"].includes(Accs.unwraps(2).rule) || Accs.unwrap.rule === "Array" && (noDot = true))) || Accessor.unwrap.rule === "@ Value" && (Accs = Accessor.unwraps(2)) && Accs.unwrap instanceof Nodes.Assignable && (["IDENTIFIER", "Value Access"].includes(Accs.unwraps(2).rule) || Accs.unwrap.rule === "Array" && (noDot = true))) {
            var Prop = Accessor.parse({
              that,
              $such,
              scope,
              vars,
              varExistent,
              constants,
              prevLine,
              isCondition,
              isValue: true,
              tabs,
              wrap,
              isClass,
              isAssignment,
              ID,
              comments,
              lastNodeLocation,
              registry,
              NoPrint: true
            });
            if (Prop.startsWith('[')) noDot = true;
            output += (noDot ? "" : ".") + Prop;
          } else {
            output += `[${Accessor.parse({
              that,
              $such,
              scope,
              vars,
              varExistent,
              constants,
              prevLine,
              isCondition,
              isValue: true,
              tabs,
              wrap,
              isClass,
              isAssignment,
              ID,
              comments,
              lastNodeLocation,
              registry
            })}]`;
          }
          break;
        }
        ;
      case 'Object':
        {
          Assignable = Assignable.unwrap;
          output += Assignable.parse({
            that,
            $such,
            scope,
            addSemicolon,
            vars,
            varExistent,
            constants,
            prevLine,
            isCondition,
            isValue,
            tabs,
            wrap,
            isClass,
            isAssignment,
            ID,
            isLine,
            lineReturns,
            comments,
            lastNodeLocation,
            registry,
            isParam,
            isStatement,
            isObjProperty,
            typeData,
            afterParse,
            metaComments
          });
          break;
        }
        ;
      case 'Array':
        {
          Assignable = Assignable.unwrap;
          output += Assignable.parse({
            that,
            $such,
            scope,
            addSemicolon,
            vars,
            varExistent,
            constants,
            prevLine,
            isCondition,
            isValue,
            tabs,
            wrap,
            isClass,
            isAssignment,
            ID,
            method,
            comments,
            lastNodeLocation,
            registry,
            isFrom,
            isParam,
            isStatement,
            isObjProperty,
            typeData,
            afterParse,
            metaComments
          });
          break;
        }
        ;
    }
    if (isAssignment && !isStatement) {
      for (let [id, loc] of ID) {
        if (scope && !scope.includes(id.toString())) {
          id = id.toString();
          if (!vars.includes(id)) {
            vars.push(id);
            if (!vars.__locations) vars.__locations = {};
            vars.__locations[id] = loc;
          }
          scope.push(id);
        }
      }
    }
    return output;
  }
};
Nodes.Assignment = class Assignment extends Base {
  parse({
    that,
    $such,
    scope,
    vars,
    varExistent,
    constants,
    constant,
    construct,
    isValue,
    prevLine,
    tabs,
    lineReturns,
    isCondition,
    isCompare,
    comments,
    lastNodeLocation,
    registry = {},
    ID = [],
    FiresSuper,
    FiresAwait,
    FiresYield,
    isStatement,
    addSemicolon,
    afterParse,
    metaComments,
    isClass,
    hasTypes,
    typeData = []
  }) {
    let Assign = this,
      output = "";
    let TargetSoak = [];
    let {
      childComments
    } = matchComments(Assign[2].loc, comments, Assign[2].loc);
    let target = Assign[2].parse({
      that,
      $such,
      scope,
      vars,
      varExistent,
      constants,
      isValue: true,
      prevLine,
      tabs,
      isCompare,
      isAssigned: true,
      isNarrow: true,
      comments: childComments,
      lastNodeLocation,
      registry,
      FiresSuper,
      FiresAwait,
      FiresYield,
      FiresSoak: TargetSoak,
      afterParse,
      metaComments
    });
    if (TargetSoak.length) {
      target = loadSoaks(target, {
        tabs,
        scope,
        vars,
        prevLine,
        Soaks: TargetSoak,
        registry,
        loc: this.loc
      });
    }
    let LH,
      FiresSoak = [];
    switch (Assign[3][0]) {
      case "FROM":
        {
          LH = Assign[1].parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            constant,
            construct,
            isValue,
            prevLine,
            tabs,
            lineReturns,
            isCondition,
            isCompare,
            isAssignment: true,
            lastNodeLocation,
            registry,
            isFrom: true,
            ID,
            isStatement,
            FiresSoak,
            typeData,
            afterParse,
            metaComments
          });
          let forCheck = Assign[1].parse({
            isAssignment: true,
            isFrom: true
          }).toString();
          if (/^\[(.|\n)+\]$/.test(forCheck)) {
            LH = `{ ${LH.slice(1, -1)} }`;
          } else if (/^([a-z$_](?:[a-z$_\d]+)?)$/i.test(forCheck)) {
            LH = `{ ${LH} }`;
          } else if (Assign[1].rule === "Value Access" && Assign[1][1].rule === "This") {
            LH = `{ ${Assign[1][2].parse({
              registry,
              noDot: true
            })}: ${LH} }`;
          }
          break;
        }
        ;
      case "AT":
        {
          LH = Assign[1].parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            constant,
            construct,
            isValue,
            prevLine,
            tabs,
            lineReturns,
            isCondition,
            isCompare,
            isAssignment: true,
            lastNodeLocation,
            registry,
            ID,
            isStatement,
            FiresSoak,
            typeData,
            afterParse,
            metaComments
          });
          if (!/^\[(.|\n)+\]$/.test(LH)) {
            LH = `[${LH}]`;
          }
          ;
          break;
        }
        ;
      case "AS":
        {
          LH = Assign[1].parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            constant,
            construct,
            isValue,
            prevLine,
            tabs,
            lineReturns,
            isCondition,
            isCompare,
            isAssignment: true,
            lastNodeLocation,
            registry,
            ID: isClass ? [] : ID,
            isStatement,
            FiresSoak,
            typeData,
            afterParse,
            metaComments
          });
          break;
        }
    }
    if ((isClass || isStatement) && registry.isTypeScript && !registry.omitTypeScript && typeData.length && typeData[0].value) {
      LH += `: ${typeData[0].value}`;
    }
    output += LH + " = " + target;
    if (FiresSoak.length && constant) {
      this.throwSyntaxError(`Existential operators not supported in declaration statements.`);
    } else if (FiresSoak.length) {
      output = loadSoaks(output, {
        tabs,
        scope,
        vars,
        prevLine,
        Soaks: FiresSoak,
        registry,
        loc: this.loc
      });
    }
    if (!isClass && !isStatement && !["Value Access", "Expression IN Expression", "ThisProperty"].includes(Assign[1].unwrap.rule)) {
      if (!vars.__data) {
        vars.__data = [];
      }
      vars.__data.push(...typeData);
    } else if (!FiresSoak.length && typeData.length) {
      let mData = addMetaDataToPrevLine({
        prevLine,
        typeData: registry.isTypeScript && !registry.omitTypeScript ? typeData.map(d => Object.fromEntries(Object.entries(d).filter(o => o[0] !== "value"))) : typeData,
        tabs,
        metaComments,
        registry
      });
      output = mData + output;
    }
    if (typeData.length) hasTypes.push(1);
    return output;
  }
};
Nodes.Block = Nodes.ClassBlock = class Block extends Base {
  static wrap(...nodes) {
    let first = Array.from(nodes)[0],
      last;
    const jar = new Nodes.Body(null, []);
    if (typeof nodes === "undefined") nodes = [];
    for (const node of Array.from(nodes)) {
      jar[1].push(new Nodes.Line(null, node));
    }
    return jar;
  }
};
Nodes.Body = Nodes.ClassBody = class Body extends Base {
  parse({
    tabs = 0,
    vars = [],
    constants = [],
    that = [],
    $such = [],
    scope = [],
    isChildren = false,
    isClass = false,
    callSelf = false,
    func = false,
    scopedParams = Object.assign([], {
      generated: true
    }),
    top = 0,
    lastValue = [],
    varExistent = [],
    comments = [],
    lastNodeLocation = {
      first_line: 1,
      first_column: 1,
      last_line: 1,
      last_column: 1
    },
    registry = {},
    debug = false,
    FiresSuper = [],
    FiresYield = [],
    FiresAwait = [],
    assignRes,
    appendToVars,
    isParenthetical = false,
    canReturn = true
  } = {}) {
    const [rule, Lines] = this;
    let output = "";
    if (callSelf) {
      ++tabs;
    }
    var count = 0;
    var LastLineLocation = lastNodeLocation,
      disableNewlines = false,
      afterParse = [],
      mappedLocations = {};
    for (let Line of Lines) {
      ++count;
      let it,
        CurrLineLocation = Line.loc || LastLineLocation,
        lineReturns;
      if (Line.loc && !mappedLocations[Line.loc.src]) {
        mappedLocations[Line.loc.src] = {
          first_line: 1,
          first_column: 1,
          last_line: 1,
          last_column: 1
        };
      }
      let {
        childComments,
        matchedComments,
        metaComments
      } = matchComments(mappedLocations[Line.loc && Line.loc.src] || LastLineLocation, comments.filter(c => c.loc.src === (Line.loc && Line.loc.src)), CurrLineLocation);
      if (count === Lines.length && (assignRes || callSelf || func) && canReturn) {
        lineReturns = true; // Parser-only var
      } else {
        lineReturns = false;
      }
      it = Line.parse({
        that,
        $such,
        scope,
        vars,
        varExistent,
        constants,
        tabs,
        lineReturns: isParenthetical ? false : lineReturns,
        assignRes,
        isClass,
        isLine: true,
        func,
        scopedParams,
        nl: Line.lineCount || 0,
        lastValue,
        comments: childComments,
        metaComments,
        afterParse,
        lastNodeLocation: mappedLocations[Line.loc && Line.loc.src] || LastLineLocation,
        registry,
        FiresSuper,
        FiresAwait,
        FiresYield,
        isParenthetical
      });
      if (it === "" || it === ";") {
        disableNewlines = true;
        continue;
      }
      if (!disableNewlines) {
        output += "\n".repeat(Line.lineCount || 0);
      } else disableNewlines = false;
      let x;
      if (matchedComments.length) {
        for (let comment of matchedComments) {
          let commentOutput = parseComment(comment, tabs, undefined, registry);
          if (registry[comment.id]) continue;
          if (comment.appendToLastLine) {
            let resource = output,
              trim = 0;
            while (/\n|\r| /.test(resource.charAt(resource.length - 1))) {
              resource = resource.slice(0, -1);
              trim++;
            }
            output = resource + " " + commentOutput;
            x = !commentOutput.endsWith('\n');
          } else {
            output += tab(registry.tabSize, tabs) + commentOutput;
            x = !commentOutput.endsWith('\n');
          }
          registry[comment.id] = true;
        }
      }
      output += (x ? it.replace(/^ +/, " ") : it) + (isParenthetical ? count === Lines.length ? "" : ", " : "\n");
      LastLineLocation = CurrLineLocation;
      if (Line.loc && Line.loc.src) mappedLocations[Line.loc.src] = CurrLineLocation;
    }
    for (let comment of comments.filter(c => c.loc.first_line >= LastLineLocation.last_line && !c.jsdoc)) {
      if (registry[comment.id]) continue;
      let commentOutput = parseComment(comment, tabs, undefined, registry);
      if (comment.loc.first_line == LastLineLocation.last_line) {
        let resource = output,
          trim = 0;
        while (/\n|\r| /.test(resource.charAt(resource.length - 1))) {
          resource = resource.slice(0, -1);
          trim++;
        }
        output = resource + " " + commentOutput.trim() + "\n".repeat(trim);
      } else {
        output += tab(registry.tabSize, tabs) + commentOutput;
      }
      registry[comment.id] = true;
    }
    if (varExistent && varExistent.length && vars.length && !isChildren && !isClass) {
      for (let every in varExistent) {
        if (vars.includes(varExistent[every])) {
          vars.splice(vars.indexOf(varExistent[every]), 1);
        }
      }
    }
    if (scopedParams && scopedParams.length && vars.length) {
      for (let every of scopedParams) {
        if (vars.includes(every)) {
          vars.splice(vars.indexOf(every), 1);
        }
      }
    }
    if (!isChildren && !isClass) {
      if (appendToVars) vars.push(appendToVars);
      if (vars.length) {
        let _vars = vars.sort((a, b) => b.length - a.length).sort((a, b) => +a.startsWith('_') - +b.startsWith('_')).filter((t, i, r) => r.indexOf(t) === i);
        let dTypes = vars.__data && vars.__data.filter(d => _vars.includes(d.ID)) || [],
          ddef = "";
        if (dTypes.length && !registry.omitTypeScript) {
          registry.isTypeScript = true;
          let rewrite = [];
          ddef += buildVarDefinitions(dTypes, tabs, registry.useVar ? "var " : "let ", comments.filter(c => c.jsdoc), rewrite, registry);
          _vars = _vars.filter(v => !rewrite.includes(v)).map(v => {
            let ddef = dTypes.find(d => d.ID === v);
            if (ddef) {
              if (vars.__locations && vars.__locations[v] && registry && registry.sources) {
                v = registry.sources.add(vars.__locations[v]) + v;
              }
              return `${v}: ${registry.sources ? registry.sources.add(ddef.loc) : ''}${ddef.value}`;
            } else {
              if (vars.__locations && vars.__locations[v] && registry && registry.sources) {
                v = registry.sources.add(vars.__locations[v]) + v;
              }
              return v;
            }
            ;
          });
        } else if (dTypes.length && registry.omitTypeScript) {
          ddef += buildVarDefinitionsWithJSDoc(dTypes, tabs, registry.useVar ? "var " : "let ", comments.filter(c => c.jsdoc), registry);
          _vars = _vars.filter(v => !dTypes.find(d => d.ID === v));
        }
        output = (_vars.length ? tab(registry.tabSize, tabs) + (registry.useVar ? "var " : "let ") + _vars.map(v => {
          if (vars.__locations && vars.__locations[v] && registry && registry.sources) {
            v = registry.sources.add(vars.__locations[v]) + v;
          }
          return v;
        }).join(', ') + ";\n\n" : '') + ddef + output;
      }
    } else if (appendToVars) {
      output = tab(registry.tabSize, tabs) + (registry.useVar ? "var " : "let ") + appendToVars + ';\n\n' + output;
    }
    if (afterParse.length) {
      output = afterParse.join(`\n${tab(registry.tabSize, tabs)}`) + `\n\n${tab(registry.tabSize, tabs)}` + output;
    }
    if (callSelf) {
      output = "(" + (FiresAwait.length ? "async " : "") + "function () {\n" + output + tab(registry.tabSize, tabs - 1) + "}).call(this)";
    }
    return top ? output.replace(/(\n| )+$/, '') : output.trim();
  }
};
Nodes.Class = class Class extends Base {
  parse({
    that,
    $such,
    scope,
    vars = [],
    varExistent,
    constants,
    prevLine,
    isValue,
    isAssigned,
    tabs = 0,
    lineReturns,
    addSemicolon,
    comments = [],
    lastNodeLocation,
    registry = {},
    metaComments
  } = {}) {
    let output = "",
      className,
      classExtends,
      classAugment,
      classImplements,
      nom;
    let {
      contents: Class
    } = this;
    let {
      args: classArguments,
      ctor: classCtor
    } = Class[4] || {};
    classAugment = Class[3] || !!classCtor;
    classImplements = Class[5];
    nom = Class[0] && Class[0].parse ? Class[0].parse({
      registry: {}
    }).toString() : Class[0] ?? "Class";
    if (Class[0]) {
      className = Class[0].parse ? Class[0].parse({
        registry
      }).toString() : Class[0];
    } else if (!(isValue || isAssigned)) {
      className = nom = Reference(scope, true);
      $such[0] = className;
    }
    if (Class[1]) {
      classExtends = Class[1].parse({
        that,
        scope,
        tabs: tabs + 1,
        isParam: true,
        vars,
        varExistent,
        constants,
        comments,
        registry,
        addSemicolon: []
      });
    }
    if (classCtor && classExtends) {
      this.throwSyntaxError('Class inheritance is not supported with automated constructors.', this.findToken("EXTENDS") || Class[1].loc);
    }
    let Body = [],
      ForeignExps = [],
      ThisProperties = []; // a copy

    var vBody = Class[2],
      thisRegistered = [];
    if (vBody instanceof Nodes.Body) {
      ForeignExps = [];
      for (var _i = 0, _len = vBody[1].length; _i < _len; _i++) {
        var Line = vBody[1][_i],
          x;
        if ((x = Line.rule === "ClassFunction" || Line.unwrap.rule === "Value" && Line.unwrapUntil && !!Line.unwrapUntil(node => node instanceof Nodes.Function && !/FUNCTION/.test(node.rule))) || Line.unwrap.rule === "Assign" && Line.unwraps(2).rule === "Assignment" && Line.unwraps(3)[1].rule === "Identifier") {
          if (Line.unwrap.rule === "Assign") {
            thisRegistered.push(Line.unwraps(3)[1].parse({}));
          }
          if (Line.rule === "ClassFunction") {
            Line.setRule('Expression');
            Line[1] = new Nodes.Expression('Value', Line[1].setRule('Function')).setLoc(Line);
          }
          if (x) Line.isMethod = true;
          Body.push(Line);
          continue;
        }
        if (Line.unwrap.rule === "Value" && Line.unwraps(2).rule === "Assignable" && Line.unwraps(3).rule === "Identifier" && !!(Line.unwraps(3).loc || {}).type) {
          if (registry.isTypeScript && !registry.omitTypeScript) {
            ThisProperties.push(Line);
          }
          thisRegistered.push(Line.unwraps(3).parse({}));
          continue;
        }
        ForeignExps.push(Line);
      }
      Body = new Nodes.Body(null, Body).setLoc(Class[2].loc || Class.loc);
    } else {
      Body = [];
      ForeignExps = [];
    }
    let header = className ? "class " + className : "class";
    let cArgs = classArguments ? `<${classArguments.parse({})}>` : '';
    if (classArguments) header += `${registry.sources ? registry.sources.add(classArguments.loc) : ''}<${classArguments.parse({
      registry
    })}>`;
    if (classExtends) header += " extends " + classExtends;
    if (classImplements && classImplements[0]) {
      let Implements = classImplements.contents;
      header += ` implements ${Implements.map(i => {
        let [iName, iTags] = i.contents;
        return iName.parse({
          registry
        }) + (iTags ? `<${iTags.parse({
          registry
        })}>` : '');
      }).join(', ')}`;
    }
    if (classCtor && !ForeignExps.length && !registry.isRecomp) {
      if (!Body.length) {
        Body = new Nodes.Body(null, []).setLoc(Class.loc);
      }
      Body.unwrap.unshift(Object.assign(new Nodes.Line("Expression", new Nodes.Expression('Value', new Nodes.Value("Function", new Nodes.Function(null, {}, new Nodes.Base(null, {
        id: new Nodes.Identifier('null', 'constructor').setLoc(classCtor.loc),
        params: Object.assign(classCtor, {
          insertAll: true
        })
      }).setLoc(classCtor.loc), new Nodes.Body(null, []).setLoc(classCtor.loc)).setLoc(classCtor.loc)).setLoc(classCtor.loc)).setLoc(classCtor.loc)).setLoc(classCtor.loc), {
        isMethod: true
      }));
    }
    if (Body.length && classAugment && !registry.isRecomp) {
      let ctor, hasToString;
      for (let [func] of Body.contents.filter(Line => Line && Line.length)) {
        let synt = func.unwrapUntil && func.unwrapUntil(x => x instanceof Nodes.Function);
        if (synt) {
          let funcName = synt.unwrap[0][0] ? synt.unwrap[0][0][1] : null;
          if ([null, "constructor"].includes(funcName) && !ctor) {
            ctor = synt;
          }
          if (funcName === "toString") {
            hasToString = true;
          }
        }
      }
      let inserted = ctor ? getInsertedParams(ctor, {
        metaComments
      }) : [];
      if (registry.isTypeScript && !registry.omitTypeScript) {
        inserted.forEach(([i,, loc, tloc]) => {
          if (!thisRegistered.includes(i)) {
            let node = new Nodes.Line("Expression", new Nodes.Value("Assignable", new Nodes.Assignable("Identifier", new Nodes.Identifier("IDENTIFIER", i))));
            if (tloc) {
              node.setLoc({
                ...loc,
                type: tloc
              });
            }
            ThisProperties.push(node);
          }
        });
      }
      if (ctor && !hasToString) {
        let ins = inserted.map(p => p[0]),
          refVals,
          valArg,
          valContent;
        if (ins.length) {
          refVals = Reference(scope, true, 'vals');
          valArg = Reference(scope, true, 'val');
          valContent = Reference(scope, true, 'cont');
        }
        var loc = this.findToken('CLASS') || classCtor && classCtor.loc || this.loc;
        Body.unwrap.push(Object.assign(new Nodes.Line("Expression", new Nodes.Expression('Value', new Nodes.Value("Function", new Nodes.Function(null, {}, new Nodes.Base(null, {
          id: new Nodes.Identifier(null, 'toString').setLoc(Class.loc)
        }).setLoc(loc), new Nodes.Body(null, [new Nodes.Line("SimpleCode", [`${ins.length ? `${registry.useVar ? 'var' : 'let'} ${refVals} = ["${ins.join('", "')}"].map((function (${!registry.omitTypeScript && registry.isTypeScript ? `this: ${nom + cArgs}, ` : ''}${valArg}${!registry.omitTypeScript && registry.isTypeScript ? ': string' : ''}) {\n${tab(registry.tabSize, tabs + 3 + !!ForeignExps.length)}${registry.useVar ? 'var' : 'let'} ${valContent}${!registry.omitTypeScript && registry.isTypeScript ? ': any' : ''} = this[${valArg}${!registry.omitTypeScript && registry.isTypeScript ? ` as keyof ${nom + cArgs}` : ''}];\n${tab(registry.tabSize, tabs + 3 + !!ForeignExps.length)}return ${valArg} + "=" + (typeof ${valContent} === "string" && ('"'+ ${valContent}.replace('"', '\\"') +'"') || ${valContent});\n${tab(registry.tabSize, tabs + 2 + !!ForeignExps.length)}}).bind(this));\n\n${tab(registry.tabSize, tabs + 2 + !!ForeignExps.length)}` : ''}return \`${nom}(${ins.length ? '${' + refVals + '.join(", ")}' : ''})\`;`])]).setLoc(loc), {
          returns: ["string"]
        }).setLoc(loc)).setLoc(loc)).setLoc(loc)).setLoc(loc), {
          isMethod: true
        }));
        var tInserted = inserted.filter(inst => !!inst[3] && ThisProperties.findIndex(t => {
          return t.unwrap.parse({
            addSemicolon: []
          }) === inst[1];
        }) === -1);
        if (registry.isTypeScript && !registry.omitTypeScript && tInserted.length) {
          ThisProperties.unshift(...tInserted.map(([, Identifier, Loc, Type]) => {
            return new Nodes.Line('Expression', new Nodes.Expression('Value', new Nodes.Value('Assignable', new Nodes.Assignable('Identifier', new Nodes.Identifier(null, Identifier))))).setLoc({
              ...Loc,
              type: Type
            });
          }));
        }
      }
    }
    if (!ForeignExps.length) {
      if (Body instanceof Nodes.Body) {
        Body = new Nodes.Body(null, Body.unwrap.sort((a, b) => {
          return a.loc.first_line - b.loc.first_line;
        }).map((Line, ind, arr) => (Line.isMethod || arr[ind - 1] && arr[ind - 1].isMethod) && !Line.lineCount ? Object.assign(Line, {
          lineCount: 1
        }) : Line)).parse({
          $such,
          scope,
          tabs: tabs + 1,
          isClass: {
            doesExtend: !!classExtends
          },
          isChildren: true,
          vars: [].concat(vars),
          varExistent,
          constants,
          comments: [...comments, ...(metaComments || [])],
          lastNodeLocation: (Class[1] || Class[0] || {
            loc: lastNodeLocation
          }).loc,
          debug: true,
          registry
        });
      } else {
        Body = "";
      }
      if (ThisProperties.length && !this.isRecomp) {
        Body = ThisProperties.map(Type => {
          return `${Type.unwrap.parse({
            registry,
            addSemicolon: []
          })}${Type.loc && Type.loc.type.optional ? '?' : ''}: ${Type.loc ? Type.loc.type.value : 'any'};`;
        }).join(`\n${tab(registry.tabSize, tabs + 1)}`) + (Body.length ? `\n${tab(registry.tabSize, tabs + 1)}` : '') + Body;
      }
      output += header;
      if (Body.length) output += " {\n" + tab(registry.tabSize, tabs + 1) + Body + "\n" + tab(registry.tabSize, tabs) + "}";else output += ` {\n${tab(registry.tabSize, tabs)}}`;
    } else {
      var lastNode, parsedBody;
      Body = Body.unwrap;
      vars.push(className);
      scope.push(className);
      let classBlock = new Nodes.Line("Expression", new Nodes.Expression("Class", new Nodes.Class(null, [nom], Class[1], new Nodes.Body(null, Body), classAugment, {
        ctor: classCtor,
        args: classArguments
      }).setLoc(this.loc)).setLoc(this.loc)).setLoc(this.loc);
      parsedBody = tab(registry.tabSize, tabs + 1) + new Nodes.Body(null, [classBlock, new Nodes.Line("SimpleCode", ""), ...ForeignExps]).parse({
        that: [nom],
        scope,
        tabs: tabs + 1,
        vars: [],
        varExistent: [],
        comments: [...comments, ...(metaComments || [])],
        constants,
        registry
      });
      parsedBody += `\n${tab(registry.tabSize, tabs + 1)}return ${nom};`;
      output = nom + " = (function() {\n" + parsedBody + "\n" + tab(registry.tabSize, tabs) + "}).call(this);";
      if (!isValue) addSemicolon.push(1);
    }
    return output;
  }
};
Nodes.Compare = class Compare extends Base {
  get operand() {
    switch (this.rule) {
      case "IS":
        return "===";
      case "ISNT":
        return "!==";
      case "OR":
        return "||";
      case "AND":
        return "&&";
      default:
        return this.rule.toLowerCase();
    }
  }
  get inverse() {
    switch (this.operand) {
      case "IS":
        return "===";
      case "ISNT":
        return "!==";
      case "===":
        return "!==";
      case "!==":
        return "===";
      case "==":
        return "!=";
      case "!=":
        return "==";
      case "<":
        return ">=";
      case ">":
        return "<=";
      case ">=":
        return "<";
      case "<=":
        return ">";
      default:
        return this.operand;
      // Have to wrap the expression with !( ), so we return the same operand
    }
  }
};
Nodes.Else = class Else extends Base {
  get isIndirect() {
    if (this.rule === "ElseOtherwise Expression" && !(this.unwrapAll instanceof Nodes.Body)) return true;
  }
};
Nodes.Expression = class Expression extends Base {
  parse({
    lineReturns = false,
    addSemicolon = [],
    construct = false,
    constants = [],
    vars = [],
    varExistent = [],
    that = [],
    $such = [],
    scope = [],
    isValue = false,
    isInvoked = false,
    isOperation = false,
    isLine = false,
    prevLine = [],
    tabs = 0,
    isCondition = false,
    isDirect = false,
    isClass = false,
    isCompare = false,
    isAssignment = false,
    isAssigned = false,
    ID = [],
    isParam = false,
    nl,
    func = false,
    scopedParams = Object.assign([], {
      generated: true
    }),
    comments = [],
    afterParse,
    metaComments = [],
    lastNodeLocation = {
      first_line: 0,
      first_column: 0,
      last_line: 0,
      last_column: 0
    },
    registry = {},
    isUnless = false,
    FiresSuper = [],
    FiresAwait = [],
    FiresYield = [],
    assignRes = false,
    isStatement = false,
    constant = false,
    FiresSoak,
    isNarrow = false,
    isObjProperty,
    metaQueue,
    isParenthetical,
    NoPrint = false
  } = {}) {
    if (isParenthetical) isValue = true;
    var [rule, Exp] = this;
    let output = "",
      block,
      wrap,
      inverse;
    if (Exp[0] == "Expression") Exp = Exp[1];
    comments = matchComments(undefined, comments, this.loc).childComments;
    switch (this.rule) {
      case "JSX":
        {
          let wrapSelf;
          registry.isJSX = true;
          if (!isLine) {
            wrap = true;
          } else {
            if (lineReturns) wrapSelf = true;
            addSemicolon.pop();
          }
          let outcome;
          if (wrapSelf || wrap) {
            outcome = `\n${tab(registry.tabSize, tabs + 1)}${Exp.parse({
              lineReturns,
              addSemicolon,
              construct,
              that,
              $such,
              scope,
              constants,
              vars,
              varExistent,
              isValue,
              prevLine,
              tabs: tabs + 1,
              isCondition,
              isOperation,
              isStatement,
              isDirect,
              isClass,
              isLine,
              isAssignment,
              ID,
              isParam,
              func,
              scopedParams,
              isAssigned,
              comments,
              lastNodeLocation,
              registry,
              FiresSuper,
              FiresAwait,
              FiresYield,
              FiresSoak,
              isNarrow,
              isObjProperty,
              afterParse,
              metaComments,
              metaQueue,
              NoPrint
            })}\n${tab(registry.tabSize, tabs)}`;
          } else {
            outcome = Exp.parse({
              lineReturns,
              addSemicolon,
              construct,
              that,
              $such,
              scope,
              constants,
              vars,
              varExistent,
              isValue,
              prevLine,
              tabs,
              isCondition,
              isOperation,
              isStatement,
              isDirect,
              isClass,
              isLine,
              isAssignment,
              ID,
              isParam,
              func,
              scopedParams,
              isAssigned,
              comments,
              lastNodeLocation,
              registry,
              FiresSuper,
              FiresAwait,
              FiresYield,
              FiresSoak,
              isNarrow,
              isObjProperty,
              afterParse,
              metaComments,
              metaQueue,
              NoPrint
            });
          }
          if (wrapSelf) outcome = `(${outcome})`;
          output += outcome;
          break;
        }
        ;
      case "While":
        {
          block = true;
          if (isValue) {
            let res = Reference(scope, true, 'results');
            output += Nodes.Block.wrap(this, '', 'return ' + res + ';').parse({
              addSemicolon: [1],
              that,
              $such,
              scope,
              constants,
              vars,
              varExistent,
              isChildren: true,
              appendToVars: `${res}${registry.isTypeScript && !registry.omitTypeScript ? ': any[]' : ''} = []`,
              tabs,
              comments,
              lastNodeLocation,
              registry,
              FiresSuper,
              FiresAwait,
              FiresYield,
              callSelf: true,
              assignRes: [res, true]
            });
            break;
          }
          addSemicolon.pop();
          let [Condition, Body, Keyword] = Exp.contents;
          output += "while (" + Condition.parse({
            addSemicolon: [],
            constants,
            vars,
            varExistent,
            that,
            $such,
            scope,
            isValue: true,
            prevLine,
            tabs,
            isCondition: true,
            isAssigned,
            scopedParams,
            comments,
            registry,
            isUnless: Keyword[0].endsWith("UNTIL"),
            FiresSuper,
            FiresAwait,
            FiresYield
          }) + ") {\n" + tab(registry.tabSize, tabs + 1) + Body.parse({
            lineReturns: !!assignRes,
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            tabs: tabs + 1,
            comments,
            registry,
            isChildren: true,
            assignRes,
            FiresSuper,
            FiresAwait,
            FiresYield
          }) + "\n" + tab(registry.tabSize, tabs) + "}";
          break;
        }
        ;
      case "Switch":
        {
          block = true;
          if (isValue) {
            let res = Letter(scope, 's');
            output += Nodes.Block.wrap(this, '', 'return ' + res + ';').parse({
              addSemicolon: [1],
              construct,
              that,
              $such,
              scope,
              constants,
              vars,
              varExistent,
              tabs,
              comments,
              lastNodeLocation,
              registry,
              FiresSuper,
              FiresAwait,
              FiresYield,
              callSelf: true,
              assignRes: [res, false],
              appendToVars: res + (registry.isTypeScript && !registry.omitTypeScript ? ': any' : ''),
              isChildren: true
            });
            break;
          }
          addSemicolon.pop();
          output += Exp.parse({
            lineReturns: !!assignRes,
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            tabs: tabs + 1,
            comments,
            registry,
            isChildren: true,
            assignRes,
            prevLine,
            FiresSuper,
            FiresAwait,
            FiresYield
          });
          break;
        }
      case "For":
        {
          block = true;
          if (isValue) {
            let res = Reference(scope, true, 'results');
            let Awaits = [];
            output += Nodes.Block.wrap(this, '', 'return ' + res + ';').parse({
              addSemicolon: [1],
              construct,
              that,
              $such,
              scope,
              constants,
              vars: [],
              varExistent: [].concat(varExistent),
              tabs,
              comments,
              lastNodeLocation,
              registry,
              FiresSuper,
              FiresAwait: Awaits,
              FiresYield,
              callSelf: true,
              assignRes: [res, true],
              appendToVars: res + (registry.isTypeScript && !registry.omitTypeScript ? ': any[]' : '') + ' = []'
            });
            if (Awaits.length) {
              output = `await ${output}`;
              FiresAwait.push(1);
            }
            break;
          }
          addSemicolon.pop();
          output += Exp.parse({
            lineReturns: !!assignRes,
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            tabs: tabs + 1,
            comments,
            registry,
            isChildren: true,
            assignRes,
            prevLine,
            FiresSuper,
            FiresAwait,
            FiresYield
          });
          break;
        }
        ;
      case "TryBlock":
        {
          block = true;
          if (isValue) {
            let res = Reference(scope, true, 'result');
            output += Nodes.Block.wrap(this, '', 'return ' + res + ';').parse({
              addSemicolon: [1],
              construct,
              that,
              $such,
              scope,
              constants,
              vars,
              varExistent,
              isChildren: true,
              tabs,
              comments,
              lastNodeLocation,
              registry,
              FiresSuper,
              FiresAwait,
              FiresYield,
              callSelf: true,
              isChildren: true,
              assignRes: [res, false],
              appendToVars: res + (registry.isTypeScript && !registry.omitTypeScript ? ': any' : '')
            });
            break;
          }
          addSemicolon.pop();
          let TRY, CATCH, FINALLY;
          Exp.contents.filter(x => x !== null).map(([a, ...b]) => {
            switch (a.split(' ')[0]) {
              case "TRY":
              case "FINALLY":
                {
                  let [Block] = b;
                  if (Block instanceof Nodes.Block) {
                    Block = Block.unwrap;
                  }
                  Block = Block.parse({
                    lineReturns: lineReturns || !!assignRes,
                    addSemicolon: [1],
                    construct,
                    that,
                    $such,
                    scope,
                    constants,
                    vars,
                    varExistent,
                    prevLine,
                    tabs: tabs + 1,
                    comments,
                    lastNodeLocation,
                    registry,
                    FiresSuper,
                    FiresAwait,
                    FiresYield,
                    assignRes,
                    isChildren: true,
                    func: lineReturns
                  });
                  let formatted = `${a.split(' ')[0].toLowerCase()} {\n${tab(registry.tabSize, tabs + 1)}${Block}\n${tab(registry.tabSize, tabs)}}`;
                  if (a.split(' ')[0] === "TRY") TRY = formatted;else FINALLY = formatted;
                  break;
                }
                ;
              case "CATCH":
                {
                  let [ErrValue, Block] = b,
                    $$such = [];
                  if (ErrValue) {
                    ErrValue = ErrValue.parse({
                      registry
                    });
                  } else {
                    ErrValue = Reference(scope, true, 'err');
                    $$such[0] = ErrValue;
                  }
                  if (Block instanceof Nodes.Block) {
                    Block = Block.unwrap;
                  }
                  Block = Block.parse({
                    lineReturns: lineReturns || !!assignRes,
                    addSemicolon: [1],
                    construct,
                    that,
                    $such: $$such,
                    scope,
                    constants,
                    vars,
                    varExistent,
                    prevLine,
                    tabs: tabs + 1,
                    comments,
                    lastNodeLocation,
                    registry,
                    FiresSuper,
                    FiresAwait,
                    FiresYield,
                    assignRes,
                    isChildren: true,
                    func: lineReturns
                  });
                  CATCH = `catch (${ErrValue}) {\n${tab(registry.tabSize, tabs + 1)}${Block}\n${tab(registry.tabSize, tabs)}}`;
                  break;
                }
            }
          });
          if (!CATCH) {
            CATCH = `catch(${Reference(scope, false, 'err')}) {  }`;
          }
          output += `${TRY} ${CATCH}${FINALLY ? ` ${FINALLY}` : ""}`;
          break;
        }
        ;
      case "Operation":
        {
          if (isInvoked && !["DO Expression", "@ Value"].includes(this.unwrap.rule)) wrap = true;
          if (isUnless && !Exp.canInverse) {
            inverse = false;
            wrap = true;
          } else if (isUnless) {
            inverse = true;
          }
          isValue = isValue || Array.isArray(assignRes) && lineReturns;
          output += Exp.parse({
            lineReturns,
            addSemicolon,
            construct,
            that,
            $such,
            scope,
            constants,
            vars,
            varExistent,
            isValue,
            prevLine,
            tabs,
            isCondition,
            isLine,
            isCompare,
            func,
            scopedParams,
            isAssigned,
            comments,
            lastNodeLocation,
            registry,
            isUnless,
            FiresSuper,
            FiresAwait,
            FiresYield
          });
          break;
        }
        ;
      case "Value":
        {
          if (!registry.isELSON && (isInvoked || isLine) && !lineReturns && ['Assignable'].includes(Exp.rule) && !["Identifier", "Array", "Value Access", "Expression IN Expression"].includes(Exp[1].rule) || Exp.rule === "Function" && isInvoked) {
            wrap = true;
          }
          if (["Function"].includes(Exp.rule) && isClass) {
            block = true;
            addSemicolon.pop();
          }
          output += Exp.parse({
            lineReturns,
            addSemicolon,
            construct,
            that,
            $such,
            scope,
            constants,
            vars,
            varExistent,
            isValue,
            prevLine,
            tabs,
            isCondition,
            isOperation,
            isStatement,
            isDirect,
            isClass,
            isLine,
            isAssignment,
            ID,
            isParam,
            func,
            scopedParams,
            isAssigned,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresAwait,
            FiresYield,
            FiresSoak,
            isNarrow,
            isObjProperty,
            afterParse,
            metaComments,
            metaQueue,
            NoPrint
          });
          break;
        }
        ;
      case "Class":
        {
          if (isInvoked) wrap = true;else block = true;
          output += Exp.parse({
            lineReturns,
            addSemicolon,
            construct,
            that,
            $such,
            scope,
            constants,
            vars,
            varExistent,
            isValue,
            prevLine,
            tabs,
            isCondition,
            isLine,
            func,
            scopedParams,
            isAssigned,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresAwait,
            FiresYield,
            metaComments
          });
          addSemicolon.pop();
          break;
        }
        ;
      case "Assign":
        {
          if (!isCompare && !isStatement && (isInvoked || isOperation || isNarrow)) wrap = true;
          output += Exp.parse({
            vars,
            varExistent,
            lineReturns,
            that,
            $such,
            scope,
            constants,
            construct,
            isValue,
            prevLine,
            isCondition,
            isCompare,
            tabs,
            func,
            scopedParams,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresAwait,
            FiresYield,
            ID,
            isStatement,
            constant,
            addSemicolon,
            afterParse,
            metaComments,
            isClass
          });
          break;
        }
        ;
      case "If":
        {
          if (isInvoked) wrap = true;
          if (!Exp.quoteSyntax) {
            block = true;
            addSemicolon && addSemicolon.pop && addSemicolon.pop();
          }
          if (Array.isArray(assignRes)) {
            if (Exp.unwrap[2] instanceof Nodes.Expression) {
              Exp.unwrap[2] = Nodes.Block.wrap(Exp.unwrap[2]);
            }
          }
          output += Exp.parse({
            vars,
            varExistent,
            constants,
            that,
            $such,
            scope,
            isValue,
            isInvoked,
            prevLine,
            tabs,
            lineReturns,
            isLine,
            func,
            scopedParams,
            isAssigned,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresAwait,
            FiresYield,
            assignRes
          });
          break;
        }
        ;
      case "Code":
        {
          if (isInvoked) wrap = true;
          let [FuncParams, Arrow, Body] = Exp.contents,
            {
              async: sync,
              yield: yields
            } = Exp;
          if (Body instanceof Nodes.Block) Body = Body.unwrap;
          let isInline = Body instanceof Nodes.Expression;
          if (sync) output += "async ";
          if (Arrow === "=") Arrow = "->";
          if (Arrow === "->") {
            output += "function";
            if (isLine) {
              output += " " + Reference(scope, true, 'fn');
            }
            output += "(";
          } else output += "(";
          let Params = [],
            ParsedParams = [],
            Insert = [],
            lastNode;
          if (FuncParams !== null) {
            for (let Parameter of FuncParams.contents) {
              lastNode = Parameter.loc;
              ParsedParams.push(ParseParam(Parameter.unwrap, {
                scope,
                vars,
                varExistent,
                tabs: tabs + 1,
                constants,
                $such,
                that,
                varExistent,
                Insert,
                Params,
                comments,
                lastNodeLocation,
                registry,
                metaComments
              }));
            }
          }
          if (Insert.length && !registry.isRecomp) {
            if (isInline) {
              Body = Nodes.Block.wrap(Body);
              isInline = false;
            }
            let Lines = Body[1];
            let index = 0;
            Lines.find(([, Exp], i) => {
              if (!(Exp instanceof Base)) return;
              let FiresSuper = [];
              Exp.parse({
                FiresSuper
              });
              if (FiresSuper.length) {
                index = i + 1;
              }
            });
            Lines.splice(index, 0, ...Insert.map((ins, i) => {
              return new Nodes.Line("SimpleCode", [`${that && that[0] || "this"}.${registry.sources ? registry.sources.add(ins[2]) : ''}${ins[0]} = ${ins[1]};`]);
            }));
          }
          output += ParsedParams.join(', ') + ')';
          let Awaits = [],
            Generator = [],
            isArrow;
          if (isInline && Arrow === "=>") {
            isArrow = true;
            output += " => ";
            output += Body.parse({
              constants,
              that,
              $such,
              scope: scope.concat(...Params),
              isValue: true,
              prevLine,
              tabs,
              isLine,
              func: true,
              scopedParams: Params,
              isAssigned,
              vars,
              varExistent,
              comments,
              lastNodeLocation,
              registry,
              FiresAwait: Awaits,
              FiresYield: Generator
            });
          } else {
            output += Arrow === "=>" ? (isArrow = true) && ` ${Arrow} ` : " ";
            output += "{\n" + tab(registry.tabSize, tabs + 1) + Body.parse({
              lineReturns: true,
              constants,
              that,
              $such,
              scope: scope.concat(...Params),
              varExistent: vars,
              varExistent,
              tabs: tabs + 1,
              func: true,
              scopedParams: Params,
              comments,
              lastNodeLocation,
              registry,
              FiresAwait: Awaits,
              FiresYield: Generator
            }) + "\n" + tab(registry.tabSize, tabs) + "}";
          }
          if ((Generator.length || yields) && isArrow) {
            this.throwSyntaxError('Generators can\'t be used in arrow functions.', Generator[0]);
          } else if (Generator.length || yields) {
            output = output.replace(/^function\(/, 'function*(');
          }
          if (Awaits.length && !sync) {
            output = `async ${output}`;
          }
          break;
        }
        ;
      case "Label":
        {
          let Bd;
          output += Exp[1].parse({
            registry
          }) + ': ';
          if (Exp[2] instanceof Nodes.Block) Bd = Exp[2].unwrap;else Bd = Exp[2];
          output += `{\n${tab(registry.tabSize, tabs + 1)}${Bd.parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            tabs: tabs + 1,
            comments,
            registry,
            isChildren: true,
            assignRes,
            prevLine,
            FiresSuper,
            FiresAwait,
            FiresYield
          })}\n${tab(registry.tabSize, tabs)}}`;
          break;
        }
    }
    if (lineReturns && !block) {
      if (Array.isArray(assignRes)) {
        output = (registry.sources ? registry.sources.add(this.loc) : '') + assignRes[0] + (assignRes[1] ? ".push(" + output + ")" : " = " + output);
      } else output = (registry.sources ? registry.sources.add(this.loc) : '') + "return " + output;
    }
    if (wrap) {
      output = (registry.sources ? registry.sources.add(this.loc) : '') + "(" + output + ")";
    }
    if (isUnless && !inverse) {
      output = "!" + output;
    }
    if (construct) {
      output = (registry.sources ? registry.sources.add(this.loc) : '') + "new " + output;
    }
    if (addSemicolon.length && !block) {
      output += ";";
      addSemicolon.pop();
    }
    return output;
  }
};
Nodes.For = class For extends Base {
  parse({
    prevLine,
    lineReturns,
    that,
    $such,
    scope,
    vars,
    varExistent,
    constants,
    tabs,
    comments,
    registry = {},
    isChildren,
    assignRes,
    appendToVars,
    FiresSuper,
    FiresAwait,
    FiresYield
  }) {
    let [Header, Body, Keyword] = this.contents,
      output = "";
    Body = Body instanceof Nodes.Block ? Body.unwrap : Body;
    if (typeof Header[1] === "string") {
      if (/for_(from|at|as)/.test(Header[1])) {
        let [[Index, Values],, Target] = Header,
          Assignments = [];
        let _ref = Letter(scope, 'j');
        let kw = Keyword ? Keyword[0].toLowerCase() + " " : "";
        scope.push(_ref);
        vars.push(_ref);
        if (!Keyword && !vars.includes(Index.parse().toString)) vars.push(Index.parse().toString());
        let refAssignable = new Nodes.Identifier('Identifier', _ref);
        output += `for (${kw}${Index.parse({
          that,
          $such,
          scope,
          constants,
          vars,
          varExistent,
          registry
        })} in (${registry.sources ? registry.sources.add(Target.loc) : ''}${_ref} = ${Target.parse({
          that,
          $such,
          scope,
          vars,
          varExistent,
          constants,
          isValue: true,
          isAssigned: true,
          registry,
          FiresSuper,
          FiresAwait,
          FiresYield
        })})) {\n` + tab(registry.tabSize, tabs);
        Target = new Nodes.Expression('Value', new Nodes.Value('Assignable', new Nodes.Assignable('Value Access', new Nodes.Value('Assignable', new Nodes.Assignable('Identifier', refAssignable.setLoc(Target.loc)).setLoc(Target.loc)).setLoc(Target.loc), new Nodes.Access('INDEX_START Expression INDEX_END', Index).setLoc(Index.loc)).setLoc(Target.loc)).setLoc(Target.loc));
        let section = kw + new Nodes.Expression('Assign', new Nodes.Assign('Assignment', new Nodes.Assignment(null, Values, Target, [Header[1].split('_').pop().toUpperCase()]).setLoc(Values.loc)).setLoc(Values.loc)).parse({
          that,
          $such,
          scope,
          vars,
          varExistent,
          constants,
          tabs: tabs,
          comments,
          registry,
          isChildren,
          assignRes,
          prevLine: Assignments,
          isLine: true,
          FiresSuper,
          FiresAwait,
          FiresYield,
          isStatement: Array.isArray(Keyword),
          constant: Keyword && Keyword[0] === "CONST"
        }) + `;\n\n${tab(registry.tabSize, tabs)}`;
        output += `${Assignments.length ? Assignments.join(`;\n${tab(registry.tabSize, tabs)}`) + `;\n${tab(registry.tabSize, tabs)}` : ''}${section}`;
        output += Body.parse({
          prevLine,
          lineReturns,
          that,
          $such,
          scope,
          vars,
          varExistent,
          constants,
          tabs,
          comments,
          registry,
          isChildren: true,
          assignRes,
          FiresSuper,
          FiresAwait,
          FiresYield
        });
        output += `\n${tab(registry.tabSize, tabs - 1)}}`;
      } else {
        let [Assignable, Kwd, TTarget] = Header,
          Assignments = [],
          section = "";
        if (Kwd === "for_of" || Kwd === "for_in" && Assignable.rule === "Identifier") {
          let ID = [];
          if (!Keyword) {
            new Nodes.Assignment("Assignable AssignKeyword Expression", Assignable, new Nodes.Expression(null, []), ['AS']).setLoc(Header[0].loc).parse({
              that,
              $such,
              scope,
              vars,
              varExistent,
              constants,
              registry,
              ID,
              hasTypes: [],
              tabs
            });
            for (let [id, loc] of ID) {
              if (!vars.includes(id.toString())) {
                vars.push(id);
                if (loc) {
                  if (!vars.__locations) {
                    vars.__locations = {};
                  }
                  vars.__locations[id] = loc;
                }
              }
            }
          }
          let kw = Keyword ? Keyword[0].toLowerCase() + " " : "";
          output += `for (${kw}${Header[0].parse({
            prevLine,
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            tabs,
            comments,
            registry,
            isChildren,
            assignRes,
            addSemicolon: []
          })} ${registry.sources ? registry.sources.add(Header[2].loc) : ''}${Header[1].split('_')[1]} ${Header[2].parse({
            prevLine,
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            tabs,
            comments,
            registry,
            isChildren,
            assignRes,
            addSemicolon: [],
            FiresSuper,
            FiresAwait,
            FiresYield
          })}) {\n${tab(registry.tabSize, tabs)}${Body.parse({
            prevLine,
            lineReturns,
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            tabs,
            comments,
            registry,
            isChildren: true,
            assignRes,
            FiresSuper,
            FiresAwait,
            FiresYield
          })}\n${tab(registry.tabSize, tabs - 1)}}`;
        } else {
          let _ref = Letter(scope, 'j'),
            _i = Letter(scope.concat(_ref), 'i');
          scope.push(_ref, _i);
          vars.push(_ref, _i);
          let refAssignable = new Nodes.Identifier('Identifier', _ref);
          let iAssignable = new Nodes.Expression('Value', new Nodes.Value('Assignable', new Nodes.Assignable('Identifier', new Nodes.Identifier('IDENTIFIER', _i))));
          let Target = new Nodes.Expression('Value', new Nodes.Value('Assignable', new Nodes.Assignable('Value Access', new Nodes.Value('Assignable', new Nodes.Assignable('Identifier', refAssignable.setLoc(TTarget.loc)).setLoc(TTarget.loc)).setLoc(TTarget.loc), new Nodes.Access('INDEX_START Expression INDEX_END', iAssignable).setLoc(Assignable.loc)).setLoc(TTarget.loc)).setLoc(TTarget.loc));
          let kw = Keyword ? Keyword[0].toLowerCase() + " " : "";
          section = kw + new Nodes.Expression('Assign', new Nodes.Assign('Assignment', new Nodes.Assignment(null, Assignable, Target, ['AS']).setLoc(Assignable.loc)).setLoc(Assignable.loc)).parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            tabs: tabs,
            comments,
            registry,
            isChildren,
            assignRes,
            prevLine: Assignments,
            isLine: true,
            FiresSuper,
            FiresAwait,
            FiresYield,
            isStatement: Array.isArray(Keyword),
            constant: Keyword && Keyword[0] === "CONST"
          }) + `;\n\n${tab(registry.tabSize, tabs)}`;
          output += `for (${_i} in (${_ref} = ${TTarget.parse({
            that,
            $such,
            prevLine,
            scope,
            vars,
            varExistent,
            constants,
            isAssigned: true,
            isValue: true,
            addSemicolon: [],
            registry,
            comments,
            FiresSuper,
            FiresAwait,
            FiresYield
          })})) {\n${tab(registry.tabSize, tabs)}${Assignments.length ? Assignments.join(`;\n${tab(registry.tabSize, tabs)}`) + `;\n${tab(registry.tabSize, tabs)}` : ''}${section}${Body.parse({
            prevLine,
            lineReturns,
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            tabs,
            comments,
            registry,
            isChildren: true,
            assignRes,
            FiresSuper,
            FiresAwait,
            FiresYield
          })}\n${tab(registry.tabSize, tabs - 1)}}`;
        }
      }
    } else {
      let Headers = Header.map(h => {
        return h.parse({
          that,
          $such,
          scope,
          vars,
          varExistent,
          constants,
          isValue: true,
          isAssigned: true,
          registry,
          FiresSuper,
          FiresAwait,
          FiresYield,
          registry
        });
      }).join('; ');
      output += `for (${Headers}) {\n${tab(registry.tabSize, tabs)}${Body.parse({
        prevLine,
        lineReturns,
        that,
        $such,
        scope,
        vars,
        varExistent,
        constants,
        tabs,
        comments,
        registry,
        isChildren: true,
        assignRes,
        FiresSuper,
        FiresAwait,
        FiresYield
      })}\n${tab(registry.tabSize, tabs - 1)}}`;
    }
    return output;
  }
};
Nodes.ForExpression = class ForExpression extends Base {
  parse(opts) {
    let {
      rule
    } = this;
    if (rule === "Declare") {
      return new Nodes.Statement('Declare', this.unwrap).setLoc(this.loc).parse(opts);
    } else {
      return this.unwrap.parse(opts);
    }
  }
};
function getInsertedParams(Func, {
  metaComments
}) {
  let Value = Func.contents;
  let Header = Value[1] && Value[1].unwrap,
    FuncParams = Header.params || [];
  let Params = [],
    ParsedParams = [],
    Insert = [],
    lastNode,
    typeData = [],
    InsertAll = FuncParams && FuncParams.insertAll;
  if (FuncParams && FuncParams[1] instanceof Nodes.ParamList) {
    for (let i = 0, p = FuncParams[1].contents; i < p.length; i++) {
      let Parameter = p[i];
      lastNode = Parameter.loc;
      ParsedParams.push(ParseParam(Parameter.unwrap, {
        scope: [],
        vars: [],
        varExistent: [],
        tabs: 1,
        constants: [],
        $such: [],
        that: [],
        Insert,
        Params,
        comments: [],
        lastNodeLocation: Func.loc,
        registry: {},
        isParam: true,
        typeData,
        i,
        metaComments
      }));
    }
  }
  if (InsertAll) {
    Params.filter(P => Array.isArray(P)).filter(([Param]) => Insert.findIndex(Ins => Ins[1] === Param) === -1).map(([Param, Loc, Type]) => Insert.push([Param, Param, Loc, Type]));
  }
  return Insert;
}
Nodes.FunctionPostlude = class extends Base {};
Nodes.FunctionPrelude = Nodes.ClassFunctionPrelude = class FunctionPrelude extends Base {
  addTag(toAdd) {
    let [rule, token, loc] = toAdd;
    for (let [tag] of this.contents) {
      if (tag === "GET" && token === "SET") {
        toAdd.throwSyntaxError(`can't use a setter in a getter function`);
      } else if (tag === "SET" && token === "SET") {
        toAdd.throwSyntaxError(`can't use a getter in a setter function`);
      }
    }
    Object.assign(toAdd.loc, loc);
    this.push(toAdd);
    return this.contents;
  }
  buildObject() {
    let result = {};
    for (let token of this.contents) {
      result[token[0].toLowerCase()] = token;
    }
    return result;
  }
};
Nodes.Function = Nodes.ClassFunction = class Function extends Base {
  parse({
    that = [],
    $such = [],
    scope = [],
    vars = [],
    varExistent = [],
    constants = [],
    prevLine = [],
    isValue,
    tabs = 0,
    func = [],
    scopedParams = [],
    comments = [],
    lastNodeLocation = {},
    registry = {},
    FiresSuper = [],
    isInvoked,
    isParam,
    isClass,
    isObject,
    lineReturns,
    isExport,
    isLine,
    metaComments = [],
    metaQueue = []
  }) {
    let {
      loc,
      rule
    } = this;
    let output = "";
    let Value = this.contents;
    let FunctionTags = Value[0] && Value[0].addTag ? Value[0].buildObject() : Value[0];
    let returns,
      {
        get: getter = undefined,
        static: _static,
        set: setter,
        async: sync,
        function: FnT
      } = FunctionTags || {};
    let yields = FnT && FnT.loc && FnT.loc.origin === "function*";
    if (_static) {
      output += "static ";
    }
    if (getter) {
      output += "get ";
    }
    if (setter) {
      output += "set ";
    }
    if (sync) {
      output += "async ";
    }
    let yieldable = true;
    if (!isClass && !isObject) {
      output += `function${yields ? '*' : ''} `;
    } else {
      yields ? output += `* ` : void 0;
    }
    let Header = Value[1] && Value[1].unwrap || {},
      {
        id: FuncName,
        params: FuncParams,
        generics: args
      } = Header || {},
      asyncable = true,
      Supers;
    returns = [];
    if (FuncParams && FuncParams.loc && FuncParams.loc.type) {
      returns.push(FuncParams.loc.type);
    }
    if (returns.length > 1) {
      this.throwSyntaxError('Duplicate return-type annotation after end of name/parameters', returns[1].loc);
    }
    if (Value[2]) {
      if (Value[2].loc && Value[2].loc.type) {
        returns.push(Value[2].loc.type);
      }
      if (Value[2] instanceof Nodes.FunctionPostlude) {
        Value[2] = Value[2].unwrap;
      }
    } else {
      Value[2] = Nodes.Block.wrap().setLoc(this.loc);
    }
    if (!FuncName && isExport) {
      this.throwSyntaxError('Expected a name for exported function.');
    }
    if (FuncName) {
      FuncName = FuncName.parse ? FuncName.parse() : FuncName;
      if (isObject && /FUNCTION/.test(rule)) {
        output += `${FuncName}: function `;
      }
      if (isClass && FuncName === "constructor") {
        asyncable = false;
      } else if (isClass && isClass.doesExtend) {
        Supers = FuncName.parse ? FuncName.parse() : FuncName;
      }
      output += FuncName.parse ? FuncName.parse({
        registry
      }) : (registry.sources ? registry.sources.add(FuncName.loc || Value[1].loc) : '') + FuncName;
    } else if (isClass) {
      output += (registry.sources ? registry.sources.add(loc) : '') + (FuncName = "constructor");
      asyncable = false;
    } else if (isLine && !isValue) {
      output += (registry.sources ? registry.sources.add(loc) : '') + (FuncName = Reference(scope, true, "fn"));
      $such.push(FuncName);
    } else if (isObject) {
      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
        message: 'Object literals can\'t contain anonymous functions.',
        location: {
          ...loc,
          last_line: loc.first_line,
          last_column: loc.first_column + 1
        }
      });
    }
    if (sync && !asyncable) {
      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
        message: "'async' modifier cannot appear on a constructor declaration.",
        location: {
          ...loc,
          last_line: loc.first_line,
          last_column: loc.first_column + 5,
          scope: registry.scope
        }
      });
    }
    if (args && !registry.omitTypeScript) {
      registry.isTypeScript = true;
      output += (registry.sources ? registry.sources.add(args.loc) : '') + '<' + args.parse({
        registry
      }) + '>';
      args = undefined;
    }
    output += "(";
    let b;
    if (output == "function (") output = "function(";
    let header = output;
    let {
        childComments
      } = matchComments(loc, comments, loc),
      commentOutput = "";
    let Params = [],
      ParsedParams = [],
      Insert = [],
      lastNode,
      typeData = [],
      InsertAll = !!FuncParams && FuncParams.insertAll;
    if (FuncParams && FuncParams[1] instanceof Nodes.ParamList) {
      for (let i = 0, p = FuncParams[1].contents; i < p.length; i++) {
        let Parameter = p[i];
        lastNode = Parameter.loc;
        ParsedParams.push(ParseParam(Parameter.unwrap, {
          scope,
          vars,
          varExistent,
          tabs,
          constants,
          $such,
          that,
          Insert,
          InsertAll,
          Params,
          comments: childComments,
          lastNodeLocation,
          registry,
          isParam: true,
          typeData,
          i,
          metaComments
        }));
      }
    }
    let DocParams = Params;
    Params = Params.filter(Param => Array.isArray(Param));
    if (InsertAll) {
      Params.filter(P => Array.isArray(P)).filter(([Param]) => Insert.findIndex(Ins => Ins[1] === Param) === -1).map(([Param, Loc]) => Insert.push([Param, Param, Loc]));
    }
    var ParamData = [];
    for (let l = DocParams.length, i = 0; i < l; i++) {
      let Param = DocParams[i];
      if (!Array.isArray(Param)) {
        ParamData.push(Param);
        continue;
      }
      let [ID, loc, metaType, ID2 = ID, propertyID] = Param;
      metaType = metaType ? {
        value: metaType.nodes.parse({
          registry
        }),
        loc: metaType.nodes.loc,
        ID,
        ID2
      } : undefined;
      if (!metaType) {
        metaType = getDataOfMetaComments({
          metaComments,
          ID,
          ID2,
          tabs,
          loc,
          registry,
          strict: true
        });
      } else {
        attachDescriptions(metaComments, [metaType], tabs, registry, true);
      }
      if (metaType) {
        ParamData.push({
          ID,
          ...metaType,
          propertyID
        });
      } else {
        ParamData.push({
          ID,
          propertyID
        });
      }
    }
    function gfl(elm) {
      if (elm.commentStart) {
        return elm.commentStart;
      } else if (elm.last_comment) {
        return elm.last_comment.first_line;
      } else if (elm.comment) {
        return elm.comment.loc.first_line;
      }
    }
    let startLine,
      lessThanLine,
      startComm = ParamData.filter(t => !t.symbol && (t.commentStart !== undefined || t.last_comment !== undefined || t.comment !== undefined)).sort((a, b) => {
        return gfl(a) - gfl(b);
      })[0];
    if (startComm) {
      startLine = gfl(startComm);
    } else {
      lessThanLine = startLine = this.loc.first_line;
    }
    var selectedComments = metaComments.slice(0, lessThanLine !== undefined ? metaComments.length : metaComments.findIndex(c => c.loc.first_line === startLine)).filter(c => !c.read && !/^(#:)?\s*((?:[^\x00-\x7F]|[a-z$_])(?:[^\x00-\x7F]|[a-z$_\d])*)\s*(:|-*>|=>?)/i.test(c[1]));
    var selectedDescription = [];
    for (let comment of selectedComments.reverse()) {
      if (comment.loc.last_line === startLine - 1) {
        selectedDescription.unshift(comment[1]);
        startLine = comment.loc.first_line;
        comment.read = true;
      } else break;
    }
    ;
    if (!!ParamData.find(d => registry.isTypeScript && !registry.omitTypeScript ? d.description : d.value) || selectedDescription.length) {
      buildFunctionDefinitionWithJSDoc({
        ParamData,
        registry,
        tabs,
        loc: this.loc,
        prevLine,
        scope,
        selectedDescription: selectedDescription.join(`\n${tab(registry.tabSize, tabs)} * `)
      });
    }
    if (Insert.length && !registry.isRecomp) {
      if (Value[2] instanceof Nodes.Expression || Value[2] instanceof Nodes.Statement) {
        Value[2] = new Nodes.Block(null, Nodes.Block.wrap(Value[2]));
      }
      let Lines = Value[2][1];
      let index = 0;
      Lines.find(([, Exp], i) => {
        if (!(Exp instanceof Base)) return;
        let FiresSuper = [];
        Exp.parse({
          FiresSuper
        });
        if (FiresSuper.length) {
          index = i + 1;
          return true;
        }
      });
      Lines.splice(index, 0, ...Insert.map((ins, i) => {
        return new Nodes.Line("SimpleCode", [`${that && that[0] || "this"}.${registry && registry.sources ? registry.sources.add(ins[2]) : ''}${ins[0]} = ${ins[1]};`]);
      }));
    }
    if (!Value[2][1] || !Value[2][1].length) Value[2][1] = [];
    if (childComments.length && Value[2].loc) {
      for (let comment of childComments) {
        if (registry[comment.id]) continue;
        if (comment.loc.first_line === Value[2].loc.first_line) {
          commentOutput += parseComment(comment, tabs, undefined, registry) + tab(registry.tabSize, tabs + 1);
          registry[comment.id] = true;
        }
      }
    }
    let Awaits = [],
      Yields = [];
    output = Value[2].parse({
      scope: scope.concat(...Params),
      isValue,
      tabs: tabs + 1,
      lineReturns,
      canReturn: !setter,
      func: FuncName === "constructor" && isClass ? false : true,
      scopedParams: Object.assign(Params.map(([Param]) => Param), {
        Supers
      }),
      varExistent: [...vars, ...varExistent],
      comments,
      lastNodeLocation,
      registry,
      FiresAwait: Awaits,
      FiresYield: Yields
    });
    let ParamsOutput = ParsedParams.join(', ');
    if (ParamsOutput && getter) {
      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
        message: 'An accessor cannot have parameters',
        location: FuncParams[1].loc
      });
    }
    header += ParamsOutput + ")";
    if (returns && returns.length && !registry.omitTypeScript) {
      registry.isTypeScript = true;
      header += `: ${returns[0].nodes ? returns[0].nodes.parse({
        registry
      }) : returns[0]}`;
    }
    header += ' ';
    output = header + "{" + (commentOutput ? " " + commentOutput.trim() : "") + "\n" + tab(registry.tabSize, tabs + 1) + output + "\n" + tab(registry.tabSize, tabs) + "}";
    if (Yields.length && !yields) {
      if (!yieldable) {
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
          message: 'Unexpected yield.',
          location: Yields[0]
        });
      }
      output = output.replace(/^function/i, 'function*');
    }
    if (Awaits.length && !sync) {
      if (!asyncable) {
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
          message: "'await' statements cannot appear on a constructor declaration.",
          location: Awaits[0]
        });
      }
      output = `async ${output}`;
    }
    let lastCommLoc = this.loc;
    let docComments = [];
    for (let o = metaComments.length; o > 0; o--) {
      let c = metaComments[o - 1];
      if (!registry[c.id] && (c.loc.last_line + 1 === lastCommLoc.first_line || c.loc.last_line === lastCommLoc.first_line && c.loc.last_column < lastCommLoc.first_column)) {
        lastCommLoc = c.loc;
        docComments.unshift(c[1]);
      }
    }
    ;
    if (docComments.length) {
      if (metaQueue) {
        metaQueue.push({
          1: ['* ', ...docComments].join('\n' + tab(registry.tabSize, tabs) + ' * ') + '\n' + tab(registry.tabSize, tabs),
          block: true
        });
      }
    }
    return output;
  }
};
Nodes.Identifier = class Identifier extends Base {
  parse({
    registry: {
      sources
    } = {}
  } = {}) {
    let Identifier = this[1];
    if (Array.isArray(Identifier[0]) && Identifier[0].length) {
      Identifier = Identifier[0];
    }
    if (this.rule === 0 && !/^((?:[^\x00-\x7F]|[a-z$_])(?:[^\x00-\x7F]|[a-z$_\d])*)$/i.test(Identifier)) this.throwSyntaxError('Can\'t convert property to importable variable.');
    if (sources) {
      Identifier = sources.add(this.loc) + Identifier;
    }
    return Identifier;
  }
};
Nodes.If = class IfBlock extends Base {
  parse({
    isStatement,
    vars,
    varExistent,
    constants,
    that,
    $such,
    scope,
    isValue,
    isInvoked,
    prevLine,
    tabs,
    lineReturns,
    isLine,
    scopedParams,
    isAssigned,
    comments,
    lastNodeLocation,
    registry = {},
    FiresSuper = [],
    assignRes
  } = {}) {
    let func;
    let output = "";
    let If = this;
    if (If.postfix) {
      let isUnless = If.unless;
      if (If.statement) {
        isValue = false;
        isStatement = true;
      }
      If = If.contents;
      let plusTabs = tabs;
      if (isInvoked && !isValue) {
        plusTabs++;
      }
      let [Condition, Body] = [If[0].parse({
        that,
        $such,
        scope,
        vars,
        varExistent,
        constants,
        prevLine,
        isValue,
        isCondition: true,
        tabs,
        comments,
        lastNodeLocation,
        registry,
        isUnless,
        FiresSuper
      }), If[1].parse({
        that,
        $such,
        scope,
        vars,
        varExistent,
        constants,
        prevLine,
        tabs,
        lineReturns,
        addSemicolon: isValue ? [] : [1],
        comments,
        lastNodeLocation: If[0].loc,
        registry,
        FiresSuper
      })];
      if (isValue && !(If[1] instanceof Nodes.Statement)) {
        output += Condition + " ? " + Body + " : void 0";
      } else if (isInvoked) {
        output += "if (" + Condition + ") {\n" + tab(registry.tabSize, plusTabs + 1) + Body + "\n" + tab(registry.tabSize, tabs + 1) + "}" + "\n" + tab(registry.tabSize, tabs);
      } else {
        output += "if (" + Condition + ") {\n" + tab(registry.tabSize, tabs + 1) + Body + "\n" + tab(registry.tabSize, tabs) + "}";
      }
      if (isInvoked) {
        if (isStatement) output = "{\n" + tab(registry.tabSize, plusTabs) + output + "}";
        output = "() => " + output;
      }
      return output;
    }
    const {
        loc,
        quoteSyntax
      } = If,
      real = If;
    If = If.contents;
    let isIndirect = (quoteSyntax || /IfUnless (\( )?Expression (\) )?(DoThen )?(\{ )?Expression/.test(If[0].rule)) && !Array.isArray(assignRes);
    let isElseIndirect;
    if (If[1]) {
      isElseIndirect = isIndirect && (quoteSyntax || If[1].isIndirect);
    }
    if (isValue && !isIndirect) {
      let rearrange = Nodes.Block.wrap(new Nodes.Expression("If", real)).setLocation(If.loc);
      return rearrange.parse({
        that,
        $such,
        scope,
        vars,
        varExistent,
        constants,
        tabs: tabs,
        callSelf: true,
        isChildren: true,
        comments,
        lastNodeLocation,
        registry,
        FiresSuper,
        scopedParams
      });
    }
    let Condition,
      Body,
      Unless,
      Else = If[1];
    [Condition, Body, Unless] = If[0].contents;
    let Soaks = [],
      condLoc = Condition.loc;
    Condition = Condition.parse({
      that,
      $such,
      scope,
      vars,
      varExistent,
      constants,
      prevLine,
      isValue: true,
      tabs,
      isCondition: true,
      isDirect: true,
      comments,
      lastNodeLocation,
      FiresSuper,
      registry,
      isUnless: Array.isArray(Unless) && Unless[0] === "UNLESS",
      FiresSoak: Soaks
    });
    if (Soaks.length) {
      Condition = loadSoaks(Condition, {
        tabs,
        scope,
        vars,
        prevLine,
        Soaks,
        registry,
        loc: this.loc
      });
    }
    if (lineReturns) func = true;
    let bodyLoc = Body.loc,
      elseLoc = Else ? Else.loc : {
        first_line: bodyLoc.last_line,
        first_column: bodyLoc.last_column
      };
    Soaks = [];
    if (Body instanceof Nodes.Expression || Body instanceof Nodes.Statement) {
      let {
        matchedComments
      } = matchComments(condLoc, comments, elseLoc);
      Body = Body.parse({
        that,
        $such,
        scope,
        vars,
        varExistent,
        constants,
        tabs: isIndirect ? tabs : tabs + 1,
        isValue: !Else ? isIndirect : isIndirect && isElseIndirect,
        prevLine,
        lineReturns: lineReturns && !isIndirect,
        addSemicolon: isIndirect ? [] : [1],
        comments: matchedComments,
        lastNodeLocation: Condition.loc,
        registry,
        FiresSuper,
        assignRes,
        FiresSoak: Soaks,
        isNarrow: !Else ? isIndirect : isIndirect && isElseIndirect
      });
      if (Soaks.length) {
        Body = loadSoaks(Body, {
          tabs,
          scope,
          vars,
          prevLine,
          Soaks,
          registry,
          loc: bodyLoc
        });
      }
      for (let comment of matchedComments) {
        if (registry[comment.id]) continue;
        let commentOutput = parseComment(comment, tabs + 1, true, registry);
        Body += '\n' + tab(registry.tabSize, tabs + 1) + commentOutput.trim();
        registry[comment.id] = true;
      }
    } else {
      Body = Body instanceof Nodes.Block ? Body.unwrap : Body;
      Body = Body.parse({
        that,
        $such,
        scope,
        vars,
        varExistent,
        constants,
        tabs: tabs + 1,
        isChildren: true,
        func: lineReturns,
        comments,
        lastNodeLocation: Condition.loc,
        registry,
        FiresSuper,
        assignRes
      });
    }
    let isElseIf;
    if (Else) {
      Else = Else.unwrap;
      if (Else instanceof Nodes.Expression || Else instanceof Nodes.Statement) {
        Soaks = [];
        isElseIf = Else.unwrap instanceof Nodes.If;
        Else = Else.parse({
          that,
          $such,
          scope,
          vars,
          varExistent,
          constants,
          tabs: tabs + 1 - (isElseIf || isIndirect),
          isValue: isIndirect && isElseIndirect,
          prevLine,
          lineReturns: !isElseIndirect && lineReturns,
          addSemicolon: isElseIndirect ? [] : [1],
          comments,
          lastNodeLocation: Body.loc,
          registry,
          FiresSuper,
          assignRes,
          FiresSoak: Soaks,
          isNarrow: isIndirect && isElseIndirect
        });
        if (Soaks.length) {
          Else = loadSoaks(Else, {
            tabs,
            scope,
            vars,
            prevLine,
            Soaks,
            registry,
            loc: elseLoc
          });
        }
      } else {
        Else = Else.unwrap;
        isElseIndirect = false;
        isElseIf = Else[1].length === 1 && Else.unwrapUntil && !!Else.unwrapUntil(C => C instanceof Nodes.If);
        Else = Else.parse({
          that,
          $such,
          scope,
          vars,
          varExistent,
          constants,
          isChildren: true,
          tabs: tabs + 1 - isElseIf,
          func,
          comments,
          lastNodeLocation: Condition.loc,
          registry,
          FiresSuper,
          assignRes
        });
      }
    }
    if (!isIndirect || isIndirect && Else && !isElseIndirect) {
      output += "if (" + Condition + ") ";
      output += "{\n" + tab(registry.tabSize, tabs + 1) + Body + "\n" + tab(registry.tabSize, tabs) + "}";
      if (Else) {
        if (isElseIf) {
          output += " else " + Else;
        } else {
          output += " else {\n" + tab(registry.tabSize, tabs + 1) + Else + "\n" + tab(registry.tabSize, tabs) + "}";
        }
      }
    } else {
      if (!isValue && lineReturns) output = (registry.sources ? registry.sources.add(this.loc) : '') + "return " + output;
      output += `${Condition} ? ${Body} : ${Else ? Else : 'void 0'}`;
    }
    return output;
  }
};
Nodes.Interpolation = class Interpolation extends Base {
  parse(opts) {
    switch (this.rule) {
      case "String":
        {
          return this.unwrap.parse(opts).replace('`', opts.inJSX ? '`' : '\\`');
        }
        ;
      default:
        {
          let int = this.unwrap.parse({
            ...opts,
            addSemicolon: [],
            isValue: true
          });
          return opts.inJSX ? `{${int}}` : `\${${int}}`;
        }
    }
  }
};
Nodes.Invocation = class Invocation extends Base {
  parse({
    that,
    $such,
    scope,
    vars,
    varExistent,
    constants,
    prevLine,
    isValue,
    tabs = 0,
    lineReturns,
    func,
    scopedParams,
    comments = [],
    lastNodeLocation,
    registry = {},
    FiresSuper = [],
    FiresSoak,
    NoPrint = false
  } = {}) {
    let [Value, Arguments, TypeArguments] = this.contents,
      {
        soak,
        templ
      } = this,
      lastNode;
    let Params = !templ && Arguments && Arguments.unwrap,
      x = Arguments && Arguments.indented,
      BeforeComments = "",
      ll;
    lastNode = Params && Params.loc || this.loc;
    let vRule = Value.rule,
      vLoc = Value.loc;
    let Soaks = [];
    Value = Value === "super" ? scopedParams && scopedParams.Supers ? `${Value}.${scopedParams.Supers}` : Value : Value.parse({}) === "print" && registry.cout && !NoPrint ? (registry.sources ? registry.sources.add(Value.loc) : "") + registry.cout : Value.parse({
      that,
      $such,
      scope,
      vars,
      varExistent,
      constants,
      prevLine,
      isInvoked: true,
      tabs,
      lineReturns,
      func,
      scopedParams,
      comments,
      lastNodeLocation,
      registry,
      FiresSoak: Soaks
    });
    if (Soaks.length) {
      Value = loadSoaks(Value, {
        tabs,
        scope,
        vars,
        prevLine,
        Soaks,
        registry,
        loc: vLoc
      });
    }
    if (soak) {
      let _ref = Value,
        s = "";
      if (vRule !== "Assignable") {
        _ref = Letter(scope, 'f');
        vars.push(_ref);
        scope.push(_ref);
        s += `(${_ref} = ${Value}) && `;
      }
      s += `typeof ${_ref} === "function" ? ${_ref}`;
      Value = s;
    }
    if (TypeArguments) {
      TypeArguments = `${registry.sources ? registry.sources.add(TypeArguments.loc) : ""}<${TypeArguments.parse({
        that,
        $such,
        scope,
        vars,
        varExistent,
        constants,
        prevLine,
        isInvoked: true,
        tabs,
        lineReturns,
        func,
        scopedParams,
        comments,
        lastNodeLocation,
        registry,
        FiresSoak: Soaks
      })}>`;
    } else TypeArguments = "";
    for (let comment of comments.filter(c => c.loc.first_line < lastNode.first_line || c.loc.first_line === lastNode.first_line && c.loc.first_column < lastNode.first_column)) {
      if (registry[comment.id]) continue;
      let commentOutput = parseComment(comment, tabs + 1, true, registry);
      BeforeComments += commentOutput;
      registry[comment.id] = true;
      x = true;
    }
    if (!templ && typeof Params !== "undefined" && Params.contents.length) {
      x = Params.contents.find(Param => {
        if (/boolean|undefined/.test(typeof Param)) {
          return !Param;
        }
        if (Param.unwrap.rule === "Code") return true;
        if (Param.unwrap.rule === "Value" && Param.unwrap.unwrap.rule === 'Function') return true;
      }) || x;
      Params = Params.contents.map((Param, i, r) => {
        if (/boolean|undefined/.test(typeof Param)) {
          return undefined;
        }
        let {
            expansion
          } = Param,
          cO;
        Param = Param.unwrapUntil(C => C instanceof Nodes.Expression) || Param;
        let {
          childComments,
          matchedComments
        } = matchComments(lastNode, comments, Param.loc);
        let Soaks = [];
        let res = Param.parse({
          that,
          $such,
          scope,
          vars,
          varExistent,
          constants,
          prevLine,
          isValue: true,
          isParam: true,
          tabs: x ? tabs + 1 : tabs,
          func,
          scopedParams,
          comments: childComments,
          lastNodeLocation: lastNode,
          registry,
          FiresSoak: Soaks
        });
        if (Soaks.length) {
          res = loadSoaks(res, {
            tabs,
            scope,
            vars,
            prevLine,
            Soaks,
            registry,
            loc: Param.loc
          });
        }
        lastNode = Param.loc;
        if (expansion) res = `...${res}`;
        if (matchedComments.length) {
          for (let comment of matchedComments) {
            if (registry[comment.id]) continue;
            x = true;
            let separator = "";
            if (comment.loc.first_line > lastNode.last_line) separator = "\n" + tab(registry.tabSize, tabs + 1);
            cO = separator + parseComment(comment, tabs + 1, true, registry);
            res = `${cO}${res}`;
            registry[comment.id] = true;
          }
        } else if (r[i - 1] === false || i !== 0 && r[i - 1] === undefined) {
          res = `\n${tab(registry.tabSize, tabs + 1) + res}`;
        }
        return res;
      }).filter(t => t !== undefined);
    } else {
      Params = [];
    }
    ll = Params.length;
    let ParamsOutput = Params.join(', '),
      b,
      AfterComments = "",
      StringOutput = templ && Arguments.parse({
        that,
        $such,
        scope,
        vars,
        varExistent,
        constants,
        prevLine,
        isValue,
        tabs,
        lineReturns,
        func,
        scopedParams,
        comments,
        lastNodeLocation,
        registry,
        FiresSuper,
        forceBacktick: true
      });
    for (let comment of comments.filter(c => c.loc.first_line >= lastNode.last_line)) {
      if (registry[comment.id]) continue;
      x = true;
      let commentOutput = parseComment(comment, tabs, true, registry);
      if (comment.loc.first_line == lastNode.last_line) {
        let resource = AfterComments,
          trim = 0;
        while (/\n|\r| /.test(resource.charAt(resource.length - 1))) {
          resource = resource.slice(0, -1);
          trim++;
        }
        AfterComments = resource + " " + commentOutput;
      } else {
        AfterComments += "\n" + tab(registry.tabSize, tabs + 1) + commentOutput;
      }
      registry[comment.id] = true;
    }
    if (x && !BeforeComments && ParamsOutput.startsWith('{\n') && !(/\n\s*\}$/.test(ParamsOutput) && ll > 1)) {
      x = false;
    }
    if (x) ParamsOutput = "\n" + tab(registry.tabSize, tabs + 1) + BeforeComments + ParamsOutput + AfterComments + "\n" + tab(registry.tabSize, tabs);
    if (this.isSuper) FiresSuper.push(1);
    return Value + TypeArguments + (templ ? StringOutput : "(" + ParamsOutput + ")") + (soak ? ' : void 0' : '');
  }
  get isSuper() {
    return this[1] === "super";
  }
};
Nodes.JSX = class JSX extends Base {
  parse(opts) {
    let fragments = [],
      {
        tabSize
      } = opts.registry,
      {
        tabs
      } = opts,
      lastInterpolation;
    for (const Interpolation of this.unwrap[0].slice(1)) {
      if (typeof Interpolation === "number") {
        tabs += Interpolation;
        lastInterpolation = Interpolation;
        fragments.push(`\n${tab(tabSize, tabs)}`);
        continue;
      }
      if (Interpolation.rule === "String" && lastInterpolation instanceof Nodes.Interpolation && lastInterpolation.rule === "String") {
        fragments.push(`\n${tab(tabSize, tabs)}`);
      }
      fragments.push(Interpolation.parse({
        ...opts,
        tabs,
        lineReturns: false,
        inJSX: true
      }));
      lastInterpolation = Interpolation;
    }
    return fragments.join('');
  }
};
Nodes.JointExpression = class JointExpression extends Base {
  parse(opts) {
    let Expressions = this.contents,
      output;
    output = Expressions.map(Exp => {
      return Exp.parse(opts);
    }).join(', ');
    return output;
  }
};
Nodes.Line = Nodes.ClassLine = class Line extends Base {
  parse({
    that,
    $such,
    scope,
    constants,
    vars,
    varExistent,
    tabs = 0,
    lineReturns,
    isClass,
    isLine = true,
    func,
    scopedParams,
    nl,
    lastValue,
    comments = [],
    afterParse,
    metaComments = [],
    lastNodeLocation,
    registry = {},
    FiresSuper = [],
    FiresYield = [],
    FiresAwait = [],
    assignRes = false,
    isParenthetical
  } = {}) {
    let colon = isParenthetical ? ", " : '\n\n';
    const [rule, Expression] = this;
    let output = "";
    var prevLine = [];
    output += tab(registry.tabSize, tabs) + (!!Expression.parse ? Expression.parse({
      addSemicolon: registry.isELSON || isParenthetical ? [] : [1],
      that,
      $such,
      scope,
      constants,
      vars,
      varExistent,
      prevLine,
      tabs,
      lineReturns,
      isClass,
      isLine,
      func,
      scopedParams,
      nl,
      comments,
      lastNodeLocation,
      registry,
      FiresSuper,
      FiresYield,
      FiresAwait,
      assignRes,
      isParenthetical,
      isValue: !!isParenthetical,
      afterParse,
      metaComments
    }) : Expression);
    if (prevLine.length) output = tab(registry.tabSize, tabs) + prevLine.join(colon + tab(registry.tabSize, tabs)) + (colon === "\n\n" ? '\n' : colon) + output;
    return output;
  }
};
Nodes.Literal = class Literal extends Base {
  parse({
    that,
    $such,
    scope,
    addSemicolon,
    vars,
    varExistent,
    constants,
    lineReturns,
    prevLine,
    isCondition,
    isValue,
    tabs,
    wrap,
    isClass,
    isLine,
    isAssignment,
    ID,
    func,
    scopedParams,
    comments,
    lastNodeLocation,
    registry = {}
  }) {
    const [rule, Literal] = this;
    let output = "";
    switch (true) {
      case Literal instanceof Nodes.AlphaNum:
        {
          output = Literal.parse({
            that,
            $such,
            scope,
            addSemicolon,
            vars,
            varExistent,
            constants,
            lineReturns,
            prevLine,
            isCondition,
            isValue,
            tabs,
            wrap,
            isClass,
            isLine,
            isAssignment,
            ID,
            func,
            scopedParams,
            comments,
            lastNodeLocation,
            registry
          });
        }
        ;
        break;
      case Literal instanceof Nodes.Regex:
        output = Literal.parse({
          that,
          $such,
          scope,
          addSemicolon,
          vars,
          varExistent,
          constants,
          lineReturns,
          prevLine,
          isCondition,
          isValue,
          tabs,
          wrap,
          isClass,
          isLine,
          isAssignment,
          ID,
          func,
          scopedParams,
          comments,
          lastNodeLocation,
          registry
        });
        break;
      default:
        output = (registry.sources ? registry.sources.add(this.loc) : '') + Literal;
        break;
    }
    return output;
  }
};
Nodes.Logical = class Logical extends Nodes.Compare {};
Nodes.Object = class Object extends Base {
  parse({
    that,
    $such,
    scope,
    addSemicolon = [],
    vars,
    varExistent,
    constants,
    prevLine,
    isCondition,
    isValue,
    isParam,
    tabs = 0,
    lineReturns,
    wrap,
    isClass,
    isAssignment,
    isStatement,
    ID = [],
    comments = [],
    lastNodeLocation,
    registry = {},
    typeData = [],
    afterParse,
    metaComments = []
  } = {}) {
    metaComments = comments.filter(c => c.jsdoc);
    let output = "";
    output += '{';
    let Object = this;
    let Assignments = [];
    let lastNode = Object.loc,
      initLoc = Object.unwrap[0] && Object.unwrap[0][2] && Object.unwrap[0][2][0] || lastNode,
      x = !isParam && Object.indented;
    Object = Object.unwrap;
    var test,
      BeforeComments = "";
    for (let comment of comments.filter(c => c.loc.first_line < initLoc.first_line || c.loc.first_line === initLoc.first_line && c.loc.first_column < initLoc.first_column)) {
      if (registry[comment.id]) continue;
      let commentOutput = parseComment(comment, tabs + 1, true, registry);
      BeforeComments += commentOutput;
      registry[comment.id] = true;
      x = true;
    }
    for (let Obj of Object) {
      if (/boolean|undefined/.test(typeof Obj)) {
        if (!Obj) {
          x = true;
          Assignments.push(["jump", ""]);
        }
        continue;
      }
      if (!isAssignment && Obj instanceof Nodes.Assignment) {
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
          message: 'Assignments not allowed in this context.',
          location: Obj.loc
        });
      } else if (isAssignment && !(Obj[1].unwrap instanceof Nodes.Value) && !(Obj instanceof Nodes.Assignment) && !(Obj[1] && Obj[1].unwrap instanceof Nodes.Assign) && Obj[1]) {
        if (!(Obj[1] instanceof Nodes.Assignable) || !(Obj[1].unwrap.unwrap instanceof Nodes.Assignment || Obj[1].unwrap.unwrap instanceof Nodes.Assignable)) {
          (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
            message: 'Invalid left-hand assignment reference.',
            location: Obj[2] && Obj[2][1] || Obj.loc
          });
        }
      }
      let {
          childComments,
          matchedComments
        } = matchComments(lastNode, comments, Obj[2] && Obj[2][1] || Obj.loc),
        typeMatch = Obj[2] && Obj[2][0].type,
        Id;
      let it = "",
        cO = "",
        LH,
        RH,
        qt;
      if (Obj instanceof Nodes.Assignment) Obj = Obj.slice(1);
      LH = Obj[0];
      let metaQueue = [];
      if (LH instanceof Nodes.Expression) {
        LH = `[${LH.parse({
          that,
          $such,
          scope,
          addSemicolon: [],
          vars,
          varExistent,
          constants,
          prevLine,
          isValue: true,
          isParam: true,
          tabs: tabs + 1,
          isAssignment,
          ID,
          comments: childComments,
          lastNodeLocation,
          registry
        })}]`;
      } else if (LH instanceof Nodes.AlphaNum) {
        let wrp;
        if (LH.unwrap && LH.unwrap[0] === "StringWithInterpolations") wrp = true;
        if (registry.isELSON && LH.unwrap && LH.unwrap[0] !== "STRING") qt = true;
        LH = LH.parse({
          that,
          $such,
          scope,
          addSemicolon: [],
          vars,
          varExistent,
          constants,
          prevLine,
          isValue: true,
          isParam: true,
          tabs: tabs + 1,
          isAssignment,
          ID,
          comments: childComments,
          lastNodeLocation,
          registry
        });
        if (wrp) LH = `[${LH}]`;
        if (qt) {
          LH = `"${LH}"`;
        }
      } else if (registry.isELSON) {
        LH = `"${LH}"`;
      } else {
        if (isAssignment && LH.parse && !(LH[0] === "Identifier" || LH instanceof Nodes.Identifier)) {
          LH.throwSyntaxError('Unexpected left-hand assignment INSIDE another assignment');
        }
        Id = LH = LH.parse ? LH.parse({
          registry
        }) : LH;
      }
      if (registry.sources) {
        it += registry.sources.add(Obj[2] && Obj[2][0] || Obj.loc);
      }
      if (Obj instanceof Nodes.Value) {
        if (isAssignment && !(Obj.unwrap.unwrap instanceof Nodes.Identifier)) {
          (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
            message: 'Invalid left-hand assignment reference.',
            location: Obj.loc
          });
        }
        it += `...` + Obj.parse({
          $such,
          that,
          scope,
          vars,
          varExistent,
          constants,
          isAssignment,
          isValue: true,
          tabs: tabs + 1
        });
      } else if (Obj instanceof Nodes.Function) {
        test = x = true;
        it += new Nodes.Value("Function", Obj).parse({
          tabs: tabs + 1,
          $such,
          that,
          scope,
          vars,
          varExistent,
          constants,
          isAssignment,
          isValue: true,
          isObject: true,
          func: true,
          comments,
          registry,
          lastNodeLocation: this.loc,
          metaComments
        });
      } else {
        it += LH;
        if (Obj[1]) {
          if (Obj[1].rule === "Value" && (["Function", "Code", "Class", "If", "Switch", "While", "TryBlock"].includes(Obj[1][1].rule) || Obj[1][1].rule === "Assignable" && ["Object", "Array"].includes(Obj[1][1][1].rule))) {
            x = !isParam && true;
          }
          RH = Obj[1].parse({
            that,
            $such,
            scope,
            addSemicolon: [],
            vars,
            varExistent,
            constants,
            prevLine,
            isValue: true,
            isAssigned: true,
            isObjProperty: true,
            isAssignment,
            tabs: tabs + 1,
            comments: childComments,
            lastNodeLocation,
            registry,
            isStatement,
            ID,
            metaComments,
            metaQueue
          });
          it += (Obj instanceof Nodes.Assignment ? " = " : ": ") + RH;
        } else {
          if (registry.isELSON) {
            this.throwSyntaxError('Value expected', Obj[2][0]);
          }
          if (Obj[3]) {
            it = `...${it}`;
          }
          ID.push([LH, Obj[2][0]]);
          Id = LH;
        }
      }
      if (test) {
        x = true;
        it = "\n" + tab(registry.tabSize, tabs + 1) + it;
      } else if (x) {
        it = "\n" + tab(registry.tabSize, tabs + 1) + it;
      }
      if (matchedComments.length) {
        for (let comment of matchedComments) {
          if (registry[comment.id]) continue;
          cO = parseComment(comment, tabs, true, registry).trim();
          Assignments.slice(-1)[0][1] += '\n' + tab(registry.tabSize, tabs + 1) + cO;
          registry[comment.id] = true;
          x = true;
        }
      }
      if (metaQueue.length) {
        for (let metaComment of metaQueue) {
          if (registry[metaComment.id]) continue;
          let mc = '\n' + tab(registry.tabSize, tabs + 1) + parseComment(metaComment, tabs, undefined, registry);
          if (Assignments.length === 0) {
            BeforeComments += mc;
          } else Assignments.slice(-1)[0][1] += mc;
          registry[metaComment.id] = true;
          x = true;
        }
      }
      lastNode = Obj[2] && Obj[2][1] || Obj.loc;
      Assignments.push([it, ""]);
      if (Id !== undefined) {
        if (!typeMatch) {
          typeMatch = getDataOfMetaComments({
            metaComments,
            ID: Id,
            tabs,
            loc: this.loc,
            registry
          });
        } else {
          attachDescriptions(metaComments, [typeMatch], tabs, registry);
        }
        if (typeMatch) {
          typeData.push({
            ID: Id,
            kind: 'Property',
            ...typeMatch
          });
        }
      }
    }
    if (Assignments.length) {
      let AfterComments = "";
      for (let comment of comments.filter(c => c.loc.first_line >= lastNode.last_line)) {
        if (registry[comment.id]) continue;
        let commentOutput = parseComment(comment, tabs + 1, true, registry);
        AfterComments += commentOutput;
        x = true;
        registry[comment.id] = true;
      }
      Assignments = Assignments.map(([a, b], i) => a === "jump" ? (x = true) && b : a + (i === Assignments.length - 1 ? "" : ",") + b + (i == Assignments.length - 1 ? !x ? " " : "" : " ")).join("");
      if (x) output += `\n${tab(registry.tabSize, tabs + 1)}${(BeforeComments + Assignments + AfterComments).trim()}\n${tab(registry.tabSize, tabs)}`;else output += " " + BeforeComments + Assignments + AfterComments;
    }
    output += "}";
    if (3 === output.length) output = '{}';
    output = output.replace(/\n \}$/, '\n}');
    return output;
  }
};
Nodes.Operation = class Operation extends Base {
  parse({
    vars,
    varExistent,
    that,
    $such = [],
    scope,
    constants,
    prevLine,
    isValue,
    isCompare,
    tabs = 0,
    lineReturns,
    isCondition,
    inverse,
    addSemicolon,
    func,
    scopedParams,
    comments = [],
    lastNodeLocation,
    registry = {},
    isUnless,
    FiresSuper,
    FiresAwait = [],
    FiresYield = [],
    assignRes
  } = {}) {
    let output = "";
    let Operation = this.contents,
      {
        rule
      } = this;
    switch (rule) {
      case "DO Expression":
      case "@ Value":
        {
          let Soaks = [];
          let val = Operation[0].parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            prevLine,
            isValue: true,
            isInvoked: true,
            tabs,
            isCondition,
            func,
            scopedParams,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresAwait,
            FiresYield,
            FiresSoak: Soaks,
            isOperation: true
          });
          if (Soaks.length) {
            val = loadSoaks(val, {
              tabs,
              scope,
              vars,
              prevLine,
              Soaks,
              registry,
              loc: this.loc
            });
          }
          output += val + "()";
          break;
        }
        ;
      case "AWAIT Expression":
      case "AWAIT INDENT Expression OUTDENT":
        {
          FiresAwait.push({
            ...Operation.loc,
            last_column: Operation.loc.first_column + 5,
            last_line: Operation.loc.first_line
          });
          output += "await ";
          output += Operation[0].parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            prevLine,
            isValue: true,
            isInvoked: true,
            tabs,
            isCondition,
            func,
            scopedParams,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresYield
          });
          break;
        }
        ;
      case "YIELD Expression":
      case "YIELD INDENT Expression OUTDENT":
        {
          FiresYield.push({
            ...this.loc,
            last_line: this.loc.first_line,
            last_column: this.loc.first_column + 5
          });
          output += "yield ";
          output += Operation[0].parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            prevLine,
            isValue: true,
            isInvoked: true,
            tabs,
            isCondition,
            func,
            scopedParams,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresYield
          });
          break;
        }
        ;
      case "WHETHER Expression":
      case "TYPEOF Expression":
      case "VOID Expression":
      case "VOID INDENT Expression OUTDENT":
        {
          if (rule.split(' ')[0] == "WHETHER" && !isCompare) output += "!!";
          if (rule.split(' ')[0] == "TYPEOF") output += "typeof ";
          if (rule.split(' ')[0] == "VOID") output += "void ";
          Operation = Operation[0];
          output += Operation.parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            prevLine,
            isValue: true,
            isOperation: true,
            tabs,
            isCondition,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresAwait,
            FiresYield
          });
          break;
        }
        ;
      case "Expression INCLUDES Expression":
        {
          output += Operation[0].parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            prevLine,
            isValue: true,
            isOperation: true,
            isInvoked: true,
            tabs,
            lineReturns,
            isCondition,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresAwait,
            FiresYield
          });
          output += `.includes(${Operation[1].parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            prevLine,
            isValue: true,
            isOperation: true,
            tabs,
            lineReturns,
            isCondition,
            isParam: true,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresAwait,
            FiresYield
          })})`;
          break;
        }
        ;
      case "MathPrefix Expression":
      case "Expression MathPostfix":
        {
          let Soaks = [],
            operand;
          output += Operation.map(E => {
            if (E instanceof Nodes.Expression) {
              return E.parse({
                that,
                $such,
                scope,
                vars,
                varExistent,
                constants,
                prevLine,
                isValue: true,
                isOperation: true,
                tabs,
                comments,
                lastNodeLocation,
                registry,
                FiresSuper,
                FiresAwait,
                FiresYield,
                isOperation: true,
                FiresSoak: Soaks
              });
            } else {
              return operand = E[0].replace(/NOT/, "!");
            }
          }).join('');
          if (Soaks.length) {
            output = loadSoaks(output, {
              tabs,
              scope,
              vars,
              prevLine,
              Soaks,
              registry,
              loc: this.loc
            });
          }
          break;
        }
        ;
      case "Expression MATH_BIN Expression":
      case "Expression Compare Expression":
      case "Expression Logical Expression":
        {
          let Soaks = [];
          let o1 = Operation[0].parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            prevLine,
            isValue: true,
            isOperation: true,
            tabs,
            isCondition,
            isCompare: true,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresAwait,
            FiresYield,
            FiresSoak: Soaks
          });
          if (Soaks.length) {
            o1 = loadSoaks(o1, {
              tabs,
              scope,
              vars,
              prevLine,
              Soaks,
              registry,
              loc: Operation[0].loc
            });
          }
          output += o1;
          let operand = !Operation[1].operand ? Operation[1] : isUnless ? Operation[1].inverse : Operation[1].operand;
          output += " " + operand + " ";
          Soaks = [];
          let RH = Operation[2].parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            prevLine,
            isValue: true,
            isOperation: true,
            tabs,
            isCondition,
            comments,
            lastNodeLocation: Operation[0].loc,
            registry,
            isUnless: isUnless && Operation[2].unwrap && Operation[2].unwrap instanceof Nodes.Operation,
            FiresSuper,
            FiresAwait,
            FiresYield,
            FiresSoak: Soaks
          });
          if (Soaks.length) {
            RH = loadSoaks(RH, {
              tabs,
              scope,
              vars,
              prevLine,
              Soaks,
              registry,
              loc: Operation[2].loc
            });
          }
          output += RH;
          break;
        }
      case "Expression Operator Expression":
        {
          output += Operation.map(E => {
            if (!E.parse) {
              return E[0].replace("PLUS", "+").replace("DIVISION", '/');
            } else {
              let Soaks = [];
              let o = E.parse({
                that,
                $such,
                scope,
                vars,
                varExistent,
                constants,
                prevLine,
                isValue: true,
                isOperation: true,
                tabs,
                comments,
                lastNodeLocation,
                registry,
                FiresSuper,
                FiresAwait,
                FiresYield,
                FiresSoak: Soaks
              });
              if (Soaks.length) {
                o = loadSoaks(o, {
                  tabs,
                  scope,
                  vars,
                  prevLine,
                  Soaks,
                  registry,
                  loc: E.loc
                });
              }
              return o;
            }
          }).join(' ');
          break;
        }
        ;
      case "Expression EXISTS":
      case "Expression SYMBOL_EXISTS":
        {
          let isWordy = Operation[0].rule === "Value" && Operation[0][1][0] === "Assignable" && Operation[0][1][1].rule === "Identifier",
            content = Operation[0].parse({
              that,
              $such,
              scope,
              vars,
              varExistent,
              constants,
              prevLine,
              isValue: true,
              isOperation: true,
              tabs,
              comments,
              lastNodeLocation,
              registry,
              FiresSuper,
              FiresAwait,
              FiresYield
            }),
            operand = isUnless ? "===" : "!==";
          if (!isWordy) {
            let refVar = Letter(scope, 'r');
            vars.push(refVar);
            scope.push(refVar);
            $such[0] = refVar;
            output += `(${refVar} = ${content}) && typeof ${refVar} ${operand} "undefined"`;
          } else {
            output += `typeof ${content} ${operand} "undefined"`;
          }
          break;
        }
        ;
      case "Multicondition":
      case "Expression Multicheck":
        {
          let [Exp, [Combination, Clauses]] = Operation;
          let Content = Exp;
          let isWordy = Exp === null ? true : Exp.rule === "Value" && Exp[1][0] === "Assignable" && Exp[1][1].rule === "Identifier",
            checking;
          if (!isWordy) {
            let refVar = Letter(scope, 'r');
            vars.push(refVar);
            scope.push(refVar);
            $such[0] = refVar;
            checking = refVar;
            let content = Content.parse({
              that,
              $such,
              scope,
              vars,
              varExistent,
              constants,
              prevLine,
              isValue: true,
              isOperation: true,
              tabs,
              comments,
              lastNodeLocation,
              registry,
              FiresSuper,
              FiresAwait,
              FiresYield
            });
            prevLine.push(`${registry.sources && registry.sources.add(Operation.loc) || ''}${refVar} = ${content};`);
          } else if (Content !== null) {
            checking = () => {
              return Content.parse({
                that,
                $such,
                scope,
                vars,
                varExistent,
                constants,
                prevLine,
                isValue: true,
                isOperation: true,
                tabs,
                comments,
                lastNodeLocation,
                registry,
                FiresSuper,
                FiresAwait,
                FiresYield
              });
            };
          }
          let ParsedClauses = [];
          for (let Cls of Clauses.contents) {
            let final = (Cls.contents.length > 1 ? '(' : '') + Cls.contents.map(Clause => {
              let [Exp, Operator] = Clause;
              if (Operator && Content === null) {
                (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
                  message: 'Unexpected ' + Operator.operand,
                  location: Operator.loc
                });
              }
              let def = new Nodes.Compare('===').setLoc(this.loc);
              let ss = Operator && Operator.operand || def.operand;
              Operator = Operator || def;
              Operator = isUnless ? Operator.inverse : Operator.operand;
              let pushed = Exp.parse({
                that,
                $such,
                scope,
                vars,
                varExistent,
                constants,
                prevLine,
                isValue: true,
                isOperation: true,
                isCompare: true,
                tabs,
                comments,
                lastNodeLocation,
                registry,
                FiresSuper,
                FiresAwait,
                FiresYield
              });
              if (typeof checking === "function") {
                pushed = `(${checking()} ${Operator} ${pushed})`;
              } else if (typeof checking === "string") {
                pushed = `(${checking} ${Operator} ${pushed})`;
              } else {
                pushed = `(${pushed})`;
              }
              if (isUnless && (!ss || Operator === ss)) {
                pushed = `!${pushed}`;
              }
              return pushed;
            }).join(' && ') + (Cls.contents.length > 1 ? ')' : '');
            ParsedClauses.push(final);
          }
          output += ParsedClauses.join(isUnless ? ' && ' : ' || ');
          break;
        }
        ;
      case "Expression CHAIN Expression":
      case "Expression CHAIN Block":
        {
          let Soaks = [];
          if (Operation[1] instanceof Nodes.Block) {
            let refV = Reference(scope, false, 'ref'),
              ccode = "",
              prevL = [];
            scope.push(refV);
            vars.push(refV);
            ccode += `${refV} = ${Operation[0].parse({
              that,
              $such,
              scope,
              vars,
              varExistent,
              constants,
              prevLine: prevL,
              isValue: true,
              isAssigned: true,
              tabs,
              comments,
              lastNodeLocation,
              registry,
              FiresSuper,
              FiresAwait,
              FiresYield
            })};`;
            if (prevL.length) {
              ccode = prevL.join(`\n${tab(registry.tabSize, tabs + 1)}`) + `\n${tab(registry.tabSize, tabs + 1)}` + ccode;
            }
            let Body = Operation[1].unwrap;
            Body.unwrap.unshift(new Nodes.Line("SimpleCode", [ccode]));
            output += Body.parse({
              constants,
              that,
              $such: [refV],
              scope: scope.concat(refV),
              isValue: true,
              prevLine,
              tabs,
              callSelf: true,
              vars,
              varExistent,
              comments,
              lastNodeLocation,
              registry
            });
          } else {
            output += Object.assign(new Nodes.Invocation(null, Operation[1], new Base(null, new Base(null, Operation[0]).setLoc(this.loc)).setLoc(this.loc)).setLoc(this.loc), {
              soak: !!Operation[2]
            }).parse({
              that,
              $such,
              scope,
              vars,
              varExistent,
              constants,
              prevLine,
              isValue: true,
              isOperation: true,
              tabs,
              isCondition,
              isCompare: true,
              comments,
              lastNodeLocation,
              registry,
              FiresSuper,
              FiresAwait,
              FiresYield,
              FiresSoaks: Soaks
            });
          }
          break;
        }
    }
    ;
    return output;
  }
  get canInverse() {
    switch (this.rule) {
      case "Expression Compare Expression":
      case "Multicondition":
      case "Expression Multicheck":
        return true;
      default:
        return false;
    }
  }
};
Nodes.ParamIdentifier = class ParamIdentifier extends Base {};
Nodes.ParamList = class ParamList extends Base {
  addParam(Param) {
    this.push(Param);
    return this.contents;
  }
  addParams(Params) {
    for (let Param of Params) {
      this.push(Param);
    }
    return this.contents;
  }
};
Nodes.ParamObject = class ParamObject extends Base {
  defaults(Expression) {
    this[1].defaults = Expression;
    return this;
  }
};
Nodes.ParamPropObj = class ParamPropObj extends Base {};
Nodes.Regex = class Regex extends Base {
  parse(opts) {
    switch (this.rule) {
      case "RegexWithInterpolations":
        return this.parseWithInterpolations(opts);
      case "REGEX":
        return this[1].replace(/\n/g, '\\n');
    }
  }
  parseWithInterpolations(opts) {
    let fragments = "",
      flags = this.unwrap[2];
    for (const Interpolation of this.unwrap[1].contents) {
      fragments += Interpolation.parse(opts);
    }
    return `new RegExp(\`${flags ? fragments.slice(0, -1) : fragments}${flags ? `\`, '${flags}'` : "`"})`;
  }
};
Nodes.RegexInterpolation = class Interpolation extends Base {
  parse(opts) {
    switch (this.rule) {
      case "Regex":
        {
          return this.unwrap.parse(opts);
        }
        ;
      default:
        {
          let int = this.unwrap.parse({
            ...opts,
            addSemicolon: [],
            isValue: true
          });
          return `\${${int}}`;
        }
    }
  }
};
Nodes.Root = class Root extends Base {
  parse(opts = {}) {
    let output = "";
    const Body = this.unwrap;
    if (opts.registry && opts.registry.isELSON && Body.unwrap.length > 1) {
      Body[1] = [new Nodes.Line('Expression', Nodes.Array.from(Body)).setLoc(Body.loc)];
    }
    if (Body !== 'EMPTY') output += Body.parse({
      ...opts,
      tabs: opts.wrapSafe ? 1 : 0,
      top: 1
    });else output += "// You should write some code below!";
    if (opts.wrapSafe) {
      output = `(function() {\n${output}\n})()`;
    }
    return output;
  }
};
Nodes.Statement = class Statement extends Base {
  parse({
    addSemicolon = [],
    construct,
    constants,
    vars,
    varExistent,
    that,
    $such,
    scope = [],
    isValue,
    isInvoked,
    isOperation,
    isLine,
    prevLine,
    tabs = 0,
    isCondition,
    isDirect,
    isClass,
    isCompare,
    isAssignment,
    ID,
    isParam,
    nl,
    func,
    scopedParams,
    comments = [],
    lastNodeLocation,
    registry = {},
    isParenthetical,
    FiresSuper,
    FiresAwait,
    FiresYield,
    afterParse = [],
    metaComments = []
  } = {}) {
    var Expression = this.unwrap;
    let output = "";
    if (isParenthetical) {
      this.throwSyntaxError('Cannot use statements in this context.');
    }
    if (registry.sources) output += registry.sources.add(this.loc);
    switch (this.rule) {
      case "Type":
        {
          if (registry.omitTypeScript) return "";
          registry.isTypeScript = true;
          let build = [],
            [member, sentences] = Expression[1].contents;
          member = member.parse();
          let chunk = `type ${member} = `;
          if (Expression[1].rule.includes('OUTDENT')) {
            tabs++;
            chunk += `\n${tab(registry.tabSize, tabs)}`;
          }
          chunk += sentences.parse({
            tabs,
            addSemicolon,
            that,
            $such,
            scope,
            constants,
            vars,
            varExistent,
            prevLine,
            isClass,
            isLine,
            func,
            scopedParams,
            nl,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresAwait,
            isValue: true
          });
          output += chunk;
          break;
        }
        ;
      case "Interface":
        {
          if (registry.omitTypeScript) return "";
          let [iName, iTags, iBody, iExtends] = Expression.contents;
          output += `interface ${iName.parse({
            registry
          })}`;
          if (iTags[0]) {
            output += `<${iTags.unwrap.parse({
              registry
            })}>`;
          }
          if (iExtends && iExtends[0]) {
            let Extends = iExtends.contents;
            output += ` extends ${Extends.map(e => {
              let [eName, eTags] = e.contents;
              return eName.parse({
                registry
              }) + (eTags ? `<${eTags.parse({
                registry
              })}>` : '');
            }).join(', ')}`;
          }
          let oBody = [];
          for (let iProp of iBody.unwrap) {
            let optional,
              [propName, propValue, extra = {}] = iProp.contents;
            if (propValue && !propValue.parse && propValue.nodes) {
              if (propValue.optional) optional = true;
              propValue = propValue.nodes;
            }
            let res = "";
            if (extra.readonly) res += 'readonly ';
            if (extra.getter) res += 'get ';
            if (extra.setter) res += 'set ';
            if (propName) {
              if (!extra.indexed) {
                res += `${propName.parse({
                  registry
                })}`;
              } else {
                res += `[${propName.parse({
                  registry
                })}${propName.loc.type ? ': ' + propName.loc.type.nodes.parse({
                  registry
                }) : ''}]`;
              }
            }
            if (extra.params) {
              let {
                params
              } = extra;
              let Par = "(",
                ParsedParams = [];
              let Params = params.unwrap instanceof Nodes.ParamList ? params.unwrap.contents : [];
              for (let Parameter of Params) {
                ParsedParams.push(ParseParam(Parameter.unwrap, {
                  registry
                }));
              }
              Par += ParsedParams.join(', ') + ")";
              res += Par;
            }
            if (propValue) {
              if (!optional && propValue.optional) optional = true;
              propValue.indented = iProp.tokens && iProp.tokens.INDENT && iProp.tokens.INDENT.length;
              res += `${optional && !extra.indexed && !extra.getter && !extra.setter && !extra.params ? '?' : ''}: ${propValue.parse({
                registry
              })}`;
            }
            res += ";";
            oBody.push(res);
          }
          oBody = oBody.join(`\n${tab(registry.tabSize, tabs + 1)}`);
          if (oBody) output += ` {\n${tab(registry.tabSize, tabs + 1)}${oBody}\n${tab(registry.tabSize, tabs)}}`;else output += ` {}`;
          break;
        }
        ;
      case "Return":
        {
          output += "return";
          if (Expression.rule === "RETURN INDENT Body OUTDENT") {
            output += " " + Expression.unwrap.parse({
              scope,
              constants,
              vars,
              varExistent,
              prevLine,
              tabs,
              scopedParams,
              nl,
              comments,
              lastNodeLocation,
              registry,
              callSelf: true
            });
          } else if (Expression.unwrap) {
            output += " " + Expression.unwrap.parse({
              addSemicolon,
              that,
              $such,
              scope,
              constants,
              vars,
              varExistent,
              prevLine,
              tabs,
              isClass,
              isLine,
              func,
              scopedParams,
              nl,
              comments,
              lastNodeLocation,
              registry,
              FiresSuper,
              FiresAwait,
              isValue: true
            });
          }
          break;
        }
        ;
      case "BREAK Identifier":
      case "CONTINUE Identifier":
        {
          output += this.rule.split(' ')[0].toLowerCase() + ' ' + Expression.parse({
            registry
          });
          break;
        }
        ;
      case "Import":
        {
          let {
            _imports: ImportList,
            _from: Module,
            _default: prevDefault
          } = this.unwraps(2);
          let isAll = ImportList && ImportList._isAll;
          ImportList = ImportList && ImportList.unwrap;
          output += "import ";
          if (prevDefault) output += `${prevDefault.parse({
            registry
          })}`;
          if (isAll) output += (output.length !== 7 ? ', ' : '') + "* as ";
          if (ImportList && ImportList instanceof Nodes.Identifier) {
            if (isAll) {
              output += ImportList.parse ? ImportList.parse({
                registry
              }) : ImportList[0].parse({
                registry
              });
            } else {
              output += `, { ${ImportList.parse ? ImportList.parse({
                registry
              }) : ImportList[0].parse({
                registry
              })} }`;
            }
          } else if (ImportList) {
            if (ImportList.contents.findIndex(([, n]) => !!n) === -1 || ImportList[0].length <= 3) {
              output += `, { `;
              output += ImportList.contents.map(([iname, idest, iloc], i, r) => {
                let str = iname.parse ? iname.parse({
                  registry
                }) : iname;
                if (idest) str += " as " + idest.parse({
                  registry
                });
                if (i !== r.length - 1) {
                  str += ", ";
                }
                return str;
              }).join('');
              output += ` }`;
            } else {
              output += `, {\n${tab(registry.tabSize, tabs + 1)}`;
              output += ImportList.contents.map(([iname, idest, iloc], i, r) => {
                let str = iname.parse ? iname.parse({
                  registry
                }) : iname;
                if (idest) str += " as " + idest.parse({
                  registry
                });
                if (i !== r.length - 1) {
                  str += ", ";
                  if (idest) str += "\n";
                }
                return str;
              }).join('');
              output += `\n${tab(registry.tabSize, tabs)}}`;
            }
          }
          output += " from " + Module;
          break;
        }
        ;
      case "Export":
        {
          let {
            list,
            declarations,
            defaults,
            exportable
          } = this.unwrap.unwrap;
          if (declarations) {
            output += "export " + new Nodes.Statement('Declare', declarations).setLoc(declarations.loc).parse({
              ...arguments[0],
              addSemicolon: []
            });
          } else if (defaults) {
            output += "export default " + defaults.parse({
              addSemicolon: [],
              that,
              $such,
              scope,
              constants,
              vars,
              varExistent,
              prevLine,
              tabs,
              comments,
              registry,
              FiresSuper,
              FiresAwait,
              FiresYield,
              ID,
              isStatement: true,
              isValue: true
            });
          } else if (list) {
            list;
            output += "export {" + `\n${tab(registry.tabSize, tabs + 1)}${list.unwrap.contents.map(l => {
              if (l[1]) {
                return (l[0].parse ? l[0].parse({
                  registry
                }) : l[0]) + ' as ' + l[1].parse({
                  registry
                });
              } else if (l[2]) {
                return l[0].parse({
                  registry
                }) + ' as default';
              } else {
                return l[0].parse ? l[0].parse({
                  registry
                }) : l[0];
              }
            }).join(',\n' + tab(registry.tabSize, tabs + 1))}\n${tab(registry.tabSize, tabs)}` + "}";
          } else if (exportable) {
            output += "export " + exportable.parse({
              addSemicolon: [],
              that,
              $such,
              scope,
              constants,
              vars,
              varExistent,
              prevLine,
              tabs,
              comments,
              registry,
              FiresSuper,
              FiresAwait,
              FiresYield,
              ID,
              isStatement: true,
              isValue: true,
              isExport: true
            });
          }
          break;
        }
        ;
      case "Declare":
        {
          let [{
            keyword,
            statements,
            indented
          }, locs] = this.unwrap.contents;
          output += keyword[0].toLowerCase() + ' ';
          let originalTabs = tabs;
          if (statements.contents.filter(statement => /boolean|undefined/.test(typeof statement)).findIndex(statement => statement === false || statement === undefined) > -1) {
            indented = true;
          }
          if (indented) {
            tabs++;
          }
          let Statements = "",
            n = false,
            LastLoc = lastNodeLocation,
            outerMeta = metaComments;
          statements.contents.forEach((statement, i, r) => {
            var metaComments = outerMeta;
            if (statement && statement.loc) {
              var {
                metaComments: mC
              } = matchComments(LastLoc, comments, statement.loc);
              metaComments = [...outerMeta, ...mC];
            }
            let self = statement,
              isLast = i === r.length - 1;
            if (/boolean|undefined/.test(typeof self)) {
              if (!self) {
                Statements += "\n" + tab(registry.tabSize, ++tabs);
              }
              return;
            } else if (self instanceof Nodes.Assignable && self.unwrap instanceof Nodes.Identifier) {
              if (keyword[0] === "CONST") self.unwrap.throwSyntaxError("Missing initializer in constant declaration");
              varExistent.push(self.parse());
              var that = self.parse({
                registry
              });
              if (self.loc.type && registry.isTypeScript && !registry.omitTypeScript) {
                that += `: ${self.loc.type.nodes.parse({
                  registry
                })}`;
              } else if (self.loc.type) {
                var prevl = [];
                addMetaDataToPrevLine({
                  typeData: [{
                    ID: self.parse({}),
                    ...self.loc.type
                  }],
                  prevLine: prevl,
                  metaComments,
                  tabs,
                  registry
                });
                prevl[prevl.length - 1] = (prevl[prevl.length - 1] !== undefined ? prevl[prevl.length - 1] + `\n${tab(registry.tabSize, originalTabs)}` : "") + `${keyword[0].toLowerCase() + ' '}${that};`;
                prevLine.push(...prevl.map(l => untab(registry.tabSize, tabs, l, originalTabs)));
                Statements = Statements.replace(/,\s*(\n\s+)?$/, '') + (!isLast ? ", " : "");
                return;
              }
              Statements += that;
            } else if (self instanceof Nodes.Assignable && !(self.unwrap instanceof Nodes.Identifier)) {
              self.unwrap.throwSyntaxError('Expected identifier, got ' + self[0].toLowerCase());
            } else {
              let ID = [],
                prevL = [],
                hasTypes = [];
              let them = new Nodes.Assign("Assignment", self).setLoc(self.loc).parse({
                constant: keyword[0] === "CONST",
                addSemicolon: [],
                that,
                $such,
                scope,
                constants,
                vars,
                varExistent,
                prevLine: prevL,
                tabs: tabs + +n,
                comments,
                metaComments,
                registry,
                FiresSuper,
                FiresAwait,
                FiresYield,
                ID,
                isStatement: true,
                isValue: true,
                hasTypes
              });
              for (let [id] of ID) {
                varExistent.push(id.toString());
              }
              if (hasTypes.length && registry.omitTypeScript) {
                prevL[prevL.length - 1] = (prevL[prevL.length - 1] !== undefined ? prevL[prevL.length - 1] + `\n${tab(registry.tabSize, originalTabs)}` : "") + `${keyword[0].toLowerCase() + ' '}${them};`;
                prevLine.push(...prevL.map(l => untab(registry.tabSize, tabs, l, originalTabs)));
                Statements = Statements.replace(/,\s*(\n\s+)?$/, '') + (!isLast ? ", " : "");
                return;
              } else {
                them = `${prevL.length ? prevL.join('\n') + `\n${tab(registry.tabSize, tabs)}` : ''}${them}`;
                Statements = Statements.replace(/\s+$/, '\n' + tab(registry.tabSize, tabs)) + them;
              }
            }
            if (!isLast) Statements += ", ";
          });
          if (!Statements.length) {
            output = "";
            addSemicolon.pop();
          } else output += indented ? '\n' + tab(registry.tabSize, tabs) + Statements : Statements;
          break;
        }
        ;
      case "THROW Expression":
      case "THROW INDENT Expression OUTDENT":
        {
          output += `throw ${this.unwrap.parse({
            addSemicolon,
            that,
            $such,
            scope,
            constants,
            vars,
            varExistent,
            prevLine,
            tabs,
            isClass,
            isLine,
            func,
            scopedParams,
            nl,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresAwait,
            FiresYield
          })}`;
          break;
        }
        ;
      case "DELETE Expression":
        {
          output += `delete ${this.unwrap.parse({
            addSemicolon,
            that,
            $such,
            scope,
            constants,
            vars,
            varExistent,
            prevLine,
            tabs,
            isClass,
            isLine,
            func,
            scopedParams,
            nl,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresAwait,
            FiresYield
          })}`;
          break;
        }
        ;
      default:
        {
          output += this.rule.toLowerCase();
          break;
        }
    }
    if (addSemicolon.length) output += ";";
    return output;
  }
};
Nodes.String = class String extends Base {
  parse(opts) {
    switch (this.rule) {
      case "StringWithInterpolations":
        return this.parseWithInterpolations(opts);
      case "STRING":
        if (opts.registry && opts.registry.isELSON) this[1] = this[1].replace(/^['`]/, '"').replace(/['`]$/, '"');
        if (opts.forceBacktick) this[1] = this[1].replace(/^['"]/, '`').replace(/['"]$/, '`');
        return this[1].replace(/\n/g, opts.inJSX ? '\n' : '\\n');
    }
  }
  parseWithInterpolations(opts) {
    let fragments = "";
    for (const Interpolation of this.unwrap[1].contents) {
      fragments += Interpolation.parse({
        ...opts,
        lineReturns: false
      });
    }
    return `\`${fragments}\``;
  }
};
Nodes.Switch = class Switch extends Base {
  parse({
    that,
    $such,
    assignRes,
    lineReturns,
    scope,
    vars,
    varExistent,
    constants,
    registry = {},
    FiresSuper,
    prevLine,
    tabs
  }) {
    let [Expression, Cases] = this.contents,
      refVar,
      output = "",
      hasCondition;
    if (Expression) {
      refVar = Letter(scope, 'j');
      vars.push(refVar);
      scope.push(refVar);
      prevLine.push(`${registry.sources ? registry.sources.add(Expression.loc) : ''}${refVar} = ${Expression.parse({
        that,
        $such,
        scope,
        addSemicolon: [],
        vars,
        varExistent,
        constants,
        registry,
        FiresSuper,
        prevLine,
        isValue: true,
        isAssigned: true,
        isCondition: true
      })};`);
      hasCondition = true;
    }
    output += `switch (true) {\n` + tab(registry.tabSize, tabs);
    let i = 0;
    for (let [rule, cases, Body] of Cases.contents) {
      let whens;
      if (rule.includes('Multicondition')) cases = cases.unwrap.unwrap;
      let Clauses = cases ? cases.contents : false;
      if (rule === "BREAK") {
        output += "break";
        if (i !== Cases.contents.length - 1) {
          output += `;\n${tab(registry.tabSize, tabs)}`;
        }
        i++;
        continue;
      } else if (!Clauses) {
        whens = `default:`;
      } else {
        whens = Clauses.map(cls => {
          let output = 'case ';
          output += (hasCondition ? '' : '!!') + (cls.length > 1 ? '(' : '') + cls.slice(+/Multicondition|POSTCASE/.test(rule)).map(cl => {
            let [exp, compare] = cl;
            if (compare && !hasCondition) {
              this.throwSyntaxError('Unexpected ' + compare.operand, compare.loc);
            }
            let $$such = [refVar];
            exp = exp.parse({
              that,
              $such: hasCondition ? $$such : $such,
              scope,
              vars,
              varExistent,
              constants,
              registry,
              FiresSuper,
              prevLine,
              tabs,
              isValue: true,
              isCondition: hasCondition,
              addSemicolon: []
            });
            return hasCondition ? $$such.active ? exp : `${refVar} ${compare ? compare.operand : '==='} ${exp}` : exp;
          }).join(`) && ${hasCondition ? '' : '!!'}(`) + (cls.length > 1 ? ')' : '');
          return output + ':';
        }).join(`\n${tab(registry.tabSize, tabs)}`);
      }
      output += whens;
      output += ` {\n${tab(registry.tabSize, tabs + 1)}` + Body.parse({
        that,
        $such: hasCondition ? [refVar] : $such,
        assignRes,
        lineReturns,
        scope,
        vars,
        varExistent,
        constants,
        registry,
        FiresSuper,
        prevLine,
        tabs: tabs + 1,
        isChildren: true
      }) + (Body.rule === null ? `\n${tab(registry.tabSize, tabs + 1)}break;` : '') + `\n${tab(registry.tabSize, tabs)}}`;
      if (i !== Cases.contents.length - 1) {
        output += `;\n${tab(registry.tabSize, tabs)}`;
      }
      i++;
    }
    output += `\n${tab(registry.tabSize, tabs - 1)}}`;
    return output;
  }
};
Nodes.Value = class Value extends Base {
  parse({
    that,
    $such,
    scope,
    addSemicolon = [],
    vars,
    varExistent,
    constants,
    prevLine,
    isCondition,
    isValue,
    isLine,
    tabs = 0,
    lineReturns,
    wrap,
    isClass,
    isAssignment,
    ID,
    isParam,
    func,
    scopedParams,
    isCompare,
    isStatement,
    inverse,
    isDirect,
    isAssigned,
    comments = [],
    lastNodeLocation,
    registry = {},
    FiresSuper = [],
    FiresAwait = [],
    FiresYield = [],
    isObject,
    FiresSoak,
    isOperation,
    isInvoked,
    isNarrow,
    isObjProperty,
    metaComments = [],
    metaQueue,
    NoPrint = false
  } = {}) {
    var output = "";
    let {
        rule
      } = this,
      Value = this.unwrap;
    switch (rule) {
      case 'Assignable':
        {
          if (isValue && !isAssignment && !isParam && !isAssigned && !isCompare && !isOperation && !registry.isELSON && Value.rule === "Object") wrap = true;
          output += Value.parse({
            that,
            $such,
            scope,
            addSemicolon,
            vars,
            varExistent,
            constants,
            lineReturns,
            prevLine,
            isCondition,
            isValue,
            tabs,
            wrap,
            isClass,
            isLine,
            isAssignment,
            lineReturns,
            ID,
            func,
            scopedParams,
            comments,
            lastNodeLocation,
            registry,
            isParam,
            FiresSoak,
            isOperation,
            isInvoked,
            isCondition,
            isStatement,
            isNarrow,
            isObjProperty
          });
          break;
        }
        ;
      case 'TypeGeneric':
        {
          break;
        }
        ;
      case 'Literal':
        {
          return Value.parse({
            that,
            $such,
            scope,
            addSemicolon,
            vars,
            varExistent,
            constants,
            lineReturns,
            prevLine,
            isCondition,
            isValue,
            tabs,
            wrap,
            isClass,
            isLine,
            isAssignment,
            lineReturns,
            func,
            scopedParams,
            comments,
            lastNodeLocation,
            registry,
            FiresSoak
          });
          break;
        }
        ;
      case 'Module':
        {
          output += Value.parse({
            registry
          });
          break;
        }
        ;
      case 'Parenthetical':
        {
          wrap = true;
          Value = Value.unwrap;
          if (Value instanceof Nodes.Expression) {
            output += Value.parse({
              vars,
              varExistent,
              that,
              $such,
              scope,
              constants,
              prevLine,
              isValue: true,
              isCompare,
              tabs,
              isCondition,
              inverse,
              addSemicolon: [],
              comments,
              lastNodeLocation,
              registry,
              FiresSoak,
              isInvoked
            });
            if (isCondition && isDirect) wrap = false;else isValue = true;
          } else {
            output += Value.parse({
              vars,
              varExistent,
              that,
              $such,
              scope,
              constants,
              prevLine,
              isValue: true,
              isCompare,
              tabs,
              isCondition,
              inverse,
              addSemicolon: [],
              comments,
              lastNodeLocation,
              registry,
              isChildren: true,
              isParenthetical: true,
              FiresSoak,
              isInvoked
            });
            if (isCondition && isDirect) wrap = false;else isValue = true;
          }
          break;
        }
        ;
      case "Invocation":
        {
          output += Value.parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            prevLine,
            isValue,
            tabs,
            func,
            scopedParams,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            FiresSoak,
            isInvoked,
            isParam,
            isObjProperty,
            NoPrint
          });
          break;
        }
        ;
      case "Function":
        {
          addSemicolon.pop();
          if (isInvoked) wrap = true;
          output += Value.parse({
            that,
            $such,
            scope,
            vars,
            varExistent,
            constants,
            prevLine,
            isValue,
            tabs,
            func,
            scopedParams,
            comments,
            lastNodeLocation,
            registry,
            FiresSuper,
            isInvoked,
            isParam,
            isClass,
            isObject,
            lineReturns,
            isLine,
            metaComments,
            metaQueue
          });
          break;
        }
        ;
      case "This":
        {
          output = that && that[0] || "this";
          if (registry.sources) {
            output = registry.sources.add(Value.loc) + output;
          }
          return output;
          break;
        }
        ;
      case "SUCH":
        {
          if (!$such || !$such.length) {
            if (func && scopedParams && !scopedParams.generated && !scopedParams.length) {
              $such = [Letter(scope, 'p')];
              scopedParams.push($such[0]);
              return (registry.sources ? registry.sources.add(this.loc, 'such') : '') + $such[0];
            } else if (func && scopedParams && !scopedParams.generated && !!scopedParams.length) {
              $such = [scopedParams[0]];
              return (registry.sources ? registry.sources.add(this.loc, 'such') : '') + $such[0];
            } else {
              return (registry.sources ? registry.sources.add(this.loc, 'such') : '') + (that && that[0] || "this");
            }
          } else {
            $such.active = true;
            return (registry.sources ? registry.sources.add(this.loc, 'such') : '') + $such[0];
          }
          break;
        }
        ;
      case "New":
        {
          output += Value[1].setLoc(this.loc).parse({
            vars,
            varExistent,
            isValue: true,
            constants,
            that,
            $such,
            scope,
            prevLine,
            tabs,
            func,
            scopedParams,
            isInvoked: true,
            construct: true,
            comments,
            lastNodeLocation,
            registry
          });
          break;
        }
    }
    if (isValue && wrap) {
      output = '(' + output + ')';
    }
    return output;
  }
};
Nodes.TypeObject = class TypeObject extends Base {
  parse({
    registry = {},
    tabs = 0
  } = {}) {
    let items = [],
      props = this.contents;
    for (let prop of props) {
      if (typeof prop === "number") {
        continue;
      }
      let [, name, value, opt, options = {}] = prop,
        isOptional = [];
      if (opt) isOptional.push(1);
      if (name instanceof Nodes.Identifier) {
        name = name.parse({
          registry
        });
      }
      if (options.isDynamicKey) {
        if (!options.keyType) {
          prop[1].throwSyntaxError('Missing type annotation for this name');
        }
        name = `[${name}: ${options.keyType.nodes.parse({
          registry
        })}]`;
      }
      if (!value) {
        value = 'any';
      } else {
        value = value.parse({
          isOptional,
          isChildren: true,
          registry
        });
      }
      items.push(`${registry.sources ? registry.sources.add(prop.loc) : ''}${name}${isOptional.length ? '?' : ''}: ${value}`);
    }
    return `{ ${items.join(', ')} }`;
  }
};
Nodes.TypeArray = class TypeArray extends Base {
  parse({
    registry = {}
  } = {}) {
    let items = [],
      props = this.contents;
    for (let prop of props) {
      if (typeof prop !== 'object') continue; // I will add line formatting later.
      let value = prop.parse({
        isChildren: true,
        registry
      });
      items.push((registry.sources ? registry.sources.add(prop.loc) : '') + value);
    }
    return `[ ${items.join(', ')} ]`;
  }
};
Nodes.InlineType = Nodes.TypeSentence = class TypeSentence extends Base {
  parse({
    isOptional = [],
    isChildren = false,
    registry = {},
    tabs = 0
  } = {}) {
    let sentences = this.contents,
      {
        tabSize
      } = registry,
      items = [],
      seemsLikeAligned = typeof sentences[0] === "string";
    let lastSentence,
      i = 0;
    for (let sentence of sentences) {
      i++;
      if (typeof sentence === "string") {
        if (typeof lastSentence !== 'number') {
          items.push(` ${sentence}`);
        } else {
          items.push(sentence);
        }
        lastSentence = sentence;
      } else if (typeof sentence === "number") {
        tabs += sentence;
        if (i > 1) {
          items.push(`\n${tab(registry.tabSize, tabs)}`);
        }
        lastSentence = sentence;
      } else {
        let it;
        if (sentence.rule === "TAG") {
          it = sentence[1].nodes.parse({
            isOptional,
            isChildren,
            registry
          });
          if (sentence[1].isArray) {
            it = `Array<${it}>`;
          }
          if (sentence[1].optional) {
            isOptional.push(1);
          }
        } else {
          if (sentence.unwrap.rule === "Regex") {
            this.throwSyntaxError('not a valid type', sentence.loc);
          }
          it = sentence.unwrap.parse ? sentence.unwrap.parse({
            registry
          }) : sentence.parse ? sentence.parse({
            registry,
            isOptional,
            isChildren
          }) : sentence.unwrap;
        }
        if (lastSentence !== undefined && typeof lastSentence !== 'number') {
          items.push(` ${it}`);
        } else {
          items.push(it);
        }
        lastSentence = sentence;
      }
    }
    if (isOptional.length && !isChildren && !items.includes('undefined') && !items.includes('any')) {
      items.push('|', 'undefined');
    }
    return items.join('');
  }
};
Nodes.TypeWithArguments = class TypeWithArguments extends Base {
  parse({
    isChildren,
    isOptional = [],
    registry
  }) {
    let {
        isArray,
        type,
        arguments: args
      } = this.unwrap,
      output = "";
    if (isArray) {
      let value = type instanceof Nodes.TypeSentence ? `(${type.parse({
        isChildren,
        isOptional,
        registry
      })})` : new Nodes.TypeSentence(null, type).parse({
        isChildren,
        isOptional,
        registry
      });
      return value += "[]";
    } else {
      let value = type.parse(),
        $args = args.parse({
          isChildren,
          isOptional,
          registry
        });
      return `${value}<${$args}>`;
    }
  }
};
Nodes.TypeArguments = class TypeArguments extends Base {
  parse({
    registry
  }) {
    let output = "",
      args = this.contents;
    output += args.map(arg => {
      if (arg.rule === "Identifier") {
        return arg.unwrap.parse({
          registry
        });
      }
    }).join(', ');
    return output;
  }
};
Nodes.TypeFunction = class TypeFunction extends Base {
  parse({
    registry
  }) {
    let [params, value, $new] = this.contents;
    let Par = ($new ? 'new ' : '') + "(",
      ParsedParams = [];
    let Params = params.unwrap instanceof Nodes.ParamList ? params.unwrap.contents : [];
    for (let Parameter of Params) {
      ParsedParams.push(ParseParam(Parameter.unwrap, {
        registry
      }));
    }
    Par += ParsedParams.join(', ');
    Par += ") => ";
    return Par + value.parse({
      registry
    });
  }
};
Nodes.TypeWrapped = class TypeWrapped extends Base {
  parse({
    registry,
    isChildren,
    isOptional
  }) {
    return `(${this.unwrap.parse({
      registry,
      isChildren,
      isOptional
    })})`;
  }
};
Nodes.TypeofKeyof = class TypeofKeyof extends Base {
  parse({
    registry,
    isChildren,
    isOptional
  }) {
    let [Value, Keyword] = this.contents;
    return `${Keyword} ` + Value.parse({
      registry,
      isChildren,
      isOptional
    });
  }
};
Nodes.TypeAccess = class TypeAccess extends Base {
  parse({
    registry,
    isChildren,
    isOptional
  }) {
    let [Value, Access] = this.contents;
    let ParsedAccess = Access instanceof Nodes.String ? `[${Access.parse({
      registry
    })}]` : `[${Access.parse({
      registry,
      isOptional,
      isChildren
    })}]`;
    return Value.parse({
      registry,
      isChildren,
      isOptional
    }) + ParsedAccess;
  }
};
Nodes.TypeValue = class TypeValue extends Base {
  parse({
    registry,
    isChildren,
    isOptional
  }) {
    let Value = this;
    return Value.unwrap && Value.unwrap.parse && Value.unwrap.parse({
      registry,
      isChildren,
      isOptional
    }) || Value.unwrap;
  }
};
function tab(size = 2, many = 0) {
  return " ".repeat(Math.max(2, size)).repeat(Math.max(0, many));
}
function untab(size, many, chunk, replace) {
  return chunk.replace(new RegExp(`\\n(${" ".repeat(size)}){${many},}`, 'gm'), '\n' + tab(size, replace));
}
function Reference(scope = [], underscore = false, label = "ref") {
  let count = 0,
    final;
  while (scope.includes((underscore ? "_" : "") + label + (count ? count : ""))) {
    count++;
  }
  return (underscore ? "_" : "") + (count ? label + count : label);
}
function Letter(scope = [], offset = "a") {
  let letters = "abcdefghijklmnopqrstuvwxyz";
  letters += letters.toUpperCase();
  let letter,
    count = 0;
  letters = letters.slice(letters.indexOf(offset));
  while (true) {
    for (letter of letters.split('')) {
      if (!scope.includes('_' + letter + (count ? count : ''))) {
        return '_' + letter + (count ? count : '');
      }
    }
    count++;
  }
}
function lookupExpression(Exp, Rule, direct) {
  let val = Exp,
    i = 0;
  while (val[0] !== Rule) {
    if (i == 2 && direct) return false;
    try {
      val = val[1].length === 1 && Array.isArray(val[1][0]) ? val[1][0] : val[1];
      if (val.length === 1 && Array.isArray(val[0])) val = val[0];
      i++;
      if (val.length === 0 || typeof val[0] !== "string") {
        return false;
      }
    } catch (e) {
      return false;
    }
  }
  return val && val[0] === Rule;
}
function matchComments(a = {
  first_line: 1,
  first_column: 1,
  last_line: 1,
  last_column: 1
}, comments = [], b = {
  first_line: 1,
  first_column: 1,
  last_line: 1,
  last_column: 1
}) {
  let releasedComments = [],
    metaComments = [],
    matchedComments = [...comments].filter((comment, id) => {
      let bool = 0;
      let c = comment.loc;
      if (c.last_line === b.first_line && c.last_column <= b.first_column) bool++;else if (c.last_line < b.first_line) bool++;
      if (bool === 1) {
        if (c.first_line > a.last_line) {
          bool++;
        } else if (c.first_line === a.last_line && c.first_column >= a.last_column) {
          if (a.last_line !== 1 && a.last_column !== 1) comment.appendToLastLine = true;
          bool++;
        }
      }
      if (!comment.jsdoc && bool === 2) {
        comment._id = id;
      } else {
        releasedComments.push(comment);
        if (comment.jsdoc && (bool === 2 || c.last_line === -1)) metaComments.push(comment);
        return;
      }
      return bool === 2;
    }),
    childComments = releasedComments.filter(comment => {
      let bool = 0;
      let c = comment.loc;
      // If comment starting location > current node location, increase 1 directly
      if (c.first_line > b.first_line) bool++;
      // else if comment starting location == current node location, check if comment first column > current node first column 
      else if (c.first_line === b.first_line && c.first_column > b.first_column) bool++;
      if (bool === 1) {
        if (c.last_line < b.last_line) bool++;else if (c.last_line == b.last_line && c.last_column < b.last_column) bool++;
      }
      return bool === 2;
    });
  return {
    releasedComments,
    childComments,
    matchedComments,
    metaComments
  };
}
function parseComment(comment, tabs, forceWrap = false, registry) {
  let commentOutput = "";
  if (!forceWrap && comment.inline) commentOutput += "// " + comment[1].trim();else commentOutput += "/*" + comment[1].split(/\n/g).map((c, i) => (i ? tab(registry.tabSize, tabs) : "") + c).join("\n") + "*/";
  if (!/\n +\*\/$/.test(commentOutput) && forceWrap) {
    if (!/ \*\/$/.test(commentOutput)) {
      commentOutput = commentOutput.slice(0, -2) + " */";
    }
  }
  let after = forceWrap ? tab(registry.tabSize, tabs) : "";
  commentOutput += comment.addNewlines ? "\n".repeat(comment.addNewlines) + after : forceWrap ? " " : "";
  return commentOutput;
}
function ParseParam(Parameter, {
  scope,
  vars,
  tabs,
  constants,
  $such,
  that,
  varExistent,
  Insert,
  InsertAll,
  Params = [],
  comments = [],
  lastNodeLocation,
  registry = {},
  i,
  isInside,
  isObject,
  isArray,
  Types,
  ValueKey,
  metaComments
}) {
  let output = "";
  comments = [];
  let dontAddAnyType = Parameter.dontAddAnyType;
  switch (Parameter[0]) {
    case "ParamArray":
      {
        Params.push({
          symbol: '['
        });
        var retval = ParseParamArray(Parameter[1].unwrap, {
          scope,
          vars,
          varExistent,
          tabs,
          constants,
          $such,
          that,
          varExistent,
          Insert,
          InsertAll,
          Params,
          comments,
          comments,
          lastNodeLocation,
          registry,
          i,
          isInside,
          isArray,
          isObject,
          Types,
          metaComments
        });
        Params.push({
          symbol: ']'
        });
        return retval;
      }
      ;
    case "ParamObject":
      {
        Params.push({
          symbol: '{',
          label: ValueKey,
          type: Parameter.loc.type && Parameter.loc.type.nodes.parse({
            registry
          })
        });
        var retval = ParseParamObject(Parameter[1].unwrap, {
          scope,
          vars,
          varExistent,
          tabs,
          constants,
          $such,
          that,
          varExistent,
          Insert,
          InsertAll,
          Params,
          comments,
          comments,
          lastNodeLocation,
          registry,
          type: !registry.omitTypeScript && Parameter[1].loc.type,
          isArray,
          isObject,
          Types,
          Loc: Parameter.loc,
          metaComments
        });
        Params.push({
          symbol: '}'
        });
        return retval;
      }
      ;
    case "ParamIdentifier":
      {
        let output = "";
        let Param = Parameter[1].contents;
        let Name = Param[0],
          // The name for this Param
          This = !!Param[1],
          // Does this param store directly in 'this' object?
          Defaults = Param[2],
          // The param default value if none assigned
          isThis = Param[3];
        findMissingType(Parameter, {
          metaComments,
          registry,
          tabs,
          scope,
          ID: Name
        });
        if (This || InsertAll && !isThis) {
          let refName = isObject ? Name : Reference(scope, false, Name);
          // this[thisProperty] = paramName
          Insert.push([Name, refName, Param.loc, Parameter.loc.type, ValueKey]); // [thisProperty, paramName]
          Params.push([refName, Param.loc, Parameter.loc.type, Name, ValueKey]);
          output += refName;
        } else {
          if (isThis && (isInside || i !== 0)) {
            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
              message: '\'this\' must be at the start of parameters',
              location: Parameter.loc
            });
          }
          if (!isThis) Params.push([Name, Param.loc, Parameter.loc.type,, ValueKey]);
          output += Name;
        }
        if (Parameter.loc.type && !registry.omitTypeScript) {
          registry.isTypeScript = true;
          if (!isObject) {
            if (isArray) {
              Types.hasNonGenerated = true;
              Types.push((registry.sources ? registry.sources.add(merge(Parameter.loc, Parameter.loc.type.nodes.loc)) : '') + Parameter.loc.type.nodes.parse({
                registry
              }));
            } else {
              output += `${Parameter.loc.type.optional ? '?' : ''}: ` + (registry.sources ? registry.sources.add(merge(Parameter.loc, Parameter.loc.type.nodes.loc)) : '') + Parameter.loc.type.nodes.parse({
                registry
              });
            }
          } else {
            Types.hasNonGenerated = true;
            Types.push((registry.sources ? registry.sources.add(merge(Parameter.loc, Parameter.loc.type.nodes.loc)) : '') + (ValueKey || Name) + `${Parameter.loc.type.optional ? '?' : ''}: ` + (registry.sources ? registry.sources.add(Parameter.loc.type.nodes.loc) : '') + Parameter.loc.type.nodes.parse({
              registry
            }));
          }
        } else if (!registry.omitTypeScript && Types) {
          if (!isObject) {
            if (isArray) {
              Types.push((registry.sources ? registry.sources.add(Parameter.loc) : '') + 'any');
            }
          } else if (!dontAddAnyType) {
            // flag
            Types.push((registry.sources ? registry.sources.add(Parameter.loc) : '') + (ValueKey || Name) + `: ` + 'any');
          }
        }
        if (typeof Defaults !== "undefined") {
          output += " = " + Defaults.parse({
            scope,
            vars,
            varExistent,
            tabs,
            constants,
            $such,
            that,
            varExistent,
            comments,
            lastNodeLocation,
            registry,
            isParam: true
          });
        }
        if (Parameter[1].expansion) output = `...${output}`;
        if (registry.sources) output = registry.sources.add(Parameter.loc) + output;
        return output;
      }
  }
  return output;
}
function ParseParamObject(ParamObject, {
  scope,
  vars,
  varExistent,
  tabs,
  constants,
  $such,
  that,
  Insert,
  InsertAll,
  Params,
  comments = [],
  lastNodeLocation,
  registry = {},
  type,
  i,
  isInside,
  isArray,
  Types: ParentTypes,
  Loc,
  metaComments
}) {
  var output = "{",
    Types = [];
  for (var i = 0; i < ParamObject.length; i++) {
    let Entry = ParamObject[i];
    let Key = Entry[0],
      // let Key: String
      Value = Entry[1],
      // let Value: String | undefined
      Defaults = Entry[2],
      // let Defaults: String | undefined
      Expansion = Entry[3],
      Loc = Entry[4] || {};
    output += " " + (registry.sources ? registry.sources.add(Entry.loc || Loc) : '');
    if (Entry instanceof Nodes.ParamIdentifier) {
      output += ParseParam(new Nodes.Param("ParamIdentifier", Entry).setLoc(Entry.loc), {
        scope,
        vars,
        varExistent,
        tabs,
        constants,
        $such,
        that,
        varExistent,
        Insert,
        Params,
        comments,
        i,
        isInside,
        isObject: true,
        Types,
        registry,
        metaComments
      });
    } else {
      if (Expansion) output += "..." + (registry.sources ? registry.sources.add(Loc) : '');
      output += Key;
      if (!Value) {
        findMissingType({
          loc: Loc
        }, {
          metaComments,
          registry,
          tabs,
          scope,
          ID: Key
        });
        Params.push([Key, Loc, Loc.type]);
      }
      if (Loc && Loc.type) {
        if (Loc.type.optional) {
          Loc.type.nodes.push('|', new Nodes.Identifier(null, 'any').setLoc({
            ...Loc,
            last_column: Loc.first_column + 1,
            last_line: Loc.first_line
          }));
        }
        Types.push((registry.sources ? registry.sources.add(merge(Loc, Loc.type.nodes.loc)) : '') + Key + ': ' + (registry.sources ? registry.sources.add(Loc.type.nodes.loc) : '') + Loc.type.nodes.parse({
          registry
        }));
        Types.hasNonGenerated = true;
        if (Value) {
          Value.dontAddAnyType = true;
        }
      }
      if (Value) {
        Types.Key = Key;
        Types.KeyLoc = Loc || Value.loc;
        output += ": " + (registry.sources ? registry.sources.add(Value.loc) : '') + ParseParam(Value, {
          scope,
          vars,
          varExistent,
          tabs,
          constants,
          $such,
          that,
          varExistent,
          Insert,
          InsertAll,
          Params,
          comments,
          isObject: true,
          ValueKey: Key,
          Types,
          registry,
          metaComments
        });
        Types.Key = undefined;
        Types.KeyLoc = undefined;
      }
      if (Defaults) output += " = " + Defaults.parse({
        scope,
        vars,
        varExistent,
        tabs,
        constants,
        $such,
        that,
        varExistent,
        isValue: true,
        isParam: true,
        comments,
        i,
        isInside
      });
    }
    output += ",";
  }
  if (output.charAt(output.length - 1) === ",") output = output.slice(0, -1);
  output += " }";
  if (!ParentTypes && !Types.hasNonGenerated) {
    Types = [];
  }
  if (!ParentTypes && !registry.omitTypeScript && (type || Types.length)) {
    registry.isTypeScript = true;
    output += `: `;
    var ttp = [];
    if (Types.length) {
      ttp.push(`{ ${Types.join(', ')} }`);
    }
    if (type) {
      ttp.push(type.nodes.parse({
        registry
      }));
    }
    output += ttp.join(' & ');
  } else if (!registry.omitTypeScript && (type || Types.length)) {
    registry.isTypeScript = true;
    var hasNonGenerated = false;
    var ttp = [];
    if (Types.length) {
      hasNonGenerated = Types.hasNonGenerated;
      ttp.push(`{ ${Types.join(', ')} }`);
    }
    if (type) {
      hasNonGenerated = true;
      ttp.push(type.nodes.parse({
        registry
      }));
    }
    ttp = ttp.join(' & ');
    if (ParentTypes.Key) {
      ttp = `${registry.sources ? registry.sources.add(ParentTypes.KeyLoc) : ''}${ParentTypes.Key}: ${ttp}`;
    }
    ParentTypes.push(ttp);
    if (hasNonGenerated) ParentTypes.hasNonGenerated = true;
  }
  if (ParamObject.defaults) output += " = " + ParamObject.defaults.parse({
    scope,
    vars,
    varExistent,
    tabs,
    constants,
    $such,
    that,
    varExistent,
    isValue: true,
    isParam: true,
    comments
  });
  if (3 === output.length) output = '{}';
  return output;
}
function ParseParamArray(ParamArray, {
  scope,
  vars,
  varExistent,
  tabs,
  constants,
  $such,
  that,
  Insert,
  InsertAll,
  Params,
  comments = [],
  lastNodeLocation,
  registry,
  i,
  isInside,
  Types: ParentTypes,
  metaComments
}) {
  var output = "[",
    Types = [];
  for (let Entry of ParamArray) {
    if (Entry) {
      output += ParseParam(Entry, {
        scope,
        vars,
        varExistent,
        tabs,
        constants,
        $such,
        that,
        varExistent,
        Insert,
        InsertAll,
        Params,
        comments,
        i,
        isInside,
        isArray: true,
        Types,
        registry,
        metaComments
      });
    }
    output += ", ";
  }
  output = output.replace(/, $/, '');
  output += "]";
  if (!Types.hasNonGenerated) {
    Types = [];
  }
  if (Types.length && !registry.omitTypeScript) {
    registry.isTypeScript = true;
    output += `: [${Types.map(t => Array.isArray(t) ? t[0] : t).join(', ')}]`;
  }
  if (ParamArray.defaults) output += " = " + ParamArray.defaults.parse({
    scope,
    vars,
    varExistent,
    tabs,
    constants,
    $such,
    that,
    varExistent,
    isValue: true,
    isParam: true,
    comments,
    comments
  });
  if (3 === output.length) output = '[]';
  return output;
}
function loadSoaks(res, {
  tabs,
  scope,
  vars,
  prevLine,
  Soaks,
  registry,
  loc
}) {
  let i = 0;
  let ss = "",
    _refV;
  for (let [soak] of Soaks) {
    ss += `${tab(registry.tabSize, tabs + i)}${registry.sources ? registry.sources.add(loc) : ''}if (${soak}) {\n`;
    i++;
  }
  ss += tab(registry.tabSize, tabs + i);
  _refV = Letter(scope, 's');
  scope.push(_refV);
  vars.push(_refV);
  ss += `${_refV} = ${res};`;
  for (let soak of Soaks) {
    i--;
    ss += `\n${tab(registry.tabSize, tabs + i)}}`;
  }
  prevLine.push(ss);
  return _refV;
}
let $$missing = [];
for (let key in _grammar_js__WEBPACK_IMPORTED_MODULE_3__["default"]) {
  if (Nodes[key]) continue;
  Nodes[key] = Base;
  $$missing.push(key);
}
function addMetaDataToPrevLine({
  typeData,
  prevLine,
  metaComments,
  tabs,
  registry
}) {
  let results = [];
  attachDescriptions(metaComments, typeData, tabs, registry);
  for (let def of typeData) {
    let build = [];
    if (def.description) {
      build.push(def.description.split('\n').map(d => d.trim()).join('\n' + tab(registry.tabSize, tabs) + ' * '));
    }
    if (def.value) {
      build.push(`@type {${def.value}}`);
    }
    if (build.length) results.push(`/**\n${tab(registry.tabSize, tabs)} * ${build.join(`\n${tab(registry.tabSize, tabs)} * `)}\n${tab(registry.tabSize, tabs)} */`);
  }
  prevLine.push(...results);
  return '';
}
function buildFunctionDefinitionWithJSDoc({
  ParamData,
  registry,
  tabs,
  loc,
  prevLine,
  scope,
  selectedDescription
}) {
  var defs = [],
    refs = [];
  function $refs(noIndex) {
    return refs.map((r, i, l) => r.chunk + (r.count !== undefined ? noIndex && i === l.length - 1 ? '' : `[${r.count}]` : '')).join('');
  }
  function $last(i = 1) {
    return refs[refs.length - i] || {};
  }
  function $isArray() {
    return typeof (refs[refs.length - 1] || {}).count === 'number';
  }
  function $isArrayRoot() {
    return refs.findIndex(r => typeof r.count === 'number') > -1;
  }
  function map(ref) {
    if (ref.isObject) {
      let res = [];
      for (var item of ref.values) {
        if (Array.isArray(item)) {
          let [key, value] = item;
          res.push(`${key}: ${value || 'any'}`);
        } else {
          res.push(item);
        }
      }
      res = '{ ' + res.join(', ') + ' }';
      if (res.length === 4) {
        res = '{ }';
      }
      if (ref.label) {
        res = `${ref.label}: ${res}`;
      }
      return res;
    } else {
      return `[${ref.values.join(', ')}]`;
    }
  }
  for (let data of ParamData) {
    if (data.symbol) {
      let opts = data;
      data = data.symbol;
      if (['{', '['].includes(data)) {
        refs.push({
          chunk: refs.length === 0 ? Reference(scope, false, 'param') : $isArray() ? '' : '.' + opts.label,
          isArray: data === '[',
          isObject: data === '{',
          count: data === '[' ? 0 : undefined,
          index: defs.length,
          values: [],
          label: opts.label
        });
        defs.push(` * @param {${data === '[' ? opts.type || 'Array<any>' : opts.type || 'object'}} ${$refs(true)}${data === '[' ? ' -' : ''}`);
      } else {
        var last = refs.pop();
        if ($isArray()) $last().count++;
        $last().values && $last().values.push(map(last));
        if ($isArrayRoot() && defs[last.index]) {
          delete defs[last.index];
        }
      }
      continue;
    }
    var line = ' * ';
    if (!$isArrayRoot()) {
      line += `@param {${data.value || '*'}} `;
      line += `${$refs() ? $refs() + ($isArray() ? '' : '.') : ''}${!$isArray() ? data.propertyID || data.ID : ''}`;
      if ((refs[refs.length - 1] || {}).count !== undefined) {
        refs[refs.length - 1].count++;
      }
    } else {
      line += `- \`${data.ID}\`${data.description ? ':' : ''}`;
      defs[$last().index] = defs[$last().index].replace(/@param \{(.+)\} /, function (str, val) {
        $last().values.push($last().isObject ? [data.label || data.ID, data.value || 'any'] : data.value || 'any');
        return `@param {${map($last())}} `;
      });
      $last().count++;
    }
    if (data.description) {
      line += ` ${data.description}`;
    }
    defs.push(line);
  }
  if (selectedDescription) {
    defs.unshift(' * ' + selectedDescription);
  }
  prevLine.push(`/**\n${tab(registry.tabSize, tabs)}${defs.filter(d => d !== undefined).join(`\n${tab(registry.tabSize, tabs)}`)}\n${tab(registry.tabSize, tabs)}*/`);
}
function buildVarDefinitionsWithJSDoc(typeData, tabs, keyword, metaComments, registry) {
  let results = [];
  attachDescriptions(metaComments, typeData, tabs, registry);
  for (let def of typeData) {
    let build = [];
    if (def.description) {
      build.push(def.description);
    }
    if (def.value) {
      build.push(`@type {${def.value}}`);
    }
    if (build.length) {
      results.push(`/**\n${tab(registry.tabSize, tabs)} * ${build.join(`\n${tab(registry.tabSize, tabs)} * `)}\n${tab(registry.tabSize, tabs)} */\n${tab(registry.tabSize, tabs)}${keyword}${def.ID};`);
    }
  }
  return results.length ? tab(registry.tabSize, tabs) + results.join('\n\n' + tab(registry.tabSize, tabs)) + '\n\n' : '';
}
function buildVarDefinitions(typeData, tabs, keyword, metaComments, rewrite, registry = {}) {
  let results = [];
  attachDescriptions(metaComments, typeData, tabs, registry);
  for (let def of typeData) {
    let build = [];
    if (def.description) {
      build.push(def.description);
    }
    if (build.length) {
      results.push(`/**\n${tab(registry.tabSize, tabs)} * ${build.join(`\n${tab(registry.tabSize, tabs)} * `)}\n${tab(registry.tabSize, tabs)} */\n${tab(registry.tabSize, tabs)}${keyword}${registry.sources ? registry.sources.add(def.loc) : ''}${def.ID}${def.value ? `: ${def.value}` : ''};`);
      rewrite.push(def.ID);
    }
  }
  return results.length ? tab(registry.tabSize, tabs) + results.join('\n\n' + tab(registry.tabSize, tabs)) + '\n\n' : '';
}
function attachDescriptions(metaComments = [], typeData, tabs, registry, strict) {
  let scaned = 0;
  metaComments = metaComments.filter(meta => !meta.read);
  for (var n = 0, len = metaComments.length; n < len; n++) {
    let comment = metaComments[n][1];
    let chunks = [],
      i = 0,
      sameLine = "";
    consume: while (true) {
      var {
          first_line: line,
          first_column: column
        } = metaComments[n].loc,
        noUpdateColumn = false;
      column = column + 2;
      if (!comment.charAt(i)) break consume;
      if (comment.charAt(i) === '\n') {
        noUpdateColumn = true;
        column = 0;
        line++;
        sameLine = "";
      }
      let name = /^((?:[^\x00-\x7F]|[a-z$_])(?:[^\x00-\x7F]|[a-z$_\d])*)\s*(:|-*>|[=-]+>?)/i.exec(comment.slice(i)),
        description;
      if (name && sameLine.trim().length === 0) {
        scaned++;
        i += name[0].length;
        let sideType;
        if (/^\s*\{/.test(comment.slice(i))) {
          let offset = i + /^\s*\{/.exec(comment.slice(i))[0].length,
            braces = ['{'],
            char,
            chunk = "";
          read: while (char = comment.charAt(offset)) {
            if (['{', '(', '[', '<'].includes(char)) {
              braces.push(char);
            } else if (!(char === ">" && ['-', '='].includes(comment.charAt(offset - 1))) && ['}', ')', ']', '>'].includes(char)) {
              var pair = ['{', '(', '[', '<'][['}', ')', ']', '>'].indexOf(char)];
              if (braces.pop() !== pair) {
                var fc = column + name[0].length + offset - i + 1;
                (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
                  message: 'Unmatched ' + char,
                  code: comment.split('\n')[line - 1],
                  location: {
                    first_line: line,
                    first_column: fc,
                    last_column: fc + 1,
                    last_line: line
                  }
                });
              }
            }
            offset++;
            if (!braces.length) {
              break read;
            } else {
              chunk += char;
            }
          }
          var optional = chunk.endsWith('?');
          if (optional) {
            chunk = chunk.slice(0, -1);
          }
          var fc = column + name[0].length + /^\s*\{/.exec(comment.slice(i))[0].length + 1;
          i = offset;
          let nodes = (() => {
            let retv;
            try {
              retv = _index_js__WEBPACK_IMPORTED_MODULE_2__["default"].compile(`type PARTIAL = ${chunk}`, {
                cursor: {
                  x: fc - 13,
                  y: line
                },
                nodes: true
              }).nodes;
            } catch (_) {}
            return retv;
          })();
          if (!nodes) {
            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
              message: 'Invalid type',
              location: {
                first_column: fc,
                first_line: line,
                last_line: line,
                last_column: fc + chunk.length
              },
              type: 'SyntaxError'
            }, comment.split('\n')[line - 1]);
          }
          sideType = {
            loc: {
              first_line: line,
              first_column: fc,
              last_column: fc + chunk.length,
              last_line: line
            },
            nodes: nodes.visit(1, 1, 0, 1, 1, 1, 2),
            optional,
            value: chunk
          };
        }
        let di = /\n(?!-)/.exec(comment.slice(i));
        description = comment.slice(i, di ? i + di.index : comment.length).trim();
        description = description.split('\n').map(line => line.replace(/^-\s*/, '').trim()).join('\n' + tab(registry.tabSize, tabs) + ' * ');
        chunks.push({
          comment: metaComments[n],
          name: name[1],
          description,
          sideType,
          value: sideType && sideType.nodes.parse({
            registry
          })
        });
        i += description.length;
      } else {
        if (!noUpdateColumn) column++;
        i++;
        sameLine += comment.charAt(i);
      }
    }
    for (let o = 0, chunkNo = chunks.length; o < chunkNo; o++) {
      let ch = chunks[o];
      let tp = typeData.find(def => def.ID === ch.name || def.ID2 === ch.name);
      if (tp) {
        ch.comment.read = true;
        tp.last_comment = ch.comment;
        tp.commentStart = ch.comment.loc.first_line;
        tp.description = ch.description.replace(/^\s*# /, '');
      }
    }
  }
  if (typeData.length === 1 && !typeData[0].description && !strict) {
    let tp = typeData[0];
    let last = metaComments[metaComments.length - 1];
    if (last && !last.read && last.loc.last_line !== -1) {
      last.read = true;
      tp.description = last[1].replace(/^\s*# /, '');
    }
    let i = metaComments.length - 1,
      com;
    while (com = metaComments[--i]) {
      if (com.read) break;
      if (com.loc.last_line === last.loc.last_line - 1) {
        tp.description = com[1].replace(/^\s*# /, '') + '\n' + tab(registry.tabSize, tabs) + tp.description;
        com.read = true;
        last = com;
      } else {
        break;
      }
    }
  } else if (typeData.length === 1 && typeData[0].description && strict) {
    metaComments = metaComments.slice(metaComments.findIndex(c => c.loc === typeData[0].last_comment.loc)).filter(c => !c.read);
    for (let comment of metaComments) {
      var last_comment = typeData[0].last_comment,
        noName = !/^\s*((?:[^\x00-\x7F]|[a-z$_])(?:[^\x00-\x7F]|[a-z$_\d])*)\s*(:|-*>|=>?)/i.test(comment[1]);
      if (noName && comment.loc.first_line === last_comment.loc.last_line + 1) {
        typeData[0].description += `\n${tab(registry.tabSize, tabs)} * ${comment[1].replace(/^\s*# /, '')}`;
        comment.read = true;
        typeData[0].last_comment = comment;
      } else {
        break;
      }
    }
  }
}
function getDataOfMetaComments({
  metaComments = [],
  ID,
  ID2,
  tabs,
  loc,
  registry,
  strict,
  noUpdate
}) {
  let result;
  metaComments = metaComments.filter(c => !c.read);
  for (let n = 0, len = metaComments.length; n < len; n++) {
    let comment = metaComments[n][1];
    let chunks = [],
      i = 0;
    consume: while (true) {
      var {
          first_line: line,
          first_column: column
        } = metaComments[n].loc,
        noUpdateColumn = false;
      column = column + 2;
      if (!comment.charAt(i)) break consume;
      if (comment.charAt(i) === '\n') {
        noUpdateColumn = true;
        column = 0;
        line++;
      }
      let name = /^((?:[^\x00-\x7F]|[a-z$_])(?:[^\x00-\x7F]|[a-z$_\d])*)\s*(:|-*>|=>?)/i.exec(comment.slice(i)),
        description;
      if (name) {
        i += name[0].length;
        let sideType;
        if (/^\s*\{/.test(comment.slice(i))) {
          let offset = i + /^\s*\{/.exec(comment.slice(i))[0].length,
            braces = ['{'],
            char,
            chunk = "";
          read: while (char = comment.charAt(offset)) {
            if (['{', '(', '[', '<'].includes(char)) {
              braces.push(char);
            } else if (['}', ')', ']', '>'].includes(char)) {
              var pair = ['{', '(', '[', '<'][['}', ')', ']', '>'].indexOf(char)];
              if (braces.pop() !== pair) {
                var fc = column + name[0].length + offset - i + 1;
                (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
                  message: 'Unmatched ' + char,
                  code: comment.split('\n')[line - 1],
                  location: {
                    first_line: line,
                    first_column: fc,
                    last_column: fc + 1,
                    last_line: line
                  }
                });
              }
            }
            offset++;
            if (!braces.length) {
              break read;
            } else {
              chunk += char;
            }
          }
          var optional = chunk.endsWith('?');
          if (optional) {
            chunk = chunk.slice(0, -1);
          }
          var fc = column + name[0].length + /^\s*\{/.exec(comment.slice(i))[0].length + 1;
          i = offset;
          let nodes = (() => {
            let retv;
            try {
              retv = _index_js__WEBPACK_IMPORTED_MODULE_2__["default"].compile(`type PARTIAL = ${chunk}`, {
                cursor: {
                  x: fc - 13,
                  y: line
                },
                nodes: true
              }).nodes;
            } catch (_) {}
            return retv;
          })();
          if (!nodes) {
            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throwSyntaxError)({
              message: 'Invalid type',
              location: {
                first_column: fc,
                first_line: line,
                last_line: line,
                last_column: fc + chunk.length
              },
              type: 'SyntaxError'
            }, comment.split('\n')[line - 1]);
          }
          sideType = {
            loc: {
              first_line: line,
              first_column: fc,
              last_column: fc + chunk.length,
              last_line: line
            },
            nodes: nodes.visit(1, 1, 0, 1, 1, 1, 2),
            optional,
            value: chunk
          };
        }
        let di = /\n(?!-)/.exec(comment.slice(i));
        description = comment.slice(i, di ? i + di.index : comment.length).trim();
        description = description.split('\n').map(line => line.replace(/^-\s*/, '').trim()).join('\n' + tab(registry.tabSize, tabs) + ' * ');
        chunks.push({
          comment: metaComments[n],
          name: name[1],
          description,
          sideType,
          value: sideType && sideType.nodes.parse({
            registry
          })
        });
        i += description.length;
      } else {
        if (!noUpdateColumn) column++;
        i++;
      }
      ;
    }
    for (let o = 0, chunkNo = chunks.length; o < chunkNo; o++) {
      let ch = chunks[o];
      if (ch.name === ID || ch.name === ID2) {
        result = ch;
        if (!noUpdate) ch.comment.read = true;
      }
    }
  }
  if (!result && !strict) {
    let last = metaComments[metaComments.length - 1];
    if (last && !last.read && last.loc.last_line !== -1) {
      if (last.loc.last_line === loc.last_line && last.loc.last_column < loc.last_column || last.loc.last_line < loc.last_line) {
        result = {
          name: ID,
          description: last[1].replace(/^\s*#\s*/, '')
        };
      }
    }
  }
  return result;
}
function findMissingType(node, {
  metaComments,
  scope,
  tabs,
  registry,
  ID,
  loc = node && node.loc
}) {
  if (node && node.loc && !node.loc.type) {
    var resType = getDataOfMetaComments({
      metaComments,
      ID,
      loc,
      tabs,
      registry,
      strict: true,
      noUpdate: true
    });
    if (resType && resType.sideType) {
      node.loc.type = resType.sideType;
    }
  }
}
;
function merge({
  first_line,
  first_column,
  ...first
}, {
  last_line,
  last_column
} = {}) {
  if (!last_line) ({
    last_line
  } = first);
  if (!last_column) ({
    last_column
  } = first);
  return {
    first_line,
    first_column,
    last_line,
    last_column,
    src: first.src,
    type: first.type
  };
}

if (typeof module !== "undefined" && typeof require === "function") {
  module.exports = {
    Parser,
    Nodes
  };
}
function print(val) {
  console.log(val);
  return val;
}

/***/ }),

/***/ "./lib/relic.js":
/*!**********************!*\
  !*** ./lib/relic.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* parser generated by jison 0.6.1-215 */ /*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journes Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */var Relic=function(){// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg,hash){Object.defineProperty(this,'name',{enumerable:false,writable:false,value:'JisonParserError'});if(msg==null)msg='???';Object.defineProperty(this,'message',{enumerable:false,writable:true,value:msg});this.hash=hash;var stacktrace;if(hash&&hash.exception instanceof Error){var ex2=hash.exception;this.message=ex2.message||msg;stacktrace=ex2.stack;}if(!stacktrace){if(Error.hasOwnProperty('captureStackTrace')){// V8/Chrome engine
Error.captureStackTrace(this,this.constructor);}else{stacktrace=new Error(msg).stack;}}if(stacktrace){Object.defineProperty(this,'stack',{enumerable:false,writable:false,value:stacktrace});}}if(typeof Object.setPrototypeOf==='function'){Object.setPrototypeOf(JisonParserError.prototype,Error.prototype);}else{JisonParserError.prototype=Object.create(Error.prototype);}JisonParserError.prototype.constructor=JisonParserError;JisonParserError.prototype.name='JisonParserError';// helper: reconstruct the productions[] table
function bp(s){var rv=[];var p=s.pop;var r=s.rule;for(var i=0,l=p.length;i<l;i++){rv.push([p[i],r[i]]);}return rv;}// helper: reconstruct the defaultActions[] table
function bda(s){var rv={};var d=s.idx;var g=s.goto;for(var i=0,l=d.length;i<l;i++){var j=d[i];rv[j]=g[i];}return rv;}// helper: reconstruct the 'goto' table
function bt(s){var rv=[];var d=s.len;var y=s.symbol;var t=s.type;var a=s.state;var m=s.mode;var g=s.goto;for(var i=0,l=d.length;i<l;i++){var n=d[i];var q={};for(var j=0;j<n;j++){var z=y.shift();switch(t.shift()){case 2:q[z]=[m.shift(),g.shift()];break;case 0:q[z]=a.shift();break;default:// type === 1: accept
q[z]=[3];}}rv.push(q);}return rv;}// helper: runlength encoding with increment step: code, length: step (default step = 0)
// `this` references an array
function s(c,l,a){a=a||0;for(var i=0;i<l;i++){this.push(c);c+=a;}}// helper: duplicate sequence from *relative* offset and length.
// `this` references an array
function c(i,l){i=this.length-i;for(l+=i;i<l;i++){this.push(this[i]);}}// helper: unpack an array using helpers and data, all passed in an array argument 'a'.
function u(a){var rv=[];for(var i=0,l=a.length;i<l;i++){var e=a[i];// Is this entry a helper function?
if(typeof e==='function'){i++;e.apply(rv,a[i]);}else{rv.push(e);}}return rv;}var parser={// Code Generator Information Report
// ---------------------------------
//
// Options:
//
//   default action mode: ............. ["classic","merge"]
//   test-compile action mode: ........ "parser:*,lexer:*"
//   try..catch: ...................... true
//   default resolve on conflict: ..... true
//   on-demand look-ahead: ............ false
//   error recovery token skip maximum: 3
//   yyerror in parse actions is: ..... NOT recoverable,
//   yyerror in lexer actions and other non-fatal lexer are:
//   .................................. NOT recoverable,
//   debug grammar/output: ............ false
//   has partial LR conflict upgrade:   true
//   rudimentary token-stack support:   false
//   parser table compression mode: ... 2
//   export debug tables: ............. false
//   export *all* tables: ............. false
//   module type: ..................... commonjs
//   parser engine type: .............. lalr
//   output main() in the module: ..... true
//   has user-specified main(): ....... false
//   has user-specified require()/import modules for main():
//   .................................. false
//   number of expected conflicts: .... 0
//
//
// Parser Analysis flags:
//
//   no significant actions (parser is a language matcher only):
//   .................................. false
//   uses yyleng: ..................... false
//   uses yylineno: ................... false
//   uses yytext: ..................... false
//   uses yylloc: ..................... false
//   uses ParseError API: ............. false
//   uses YYERROR: .................... false
//   uses YYRECOVERING: ............... false
//   uses YYERROK: .................... false
//   uses YYCLEARIN: .................. false
//   tracks rule values: .............. true
//   assigns rule values: ............. true
//   uses location tracking: .......... true
//   assigns location: ................ true
//   uses yystack: .................... false
//   uses yysstack: ................... false
//   uses yysp: ....................... true
//   uses yyrulelength: ............... false
//   uses yyMergeLocationInfo API: .... true
//   has error recovery: .............. false
//   has error reporting: ............. false
//
// --------- END OF REPORT -----------
trace:function no_op_trace(){},JisonParserError:JisonParserError,yy:{},options:{type:"lalr",hasPartialLrUpgradeOnConflict:true,errorRecoveryTokenDiscardCount:3},symbols_:{"!":7,"!=":56,"!==":54,"$accept":0,"$end":1,"%":9,"&":14,"&&":63,"(":21,")":22,")>":79,"*":8,"**":45,"+":4,"++":41,",":17,"-":5,"--":42,".":23,"...":116,":":20,";":18,"<":12,"<(":78,"<<":48,"<=":58,"==":55,"===":52,">":11,">=":57,">>":49,">>>":50,"?":19,"??":64,"@":3,"AND":60,"AS":143,"ASYNC":74,"AT":144,"AWAIT":30,"Access":260,"AlphaNum":226,"Arg":214,"ArgList":213,"Arguments":212,"Array":262,"ArrayArg":266,"ArrayList":264,"Assign":251,"AssignKeyword":253,"Assignable":254,"Assignment":252,"BOOL":124,"BREAK":90,"Block":181,"BlockExpression":198,"Body":165,"CALL_END":115,"CALL_START":114,"CASE":92,"CATCH":101,"CHAIN":39,"CLASS":76,"COMPOUND_AND":40,"COMPOUND_OR":91,"CONST":160,"CONTINUE":148,"Case":193,"Cases":192,"Catch":200,"Class":184,"ClassBlock":185,"ClassBody":166,"ClassConstructor?":186,"ClassFunction":246,"ClassFunctionPrelude":236,"ClassFunctionTag":237,"ClassImplements?":272,"ClassLine":168,"Clause":171,"Clauses":194,"Code":182,"Compare":175,"DEFAULT":88,"DEFAULTS":147,"DELETE":150,"DIVISION":47,"DO":27,"Declaration":300,"DeclarationKeyword":298,"Declarations":299,"Declare":297,"Defaults":255,"EITHER":65,"EITHER_OR":66,"ELSE":108,"EOF":1,"EXISTS":35,"EXPORT":163,"EXTENDS":77,"Else":208,"ElseOtherwise":205,"Export":304,"ExportList":306,"ExportName":308,"ExportNames":307,"Exportable":309,"Expression":169,"ExtendsName":274,"ExtendsNames":273,"FINALLY":102,"FOR":81,"FOR_AS":97,"FOR_AT":96,"FOR_FROM":95,"FOR_IN":85,"FOR_OF":84,"FROM":145,"FUNCTION":138,"FUNC_DIRECTIVE":69,"FUNC_DIRECTIVE?":245,"FUNC_EXISTS":112,"Finally":201,"For":189,"ForAny":196,"ForAssignable":190,"ForExpression":187,"Function":242,"FunctionInterlude":240,"FunctionInterlude?":243,"FunctionPostlude":241,"FunctionPostlude?":244,"FunctionPrelude":238,"FunctionTag":239,"GET":140,"IDENTIFIER":142,"IF":93,"IMPLEMENTS":152,"IMPORT":162,"IN":146,"INCLUDES":37,"INDENT":31,"INDEX_END":120,"INDEX_START":119,"INFINITY":123,"INSTANCEOF":59,"INTERFACE":151,"INTERPOLATION_END":134,"INTERPOLATION_START":133,"IS":51,"ISNT":53,"Identifier":258,"If":197,"IfBlock":209,"IfUnless":207,"Import":302,"ImportList":305,"ImportName":311,"ImportNames":310,"InlineType":291,"IntExtends?":271,"IntTypeSentence?":278,"IntTypeSpecifiers":279,"Interface":270,"InterfaceBody":275,"InterfaceProperties":276,"InterfaceProperty":277,"Interpolation":231,"Interpolations":230,"Invocation":211,"JSX":228,"JSX_END":130,"JSX_START":129,"JointExpression":188,"KEYOF":157,"LET":159,"LOOP":103,"Label":183,"Line":167,"Literal":225,"Logical":176,"Loop":203,"MATH_BIN":38,"MathPostfix":173,"MathPrefix":172,"Multicheck":177,"MulticheckClauses":180,"MulticheckCombinations":179,"Multicondition":178,"NAN":126,"NEW":117,"NEWLINE":26,"NOT":44,"NULL":125,"NUMBER":127,"New":215,"ON":94,"OR":61,"OTHERWISE":109,"OUTDENT":32,"Object":220,"Operation":170,"Operator":174,"OptComma":219,"OptSeparator":303,"OptVoids":267,"PARAM_END":72,"PARAM_START":71,"PLUS":46,"POSTCASE":89,"POSTFOR":86,"POSTIF":98,"POSTUNLESS":99,"POSTUNTIL":107,"POSTWHILE":106,"PROPERTY":118,"Param":250,"ParamArray":261,"ParamArrayArg":265,"ParamArrayList":263,"ParamAssignable":256,"ParamIdentifier":259,"ParamList":249,"ParamObject":257,"ParamPropList":222,"ParamPropObj":224,"Params":248,"Parenthetical":218,"PropList":221,"PropObj":223,"READONLY":153,"REGEX":135,"REGEX_END":137,"REGEX_START":136,"RETURN":161,"Regex":232,"RegexInterpolation":235,"RegexInterpolations":234,"RegexWithInterpolations":233,"Return":301,"Root":164,"SET":141,"STATIC":139,"STRING":128,"STRING_END":132,"STRING_START":131,"SUCH":111,"SUPER":113,"SWITCH":87,"SYMBOL_EXISTS":36,"Statement":269,"String":227,"StringWithInterpolations":229,"Super":216,"Switch":191,"TAG":156,"THEN":73,"THIS":121,"THROW":149,"TRY":100,"TYPE":154,"TYPEOF":29,"TYPE_JOIN":155,"This":217,"Try":199,"TryBlock":202,"Type":280,"TypeAccess":286,"TypeArgument":290,"TypeArguments":289,"TypeArguments?":247,"TypeArray":295,"TypeArrayItems":296,"TypeDeclaration":281,"TypeFunction":287,"TypeObjProp":294,"TypeObjProps":293,"TypeObject":292,"TypeSentence":282,"TypeValue":283,"TypeWithArguments":288,"TypeWrapped":285,"TypeofKeyof":284,"UNDEFINED":122,"UNLESS":110,"UNTIL":105,"USING":75,"VAR":158,"VOID":33,"Value":210,"Voids":268,"WHEN":82,"WHETHER":28,"WHILE":104,"WHILST":83,"WITH":80,"WITHIN":70,"When":195,"While":206,"WhileUntil":204,"YIELD":34,"[":24,"]":25,"^":10,"error":2,"{":15,"{{":67,"|":13,"||":62,"}":16,"}}":68,"~":6,"~~":43},terminals_:{1:"EOF",2:"error",3:"@",4:"+",5:"-",6:"~",7:"!",8:"*",9:"%",10:"^",11:">",12:"<",13:"|",14:"&",15:"{",16:"}",17:",",18:";",19:"?",20:":",21:"(",22:")",23:".",24:"[",25:"]",26:"NEWLINE",27:"DO",28:"WHETHER",29:"TYPEOF",30:"AWAIT",31:"INDENT",32:"OUTDENT",33:"VOID",34:"YIELD",35:"EXISTS",36:"SYMBOL_EXISTS",37:"INCLUDES",38:"MATH_BIN",39:"CHAIN",40:"COMPOUND_AND",41:"++",42:"--",43:"~~",44:"NOT",45:"**",46:"PLUS",47:"DIVISION",48:"<<",49:">>",50:">>>",51:"IS",52:"===",53:"ISNT",54:"!==",55:"==",56:"!=",57:">=",58:"<=",59:"INSTANCEOF",60:"AND",61:"OR",62:"||",63:"&&",64:"??",65:"EITHER",66:"EITHER_OR",67:"{{",68:"}}",69:"FUNC_DIRECTIVE",70:"WITHIN",71:"PARAM_START",72:"PARAM_END",73:"THEN",74:"ASYNC",75:"USING",76:"CLASS",77:"EXTENDS",78:"<(",79:")>",80:"WITH",81:"FOR",82:"WHEN",83:"WHILST",84:"FOR_OF",85:"FOR_IN",86:"POSTFOR",87:"SWITCH",88:"DEFAULT",89:"POSTCASE",90:"BREAK",91:"COMPOUND_OR",92:"CASE",93:"IF",94:"ON",95:"FOR_FROM",96:"FOR_AT",97:"FOR_AS",98:"POSTIF",99:"POSTUNLESS",100:"TRY",101:"CATCH",102:"FINALLY",103:"LOOP",104:"WHILE",105:"UNTIL",106:"POSTWHILE",107:"POSTUNTIL",108:"ELSE",109:"OTHERWISE",110:"UNLESS",111:"SUCH",112:"FUNC_EXISTS",113:"SUPER",114:"CALL_START",115:"CALL_END",116:"...",117:"NEW",118:"PROPERTY",119:"INDEX_START",120:"INDEX_END",121:"THIS",122:"UNDEFINED",123:"INFINITY",124:"BOOL",125:"NULL",126:"NAN",127:"NUMBER",128:"STRING",129:"JSX_START",130:"JSX_END",131:"STRING_START",132:"STRING_END",133:"INTERPOLATION_START",134:"INTERPOLATION_END",135:"REGEX",136:"REGEX_START",137:"REGEX_END",138:"FUNCTION",139:"STATIC",140:"GET",141:"SET",142:"IDENTIFIER",143:"AS",144:"AT",145:"FROM",146:"IN",147:"DEFAULTS",148:"CONTINUE",149:"THROW",150:"DELETE",151:"INTERFACE",152:"IMPLEMENTS",153:"READONLY",154:"TYPE",155:"TYPE_JOIN",156:"TAG",157:"KEYOF",158:"VAR",159:"LET",160:"CONST",161:"RETURN",162:"IMPORT",163:"EXPORT"},TERROR:2,EOF:1,// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName:null,originalParseError:null,cleanupAfterParse:null,constructParseErrorInfo:null,yyMergeLocationInfo:null,__error_infos:[],// INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
__error_recovery_infos:[],// INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
// APIs which will be set up depending on user action code analysis:
//yyRecovering: 0,
//yyErrOk: 0,
//yyClearIn: 0,
// Helper APIs
// -----------
// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName:function parser_quoteName(id_str){return'"'+id_str+'"';},// Return the name of the given symbol (terminal or non-terminal) as a string, when available.
//
// Return NULL when the symbol is unknown to the parser.
getSymbolName:function parser_getSymbolName(symbol){if(this.terminals_[symbol]){return this.terminals_[symbol];}// Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
//
// An example of this may be where a rule's action code contains a call like this:
//
//      parser.getSymbolName(#$)
//
// to obtain a human-readable name of the current grammar rule.
var s=this.symbols_;for(var key in s){if(s[key]===symbol){return key;}}return null;},// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol:function parser_describeSymbol(symbol){if(symbol!==this.EOF&&this.terminal_descriptions_&&this.terminal_descriptions_[symbol]){return this.terminal_descriptions_[symbol];}else if(symbol===this.EOF){return'end of input';}var id=this.getSymbolName(symbol);if(id){return this.quoteName(id);}return null;},// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set:function parser_collect_expected_token_set(state,do_not_describe){var TERROR=this.TERROR;var tokenset=[];var check={};// Has this (error?) state been outfitted with a custom expectations description text for human consumption?
// If so, use that one instead of the less palatable token set.
if(!do_not_describe&&this.state_descriptions_&&this.state_descriptions_[state]){return[this.state_descriptions_[state]];}for(var p in this.table[state]){p=+p;if(p!==TERROR){var d=do_not_describe?p:this.describeSymbol(p);if(d&&!check[d]){tokenset.push(d);check[d]=true;// Mark this token description as already mentioned to prevent outputting duplicate entries.
}}}return tokenset;},productions_:bp({pop:u([164,164,s,[165,3],s,[166,3],167,167,s,[168,3],s,[169,12],s,[170,23],s,[171,3],s,[172,8],173,173,s,[174,11],s,[175,11],s,[176,7],177,178,179,179,180,180,s,[181,6],s,[182,15],s,[183,3],s,[184,12],s,[185,6],s,[186,4],187,187,188,188,s,[189,22],190,190,s,[191,4],192,192,s,[193,10],s,[194,3],s,[195,4],s,[196,3],s,[197,9],198,198,199,199,s,[200,5],201,201,s,[202,3],203,203,s,[204,4],s,[205,3],s,[206,7],207,207,s,[208,4],s,[209,10],s,[210,9],s,[211,9],s,[212,3],s,[213,4],s,[214,3],215,216,216,217,s,[218,3],219,219,s,[220,3],s,[221,4],s,[222,5],s,[223,18],s,[224,8],s,[225,7],226,226,227,s,[227,4,1],230,230,231,231,232,232,233,234,234,235,235,236,236,s,[237,5],238,238,239,239,s,[240,8],s,[241,6],242,243,243,244,244,245,245,s,[246,4],s,[247,3],248,248,s,[249,4],250,251,s,[252,4],s,[253,3],s,[254,5],255,255,s,[256,5],257,257,258,s,[259,9],260,260,s,[261,3],s,[262,3],s,[263,3],s,[264,4],265,265,s,[266,4],267,267,s,[268,3],s,[269,13],270,270,271,271,272,272,s,[273,3],274,s,[275,7],s,[276,8],s,[277,11],s,[278,4],279,279,s,[280,3],s,[281,3],s,[282,7],s,[283,11],284,284,285,285,s,[286,4],s,[287,4],s,[288,3],s,[289,4],s,[290,3],s,[291,5],s,[292,3],s,[293,4],s,[294,11],295,295,s,[296,4],297,297,s,[298,3],s,[299,4],s,[300,4],s,[301,4],s,[302,3],s,[303,3],s,[304,8],s,[305,4],306,306,s,[307,3],s,[308,6],309,309,s,[310,3],s,[311,6]]),rule:u([0,1,3,2,c,[3,4],s,[1,17],2,2,3,s,[2,5],4,2,4,c,[4,3],2,s,[3,4],c,[41,3],3,4,1,c,[44,19],s,[1,21],s,[2,4],3,c,[6,3],4,3,5,3,2,5,5,4,5,4,6,5,6,c,[6,3],5,c,[19,3],4,s,[3,4,1],4,5,7,8,6,6,5,7,c,[104,3],c,[36,4],0,c,[97,4],1,1,3,7,8,8,c,[3,3],5,5,s,[6,4],c,[11,3],9,9,c,[13,4],7,2,1,5,4,7,6,c,[129,3],3,c,[139,3],c,[90,5],c,[12,3],s,[2,4],c,[107,5],5,3,7,s,[3,4],c,[201,3],c,[27,4],4,c,[176,3],1,c,[191,4],s,[1,7],4,4,5,c,[185,3],c,[50,3],c,[29,4],s,[5,4],4,4,6,6,c,[202,3],s,[1,8],c,[147,3],c,[3,3],3,c,[153,4],c,[98,3],c,[4,3],c,[69,5],c,[96,3],5,0,1,c,[26,3],c,[19,3],c,[9,3],c,[5,3],c,[115,4],c,[74,3],c,[142,3],c,[46,3],c,[79,5],3,2,c,[272,3],c,[121,4],s,[1,10],c,[13,3],c,[207,3],c,[9,4],c,[26,3],c,[36,3],c,[269,7],c,[16,3],c,[41,3],c,[329,4],c,[283,6],4,0,1,0,1,s,[0,4,1],1,2,0,c,[122,3],c,[187,3],c,[120,3],1,3,5,c,[59,5],c,[35,4],c,[8,5],c,[23,3],c,[277,4],c,[383,4],c,[181,3],c,[212,4],c,[220,3],c,[165,5],1,3,6,c,[16,3],c,[232,4],0,c,[45,5],c,[9,3],c,[55,5],4,c,[7,3],5,7,0,2,0,c,[194,4],c,[6,3],c,[346,3],c,[70,4],4,c,[336,3],7,9,c,[7,3],9,c,[386,3],c,[27,3],8,c,[26,4],c,[47,4],c,[119,3],c,[216,3],c,[386,4],c,[197,12],c,[296,4],4,6,c,[365,4],c,[24,3],c,[112,5],c,[70,4],c,[40,5],c,[26,3],c,[15,6],c,[307,3],7,8,9,c,[87,3],c,[17,3],c,[353,3],c,[266,3],c,[177,4],c,[26,4],5,c,[259,4],s,[4,3],6,c,[224,3],c,[129,4],c,[578,4],c,[224,4],c,[58,5],c,[346,6],c,[43,5],c,[11,3],c,[10,3]])}),performAction:function parser__PerformAction(yyloc,yystate/* action[1] */,yysp,yyvstack,yylstack){/* this == yyval */ // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
var yy=this.yy;var yyparser=yy.parser;var yylexer=yy.lexer;switch(yystate){case 0:/*! Production::    $accept : Root $end */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-):
this.$=yyvstack[yysp-1];this._$=yylstack[yysp-1];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-)
break;case 1:/*! Production::    Root : %epsilon */ // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(null,null,null,null,true);// END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
return this.$=Object.assign(new yy["Root"]("",...['EMPTY']),{rule:"",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["",yylstack[yysp]]);break;case 2:/*! Production::    Root : Body */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
return this.$=new yy["Root"]("Body",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Body",yylstack[yysp-1]]);break;case 3:/*! Production::    Body : Body NEWLINE Line */case 6:/*! Production::    ClassBody : ClassBody NEWLINE ClassLine */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
this.$=yyvstack[yysp-2];this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)
(yyvstack[yysp-2][1]=[...yyvstack[yysp-2][1],Object.assign(yyvstack[yysp],{lineCount:yyvstack[yysp-1]})])&&Object.assign(yyvstack[yysp-2],{loc:{first_line:yylstack[yysp-2].first_line,last_line:yylstack[yysp].last_line,first_column:yylstack[yysp-2].first_column,last_column:yylstack[yysp].last_column}});break;case 4:/*! Production::    Body : Body NEWLINE */case 7:/*! Production::    ClassBody : ClassBody NEWLINE */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(yyvstack[yysp-1][1][yyvstack[yysp-1][1].length-1],{lineCount:yyvstack[yysp]})&&Object.assign(yyvstack[yysp-1],{loc:{first_line:yylstack[yysp-1].first_line,last_line:yylstack[yysp].last_line,first_column:yylstack[yysp-1].first_column,last_column:yylstack[yysp].last_column}});break;case 5:/*! Production::    Body : Line */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Body"]("Line",...[[yyvstack[yysp]]]),{rule:"Line",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Line",yylstack[yysp]]);break;case 8:/*! Production::    ClassBody : ClassLine */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassBody"]("ClassLine",...[[yyvstack[yysp]]]),{rule:"ClassLine",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["ClassLine",yylstack[yysp]]);break;case 9:/*! Production::    Line : Statement */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Line"]("Statement",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Statement",yylstack[yysp-1]]);break;case 10:/*! Production::    Line : Expression */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Line"]("Expression",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Expression",yylstack[yysp-1]]);break;case 11:/*! Production::    ClassLine : Statement */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ClassLine"]("Statement",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Statement",yylstack[yysp-1]]);break;case 12:/*! Production::    ClassLine : Expression */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ClassLine"]("Expression",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Expression",yylstack[yysp-1]]);break;case 13:/*! Production::    ClassLine : ClassFunction */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ClassLine"]("ClassFunction",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["ClassFunction",yylstack[yysp-1]]);break;case 14:/*! Production::    Expression : While */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Expression"]("While",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["While",yylstack[yysp-1]]);break;case 15:/*! Production::    Expression : For */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Expression"]("For",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["For",yylstack[yysp-1]]);break;case 16:/*! Production::    Expression : Switch */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Expression"]("Switch",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Switch",yylstack[yysp-1]]);break;case 17:/*! Production::    Expression : TryBlock */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Expression"]("TryBlock",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TryBlock",yylstack[yysp-1]]);break;case 18:/*! Production::    Expression : Class */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Expression"]("Class",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Class",yylstack[yysp-1]]);break;case 19:/*! Production::    Expression : Code */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Expression"]("Code",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Code",yylstack[yysp-1]]);break;case 20:/*! Production::    Expression : Label */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Expression"]("Label",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Label",yylstack[yysp-1]]);break;case 21:/*! Production::    Expression : Value */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Expression"]("Value",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Value",yylstack[yysp-1]]);break;case 22:/*! Production::    Expression : JSX */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Expression"]("JSX",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["JSX",yylstack[yysp-1]]);break;case 23:/*! Production::    Expression : If */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Expression"]("If",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["If",yylstack[yysp-1]]);break;case 24:/*! Production::    Expression : Operation */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Expression"]("Operation",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Operation",yylstack[yysp-1]]);break;case 25:/*! Production::    Expression : Assign */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Expression"]("Assign",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Assign",yylstack[yysp-1]]);break;case 26:/*! Production::    Operation : MathPrefix Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("MathPrefix Expression",...[yyvstack[yysp-1],yyvstack[yysp]]),{rule:"MathPrefix Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["MathPrefix",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 27:/*! Production::    Operation : Expression MathPostfix */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("Expression MathPostfix",...[yyvstack[yysp-1],yyvstack[yysp]]),{rule:"Expression MathPostfix",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-1]],["MathPostfix",yylstack[yysp]]);break;case 28:/*! Production::    Operation : Expression Operator Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("Expression Operator Expression",...[yyvstack[yysp-2],yyvstack[yysp-1],yyvstack[yysp]]),{rule:"Expression Operator Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-2]],["Operator",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 29:/*! Production::    Operation : "@" Value */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("@ Value",...[yyvstack[yysp]]),{rule:"@ Value",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["@",yylstack[yysp-1]],["Value",yylstack[yysp]]);break;case 30:/*! Production::    Operation : DO Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("DO Expression",...[yyvstack[yysp]]),{rule:"DO Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["DO",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 31:/*! Production::    Operation : WHETHER Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("WHETHER Expression",...[yyvstack[yysp]]),{rule:"WHETHER Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WHETHER",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 32:/*! Production::    Operation : TYPEOF Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("TYPEOF Expression",...[yyvstack[yysp]]),{rule:"TYPEOF Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TYPEOF",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 33:/*! Production::    Operation : AWAIT Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("AWAIT Expression",...[yyvstack[yysp]]),{rule:"AWAIT Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["AWAIT",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 34:/*! Production::    Operation : AWAIT INDENT Expression OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("AWAIT INDENT Expression OUTDENT",...[yyvstack[yysp-1]]),{rule:"AWAIT INDENT Expression OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["AWAIT",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 35:/*! Production::    Operation : VOID Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("VOID Expression",...[yyvstack[yysp]]),{rule:"VOID Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["VOID",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 36:/*! Production::    Operation : VOID INDENT Expression OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("VOID INDENT Expression OUTDENT",...[yyvstack[yysp-1]]),{rule:"VOID INDENT Expression OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["VOID",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 37:/*! Production::    Operation : YIELD Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("YIELD Expression",...[yyvstack[yysp]]),{rule:"YIELD Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["YIELD",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 38:/*! Production::    Operation : YIELD INDENT Expression OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("YIELD INDENT Expression OUTDENT",...[yyvstack[yysp-1]]),{rule:"YIELD INDENT Expression OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["YIELD",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 39:/*! Production::    Operation : Expression EXISTS */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("Expression EXISTS",...[yyvstack[yysp-1]]),{rule:"Expression EXISTS",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-1]],["EXISTS",yylstack[yysp]]);break;case 40:/*! Production::    Operation : Expression SYMBOL_EXISTS */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("Expression SYMBOL_EXISTS",...[yyvstack[yysp-1]]),{rule:"Expression SYMBOL_EXISTS",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-1]],["SYMBOL_EXISTS",yylstack[yysp]]);break;case 41:/*! Production::    Operation : Expression Compare Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("Expression Compare Expression",...[yyvstack[yysp-2],yyvstack[yysp-1],yyvstack[yysp]]),{rule:"Expression Compare Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-2]],["Compare",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 42:/*! Production::    Operation : Expression Logical Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("Expression Logical Expression",...[yyvstack[yysp-2],yyvstack[yysp-1],yyvstack[yysp]]),{rule:"Expression Logical Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-2]],["Logical",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 43:/*! Production::    Operation : Expression INCLUDES Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("Expression INCLUDES Expression",...[yyvstack[yysp-2],yyvstack[yysp]]),{rule:"Expression INCLUDES Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-2]],["INCLUDES",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 44:/*! Production::    Operation : Expression MATH_BIN Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("Expression MATH_BIN Expression",...[yyvstack[yysp-2],yyvstack[yysp-1],yyvstack[yysp]]),{rule:"Expression MATH_BIN Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-2]],["MATH_BIN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 45:/*! Production::    Operation : Expression Multicheck */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("Expression Multicheck",...[yyvstack[yysp-1],yyvstack[yysp].contents]),{rule:"Expression Multicheck",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-1]],["Multicheck",yylstack[yysp]]);break;case 46:/*! Production::    Operation : Multicondition */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("Multicondition",...[null,yyvstack[yysp].contents]),{rule:"Multicondition",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Multicondition",yylstack[yysp]]);break;case 47:/*! Production::    Operation : Expression CHAIN Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("Expression CHAIN Expression",...[yyvstack[yysp-2],yyvstack[yysp],/then\?|\?>/.test(yyvstack[yysp-1].origin||'')]),{rule:"Expression CHAIN Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-2]],["CHAIN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 48:/*! Production::    Operation : Expression CHAIN Block */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Operation"]("Expression CHAIN Block",...[yyvstack[yysp-2],yyvstack[yysp],/then\?|\?>/.test(yyvstack[yysp-1].origin||'')]),{rule:"Expression CHAIN Block",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-2]],["CHAIN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 49:/*! Production::    Clause : Clause COMPOUND_AND Compare Expression */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Clause"]("Clause COMPOUND_AND Compare Expression",...[...yyvstack[yysp-3].contents,[yyvstack[yysp],yyvstack[yysp-1]]]),{rule:"Clause COMPOUND_AND Compare Expression",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Clause",yylstack[yysp-3]],["COMPOUND_AND",yylstack[yysp-2]],["Compare",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 50:/*! Production::    Clause : Expression */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Clause"]("Expression",...[[yyvstack[yysp]]]),{rule:"Expression",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Expression",yylstack[yysp]]);break;case 51:/*! Production::    Clause : Compare Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Clause"]("Compare Expression",...[[yyvstack[yysp],yyvstack[yysp-1]]]),{rule:"Compare Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Compare",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 52:/*! Production::    MathPrefix : "++" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["MathPrefix"]("++",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["++",yylstack[yysp-1]]);break;case 53:/*! Production::    MathPrefix : "--" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["MathPrefix"]("--",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["--",yylstack[yysp-1]]);break;case 54:/*! Production::    MathPrefix : "+" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["MathPrefix"]("+",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["+",yylstack[yysp-1]]);break;case 55:/*! Production::    MathPrefix : "-" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["MathPrefix"]("-",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["-",yylstack[yysp-1]]);break;case 56:/*! Production::    MathPrefix : "~" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["MathPrefix"]("~",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["~",yylstack[yysp-1]]);break;case 57:/*! Production::    MathPrefix : "~~" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["MathPrefix"]("~~",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["~~",yylstack[yysp-1]]);break;case 58:/*! Production::    MathPrefix : NOT */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["MathPrefix"]("NOT",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["NOT",yylstack[yysp-1]]);break;case 59:/*! Production::    MathPrefix : "!" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["MathPrefix"]("!",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["!",yylstack[yysp-1]]);break;case 60:/*! Production::    MathPostfix : "++" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["MathPostfix"]("++",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["++",yylstack[yysp-1]]);break;case 61:/*! Production::    MathPostfix : "--" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["MathPostfix"]("--",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["--",yylstack[yysp-1]]);break;case 62:/*! Production::    Operator : "*" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Operator"]("*",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["*",yylstack[yysp-1]]);break;case 63:/*! Production::    Operator : "**" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Operator"]("**",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["**",yylstack[yysp-1]]);break;case 64:/*! Production::    Operator : "+" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Operator"]("+",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["+",yylstack[yysp-1]]);break;case 65:/*! Production::    Operator : PLUS */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Operator"]("PLUS",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["PLUS",yylstack[yysp-1]]);break;case 66:/*! Production::    Operator : "-" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Operator"]("-",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["-",yylstack[yysp-1]]);break;case 67:/*! Production::    Operator : DIVISION */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Operator"]("DIVISION",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["DIVISION",yylstack[yysp-1]]);break;case 68:/*! Production::    Operator : "%" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Operator"]("%",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["%",yylstack[yysp-1]]);break;case 69:/*! Production::    Operator : "<<" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Operator"]("<<",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["<<",yylstack[yysp-1]]);break;case 70:/*! Production::    Operator : ">>" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Operator"](">>",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens([">>",yylstack[yysp-1]]);break;case 71:/*! Production::    Operator : ">>>" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Operator"](">>>",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens([">>>",yylstack[yysp-1]]);break;case 72:/*! Production::    Operator : "^" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Operator"]("^",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["^",yylstack[yysp-1]]);break;case 73:/*! Production::    Compare : IS */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Compare"]("IS",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["IS",yylstack[yysp-1]]);break;case 74:/*! Production::    Compare : "===" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Compare"]("===",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["===",yylstack[yysp-1]]);break;case 75:/*! Production::    Compare : ISNT */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Compare"]("ISNT",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["ISNT",yylstack[yysp-1]]);break;case 76:/*! Production::    Compare : "!==" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Compare"]("!==",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["!==",yylstack[yysp-1]]);break;case 77:/*! Production::    Compare : "==" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Compare"]("==",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["==",yylstack[yysp-1]]);break;case 78:/*! Production::    Compare : "!=" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Compare"]("!=",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["!=",yylstack[yysp-1]]);break;case 79:/*! Production::    Compare : ">=" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Compare"](">=",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens([">=",yylstack[yysp-1]]);break;case 80:/*! Production::    Compare : "<=" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Compare"]("<=",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["<=",yylstack[yysp-1]]);break;case 81:/*! Production::    Compare : ">" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Compare"](">",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens([">",yylstack[yysp-1]]);break;case 82:/*! Production::    Compare : "<" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Compare"]("<",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["<",yylstack[yysp-1]]);break;case 83:/*! Production::    Compare : INSTANCEOF */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Compare"]("INSTANCEOF",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["INSTANCEOF",yylstack[yysp-1]]);break;case 84:/*! Production::    Logical : AND */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Logical"]("AND",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["AND",yylstack[yysp-1]]);break;case 85:/*! Production::    Logical : OR */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Logical"]("OR",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["OR",yylstack[yysp-1]]);break;case 86:/*! Production::    Logical : "||" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Logical"]("||",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["||",yylstack[yysp-1]]);break;case 87:/*! Production::    Logical : "&&" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Logical"]("&&",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["&&",yylstack[yysp-1]]);break;case 88:/*! Production::    Logical : "|" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Logical"]("|",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["|",yylstack[yysp-1]]);break;case 89:/*! Production::    Logical : "&" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Logical"]("&",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["&",yylstack[yysp-1]]);break;case 90:/*! Production::    Logical : "??" */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Logical"]("??",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["??",yylstack[yysp-1]]);break;case 91:/*! Production::    Multicheck : MulticheckCombinations MulticheckClauses */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Multicheck"]("MulticheckCombinations MulticheckClauses",...[yyvstack[yysp-1].rule,yyvstack[yysp]]),{rule:"MulticheckCombinations MulticheckClauses",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["MulticheckCombinations",yylstack[yysp-1]],["MulticheckClauses",yylstack[yysp]]);break;case 92:/*! Production::    Multicondition : EITHER MulticheckClauses */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Multicondition"]("EITHER MulticheckClauses",...[yyvstack[yysp-1],yyvstack[yysp]]),{rule:"EITHER MulticheckClauses",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["EITHER",yylstack[yysp-1]],["MulticheckClauses",yylstack[yysp]]);break;case 93:/*! Production::    MulticheckCombinations : IS EITHER */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["MulticheckCombinations"]("IS EITHER",...[yyvstack[yysp-1]]).setLocation({first_line:yylstack[yysp-1].first_line,first_column:yylstack[yysp-1].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp-1].src,type:yylstack[yysp-1].type}).setTokens(["IS",yylstack[yysp-2]],["EITHER",yylstack[yysp-1]]);break;case 94:/*! Production::    MulticheckCombinations : ISNT EITHER */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["MulticheckCombinations"]("ISNT EITHER",...[yyvstack[yysp-1]]).setLocation({first_line:yylstack[yysp-1].first_line,first_column:yylstack[yysp-1].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp-1].src,type:yylstack[yysp-1].type}).setTokens(["ISNT",yylstack[yysp-2]],["EITHER",yylstack[yysp-1]]);break;case 95:/*! Production::    MulticheckClauses : MulticheckClauses EITHER_OR Clause */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["MulticheckClauses"]("MulticheckClauses EITHER_OR Clause",...[...yyvstack[yysp-2].contents,yyvstack[yysp]]),{rule:"MulticheckClauses EITHER_OR Clause",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["MulticheckClauses",yylstack[yysp-2]],["EITHER_OR",yylstack[yysp-1]],["Clause",yylstack[yysp]]);break;case 96:/*! Production::    MulticheckClauses : Clause */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["MulticheckClauses"]("Clause",...[yyvstack[yysp]]),{rule:"Clause",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Clause",yylstack[yysp]]);break;case 97:/*! Production::    Block : "{{" "}}" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Block"]("{{ }}",...[yy.Block.wrap()]),{rule:"{{ }}",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{{",yylstack[yysp-1]],["}}",yylstack[yysp]]);break;case 98:/*! Production::    Block : INDENT OUTDENT */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Block"]("INDENT OUTDENT",...[yy.Block.wrap()]),{rule:"INDENT OUTDENT",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["INDENT",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 99:/*! Production::    Block : "{{" INDENT OUTDENT "}}" */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Block"]("{{ INDENT OUTDENT }}",...[yy.Block.wrap()]),{rule:"{{ INDENT OUTDENT }}",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{{",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["}}",yylstack[yysp]]);break;case 100:/*! Production::    Block : INDENT Body OUTDENT */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Block"]("INDENT Body OUTDENT",...[yyvstack[yysp-1]]),{rule:"INDENT Body OUTDENT",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["INDENT",yylstack[yysp-2]],["Body",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 101:/*! Production::    Block : "{{" INDENT Body OUTDENT "}}" */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Block"]("{{ INDENT Body OUTDENT }}",...[yyvstack[yysp-2]]),{rule:"{{ INDENT Body OUTDENT }}",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{{",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["Body",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["}}",yylstack[yysp]]);break;case 102:/*! Production::    Block : "{" Body "}" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Block"]("{ Body }",...[yyvstack[yysp-1]]),{rule:"{ Body }",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{",yylstack[yysp-2]],["Body",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 103:/*! Production::    Code : FUNC_DIRECTIVE Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("FUNC_DIRECTIVE Expression",...[null,yyvstack[yysp-1],yyvstack[yysp]]),{rule:"FUNC_DIRECTIVE Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FUNC_DIRECTIVE",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 104:/*! Production::    Code : WITHIN PARAM_START ParamList PARAM_END Block */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("WITHIN PARAM_START ParamList PARAM_END Block",...[yyvstack[yysp-2],'=>',yyvstack[yysp]]),{rule:"WITHIN PARAM_START ParamList PARAM_END Block",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WITHIN",yylstack[yysp-4]],["PARAM_START",yylstack[yysp-3]],["ParamList",yylstack[yysp-2]],["PARAM_END",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 105:/*! Production::    Code : PARAM_START ParamList PARAM_END FUNC_DIRECTIVE Block */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("PARAM_START ParamList PARAM_END FUNC_DIRECTIVE Block",...[yyvstack[yysp-3],yyvstack[yysp-1],yyvstack[yysp]]),{rule:"PARAM_START ParamList PARAM_END FUNC_DIRECTIVE Block",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PARAM_START",yylstack[yysp-4]],["ParamList",yylstack[yysp-3]],["PARAM_END",yylstack[yysp-2]],["FUNC_DIRECTIVE",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 106:/*! Production::    Code : PARAM_START PARAM_END FUNC_DIRECTIVE Block */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("PARAM_START PARAM_END FUNC_DIRECTIVE Block",...[null,yyvstack[yysp-1],yyvstack[yysp]]),{rule:"PARAM_START PARAM_END FUNC_DIRECTIVE Block",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PARAM_START",yylstack[yysp-3]],["PARAM_END",yylstack[yysp-2]],["FUNC_DIRECTIVE",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 107:/*! Production::    Code : PARAM_START ParamList PARAM_END FUNC_DIRECTIVE Expression */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("PARAM_START ParamList PARAM_END FUNC_DIRECTIVE Expression",...[yyvstack[yysp-3],yyvstack[yysp-1],yyvstack[yysp]]),{rule:"PARAM_START ParamList PARAM_END FUNC_DIRECTIVE Expression",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PARAM_START",yylstack[yysp-4]],["ParamList",yylstack[yysp-3]],["PARAM_END",yylstack[yysp-2]],["FUNC_DIRECTIVE",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 108:/*! Production::    Code : PARAM_START PARAM_END FUNC_DIRECTIVE Expression */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("PARAM_START PARAM_END FUNC_DIRECTIVE Expression",...[null,yyvstack[yysp-1],yyvstack[yysp]]),{rule:"PARAM_START PARAM_END FUNC_DIRECTIVE Expression",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PARAM_START",yylstack[yysp-3]],["PARAM_END",yylstack[yysp-2]],["FUNC_DIRECTIVE",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 109:/*! Production::    Code : WITHIN PARAM_START ParamList PARAM_END THEN Block */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("WITHIN PARAM_START ParamList PARAM_END THEN Block",...[yyvstack[yysp-3],'=>',yyvstack[yysp-1]]),{rule:"WITHIN PARAM_START ParamList PARAM_END THEN Block",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WITHIN",yylstack[yysp-5]],["PARAM_START",yylstack[yysp-4]],["ParamList",yylstack[yysp-3]],["PARAM_END",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 110:/*! Production::    Code : WITHIN PARAM_START ParamList PARAM_END Expression */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("WITHIN PARAM_START ParamList PARAM_END Expression",...[yyvstack[yysp-2],'=>',yyvstack[yysp]]),{rule:"WITHIN PARAM_START ParamList PARAM_END Expression",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WITHIN",yylstack[yysp-4]],["PARAM_START",yylstack[yysp-3]],["ParamList",yylstack[yysp-2]],["PARAM_END",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 111:/*! Production::    Code : WITHIN PARAM_START ParamList PARAM_END THEN Expression */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("WITHIN PARAM_START ParamList PARAM_END THEN Expression",...[yyvstack[yysp-3],'=>',yyvstack[yysp]]),{rule:"WITHIN PARAM_START ParamList PARAM_END THEN Expression",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WITHIN",yylstack[yysp-5]],["PARAM_START",yylstack[yysp-4]],["ParamList",yylstack[yysp-3]],["PARAM_END",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 112:/*! Production::    Code : WITHIN PARAM_START PARAM_END Block */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("WITHIN PARAM_START PARAM_END Block",...[null,'=>',yyvstack[yysp]]),{rule:"WITHIN PARAM_START PARAM_END Block",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WITHIN",yylstack[yysp-3]],["PARAM_START",yylstack[yysp-2]],["PARAM_END",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 113:/*! Production::    Code : WITHIN PARAM_START PARAM_END THEN Block */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("WITHIN PARAM_START PARAM_END THEN Block",...[null,'=>',yyvstack[yysp]]),{rule:"WITHIN PARAM_START PARAM_END THEN Block",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WITHIN",yylstack[yysp-4]],["PARAM_START",yylstack[yysp-3]],["PARAM_END",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 114:/*! Production::    Code : WITHIN PARAM_START PARAM_END Expression */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("WITHIN PARAM_START PARAM_END Expression",...[null,'=>',yyvstack[yysp]]),{rule:"WITHIN PARAM_START PARAM_END Expression",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WITHIN",yylstack[yysp-3]],["PARAM_START",yylstack[yysp-2]],["PARAM_END",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 115:/*! Production::    Code : WITHIN PARAM_START PARAM_END THEN Expression */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("WITHIN PARAM_START PARAM_END THEN Expression",...[null,'=>',yyvstack[yysp]]),{rule:"WITHIN PARAM_START PARAM_END THEN Expression",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WITHIN",yylstack[yysp-4]],["PARAM_START",yylstack[yysp-3]],["PARAM_END",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 116:/*! Production::    Code : WITHIN Block */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("WITHIN Block",...[null,'=>',yyvstack[yysp]]),{rule:"WITHIN Block",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WITHIN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 117:/*! Production::    Code : ASYNC Code */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Code"]("ASYNC Code",...[...yyvstack[yysp].contents]),{rule:"ASYNC Code",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false,"async":true},{generated:undefined}).setTokens(["ASYNC",yylstack[yysp-1]],["Code",yylstack[yysp]]);break;case 118:/*! Production::    Label : USING Identifier THEN Expression */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Label"]("USING Identifier THEN Expression",...[yyvstack[yysp-2],yy.Block.wrap(yyvstack[yysp])]),{rule:"USING Identifier THEN Expression",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["USING",yylstack[yysp-3]],["Identifier",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 119:/*! Production::    Label : USING Identifier THEN Statement */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Label"]("USING Identifier THEN Statement",...[yyvstack[yysp-2],yy.Block.wrap(yyvstack[yysp])]),{rule:"USING Identifier THEN Statement",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["USING",yylstack[yysp-3]],["Identifier",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Statement",yylstack[yysp]]);break;case 120:/*! Production::    Label : USING Identifier Block */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Label"]("USING Identifier Block",...[yyvstack[yysp-1],yyvstack[yysp]]),{rule:"USING Identifier Block",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["USING",yylstack[yysp-2]],["Identifier",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 121:/*! Production::    Class : CLASS Identifier ClassConstructor? ClassImplements? */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Class"]("CLASS Identifier ClassConstructor? ClassImplements?",...[yyvstack[yysp-2],false,false,yylstack[yysp-3].origin==="class*",yyvstack[yysp-1].unwrap,yyvstack[yysp].unwrap]),{rule:"CLASS Identifier ClassConstructor? ClassImplements?",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp-2]&&yylstack[yysp-2].last_line,last_column:yylstack[yysp-2]&&yylstack[yysp-2].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CLASS",yylstack[yysp-3]],["Identifier",yylstack[yysp-2]],["ClassConstructor?",yylstack[yysp-1]],["ClassImplements?",yylstack[yysp]]);break;case 122:/*! Production::    Class : CLASS Identifier ClassConstructor? ClassImplements? ClassBlock */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Class"]("CLASS Identifier ClassConstructor? ClassImplements? ClassBlock",...[yyvstack[yysp-3],false,yyvstack[yysp][1],yylstack[yysp-4].origin==="class*",yyvstack[yysp-2].unwrap,yyvstack[yysp-1].unwrap]),{rule:"CLASS Identifier ClassConstructor? ClassImplements? ClassBlock",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CLASS",yylstack[yysp-4]],["Identifier",yylstack[yysp-3]],["ClassConstructor?",yylstack[yysp-2]],["ClassImplements?",yylstack[yysp-1]],["ClassBlock",yylstack[yysp]]);break;case 123:/*! Production::    Class : CLASS Identifier ClassConstructor? ClassImplements? THEN ClassBlock */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Class"]("CLASS Identifier ClassConstructor? ClassImplements? THEN ClassBlock",...[yyvstack[yysp-4],false,yyvstack[yysp][1],yylstack[yysp-5].origin==="class*",yyvstack[yysp-3].unwrap,yyvstack[yysp-2].unwrap]),{rule:"CLASS Identifier ClassConstructor? ClassImplements? THEN ClassBlock",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CLASS",yylstack[yysp-5]],["Identifier",yylstack[yysp-4]],["ClassConstructor?",yylstack[yysp-3]],["ClassImplements?",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["ClassBlock",yylstack[yysp]]);break;case 124:/*! Production::    Class : CLASS ClassConstructor? ClassImplements? ClassBlock */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Class"]("CLASS ClassConstructor? ClassImplements? ClassBlock",...[undefined,false,yyvstack[yysp][1],yylstack[yysp-3].origin==="class*",yyvstack[yysp-2].unwrap,yyvstack[yysp-1].unwrap]),{rule:"CLASS ClassConstructor? ClassImplements? ClassBlock",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CLASS",yylstack[yysp-3]],["ClassConstructor?",yylstack[yysp-2]],["ClassImplements?",yylstack[yysp-1]],["ClassBlock",yylstack[yysp]]);break;case 125:/*! Production::    Class : CLASS ClassConstructor? ClassImplements? THEN ClassBlock */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Class"]("CLASS ClassConstructor? ClassImplements? THEN ClassBlock",...[undefined,false,yyvstack[yysp][1],yylstack[yysp-4].origin==="class*",yyvstack[yysp-3].unwrap,yyvstack[yysp-2].unwrap]),{rule:"CLASS ClassConstructor? ClassImplements? THEN ClassBlock",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CLASS",yylstack[yysp-4]],["ClassConstructor?",yylstack[yysp-3]],["ClassImplements?",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["ClassBlock",yylstack[yysp]]);break;case 126:/*! Production::    Class : CLASS Identifier ClassConstructor? EXTENDS Value ClassImplements? ClassBlock */ // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-6,yysp);// END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Class"]("CLASS Identifier ClassConstructor? EXTENDS Value ClassImplements? ClassBlock",...[yyvstack[yysp-5],yyvstack[yysp-2],yyvstack[yysp][1],yylstack[yysp-6].origin==="class*",yyvstack[yysp-4].unwrap,yyvstack[yysp-1].unwrap]),{rule:"CLASS Identifier ClassConstructor? EXTENDS Value ClassImplements? ClassBlock",loc:{first_line:yylstack[yysp-6]&&yylstack[yysp-6].first_line,first_column:yylstack[yysp-6]&&yylstack[yysp-6].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-6]&&yylstack[yysp-6].src,type:yylstack[yysp-6]&&yylstack[yysp-6].type||yylstack[yysp-6]&&yylstack[yysp-6].type}},{"first":1,"last":7,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CLASS",yylstack[yysp-6]],["Identifier",yylstack[yysp-5]],["ClassConstructor?",yylstack[yysp-4]],["EXTENDS",yylstack[yysp-3]],["Value",yylstack[yysp-2]],["ClassImplements?",yylstack[yysp-1]],["ClassBlock",yylstack[yysp]]);break;case 127:/*! Production::    Class : CLASS Identifier ClassConstructor? EXTENDS Value ClassImplements? THEN ClassBlock */ // default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-7,yysp);// END of default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Class"]("CLASS Identifier ClassConstructor? EXTENDS Value ClassImplements? THEN ClassBlock",...[yyvstack[yysp-6],yyvstack[yysp-3],yyvstack[yysp][1],yylstack[yysp-7].origin==="class*",yyvstack[yysp-5].unwrap,yyvstack[yysp-2].unwrap]),{rule:"CLASS Identifier ClassConstructor? EXTENDS Value ClassImplements? THEN ClassBlock",loc:{first_line:yylstack[yysp-7]&&yylstack[yysp-7].first_line,first_column:yylstack[yysp-7]&&yylstack[yysp-7].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-7]&&yylstack[yysp-7].src,type:yylstack[yysp-7]&&yylstack[yysp-7].type||yylstack[yysp-7]&&yylstack[yysp-7].type}},{"first":1,"last":8,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CLASS",yylstack[yysp-7]],["Identifier",yylstack[yysp-6]],["ClassConstructor?",yylstack[yysp-5]],["EXTENDS",yylstack[yysp-4]],["Value",yylstack[yysp-3]],["ClassImplements?",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["ClassBlock",yylstack[yysp]]);break;case 128:/*! Production::    Class : CLASS ClassConstructor? EXTENDS Value ClassImplements? ClassBlock */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Class"]("CLASS ClassConstructor? EXTENDS Value ClassImplements? ClassBlock",...[undefined,yyvstack[yysp-2],yyvstack[yysp][1],yylstack[yysp-5].origin==="class*",yyvstack[yysp-4].unwrap,yyvstack[yysp-1].unwrap]),{rule:"CLASS ClassConstructor? EXTENDS Value ClassImplements? ClassBlock",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CLASS",yylstack[yysp-5]],["ClassConstructor?",yylstack[yysp-4]],["EXTENDS",yylstack[yysp-3]],["Value",yylstack[yysp-2]],["ClassImplements?",yylstack[yysp-1]],["ClassBlock",yylstack[yysp]]);break;case 129:/*! Production::    Class : CLASS Identifier ClassConstructor? EXTENDS Value ClassImplements? */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Class"]("CLASS Identifier ClassConstructor? EXTENDS Value ClassImplements?",...[yyvstack[yysp-4],yyvstack[yysp-1],false,yylstack[yysp-5].origin==="class*",yyvstack[yysp-3].unwrap,yyvstack[yysp].unwrap]),{rule:"CLASS Identifier ClassConstructor? EXTENDS Value ClassImplements?",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CLASS",yylstack[yysp-5]],["Identifier",yylstack[yysp-4]],["ClassConstructor?",yylstack[yysp-3]],["EXTENDS",yylstack[yysp-2]],["Value",yylstack[yysp-1]],["ClassImplements?",yylstack[yysp]]);break;case 130:/*! Production::    Class : CLASS ClassConstructor? EXTENDS Value ClassImplements? */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Class"]("CLASS ClassConstructor? EXTENDS Value ClassImplements?",...[undefined,yyvstack[yysp-1],false,yylstack[yysp-4].origin==="class*",yyvstack[yysp-3].unwrap,yyvstack[yysp].unwrap]),{rule:"CLASS ClassConstructor? EXTENDS Value ClassImplements?",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CLASS",yylstack[yysp-4]],["ClassConstructor?",yylstack[yysp-3]],["EXTENDS",yylstack[yysp-2]],["Value",yylstack[yysp-1]],["ClassImplements?",yylstack[yysp]]);break;case 131:/*! Production::    Class : CLASS ClassConstructor? EXTENDS Value ClassImplements? THEN ClassBlock */ // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-6,yysp);// END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Class"]("CLASS ClassConstructor? EXTENDS Value ClassImplements? THEN ClassBlock",...[undefined,yyvstack[yysp-3],yyvstack[yysp][1],yylstack[yysp-6].origin==="class*",yyvstack[yysp-5].unwrap,yyvstack[yysp-2].unwrap]),{rule:"CLASS ClassConstructor? EXTENDS Value ClassImplements? THEN ClassBlock",loc:{first_line:yylstack[yysp-6]&&yylstack[yysp-6].first_line,first_column:yylstack[yysp-6]&&yylstack[yysp-6].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-6]&&yylstack[yysp-6].src,type:yylstack[yysp-6]&&yylstack[yysp-6].type||yylstack[yysp-6]&&yylstack[yysp-6].type}},{"first":1,"last":7,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CLASS",yylstack[yysp-6]],["ClassConstructor?",yylstack[yysp-5]],["EXTENDS",yylstack[yysp-4]],["Value",yylstack[yysp-3]],["ClassImplements?",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["ClassBlock",yylstack[yysp]]);break;case 132:/*! Production::    Class : CLASS ClassConstructor? ClassImplements? */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Class"]("CLASS ClassConstructor? ClassImplements?",...[,,,yylstack[yysp-2].origin==="class*",yyvstack[yysp-1].unwrap,yyvstack[yysp].unwrap]),{rule:"CLASS ClassConstructor? ClassImplements?",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp-2]&&yylstack[yysp-2].last_line,last_column:yylstack[yysp-2]&&yylstack[yysp-2].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CLASS",yylstack[yysp-2]],["ClassConstructor?",yylstack[yysp-1]],["ClassImplements?",yylstack[yysp]]);break;case 133:/*! Production::    ClassBlock : "{{" "}}" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassBlock"]("{{ }}",...[yy.Block.wrap()]),{rule:"{{ }}",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{{",yylstack[yysp-1]],["}}",yylstack[yysp]]);break;case 134:/*! Production::    ClassBlock : INDENT OUTDENT */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassBlock"]("INDENT OUTDENT",...[yy.Block.wrap()]),{rule:"INDENT OUTDENT",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["INDENT",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 135:/*! Production::    ClassBlock : "{{" INDENT OUTDENT "}}" */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassBlock"]("{{ INDENT OUTDENT }}",...[yy.Block.wrap()]),{rule:"{{ INDENT OUTDENT }}",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{{",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["}}",yylstack[yysp]]);break;case 136:/*! Production::    ClassBlock : INDENT ClassBody OUTDENT */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassBlock"]("INDENT ClassBody OUTDENT",...[yyvstack[yysp-1]]),{rule:"INDENT ClassBody OUTDENT",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["INDENT",yylstack[yysp-2]],["ClassBody",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 137:/*! Production::    ClassBlock : "{{" INDENT ClassBody OUTDENT "}}" */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassBlock"]("{{ INDENT ClassBody OUTDENT }}",...[yyvstack[yysp-2]]),{rule:"{{ INDENT ClassBody OUTDENT }}",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{{",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["ClassBody",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["}}",yylstack[yysp]]);break;case 138:/*! Production::    ClassBlock : "{" ClassBody "}" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassBlock"]("{ ClassBody }",...[yyvstack[yysp-1]]),{rule:"{ ClassBody }",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{",yylstack[yysp-2]],["ClassBody",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 139:/*! Production::    ClassConstructor? : %epsilon */ // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(null,null,null,null,true);// END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassConstructor?"]("",...[undefined]),{rule:"",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src}},{"first":0,"last":0,"typeOf":0,"checkGenerated":false},{generated:undefined}).setTokens();break;case 140:/*! Production::    ClassConstructor? : "<(" TypeArguments ")>" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassConstructor?"]("<( TypeArguments )>",...[{args:yyvstack[yysp-1]}]),{rule:"<( TypeArguments )>",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["<(",yylstack[yysp-2]],["TypeArguments",yylstack[yysp-1]],[")>",yylstack[yysp]]);break;case 141:/*! Production::    ClassConstructor? : TypeArguments? WITH Params */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassConstructor?"]("TypeArguments? WITH Params",...[{args:yyvstack[yysp-2].unwrap,ctor:yyvstack[yysp]}]),{rule:"TypeArguments? WITH Params",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":2,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeArguments?",yylstack[yysp-2]],["WITH",yylstack[yysp-1]],["Params",yylstack[yysp]]);break;case 142:/*! Production::    ClassConstructor? : TypeArguments? Params */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassConstructor?"]("TypeArguments? Params",...[{args:yyvstack[yysp-1].unwrap,ctor:yyvstack[yysp]}]),{rule:"TypeArguments? Params",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp]&&yylstack[yysp].type}},{"first":2,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeArguments?",yylstack[yysp-1]],["Params",yylstack[yysp]]);break;case 143:/*! Production::    ForExpression : JointExpression */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ForExpression"]("JointExpression",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["JointExpression",yylstack[yysp-1]]);break;case 144:/*! Production::    ForExpression : Declare */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ForExpression"]("Declare",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Declare",yylstack[yysp-1]]);break;case 145:/*! Production::    JointExpression : Expression */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["JointExpression"]("Expression",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Expression",yylstack[yysp-1]]);break;case 146:/*! Production::    JointExpression : JointExpression "," Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["JointExpression"]("JointExpression , Expression",...[...yyvstack[yysp-2].contents,yyvstack[yysp]]),{rule:"JointExpression , Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["JointExpression",yylstack[yysp-2]],[",",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 147:/*! Production::    For : FOR ForExpression ";" Expression ";" Expression Block */ // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-6,yysp);// END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR ForExpression ; Expression ; Expression Block",...[[yyvstack[yysp-5],yyvstack[yysp-3],yyvstack[yysp-1]],yyvstack[yysp]]),{rule:"FOR ForExpression ; Expression ; Expression Block",loc:{first_line:yylstack[yysp-6]&&yylstack[yysp-6].first_line,first_column:yylstack[yysp-6]&&yylstack[yysp-6].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-6]&&yylstack[yysp-6].src,type:yylstack[yysp-6]&&yylstack[yysp-6].type||yylstack[yysp-6]&&yylstack[yysp-6].type}},{"first":1,"last":7,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-6]],["ForExpression",yylstack[yysp-5]],[";",yylstack[yysp-4]],["Expression",yylstack[yysp-3]],[";",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 148:/*! Production::    For : FOR ForExpression ";" Expression ";" Expression THEN Block */ // default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-7,yysp);// END of default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR ForExpression ; Expression ; Expression THEN Block",...[[yyvstack[yysp-6],yyvstack[yysp-4],yyvstack[yysp-2]],yyvstack[yysp]]),{rule:"FOR ForExpression ; Expression ; Expression THEN Block",loc:{first_line:yylstack[yysp-7]&&yylstack[yysp-7].first_line,first_column:yylstack[yysp-7]&&yylstack[yysp-7].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-7]&&yylstack[yysp-7].src,type:yylstack[yysp-7]&&yylstack[yysp-7].type||yylstack[yysp-7]&&yylstack[yysp-7].type}},{"first":1,"last":8,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-7]],["ForExpression",yylstack[yysp-6]],[";",yylstack[yysp-5]],["Expression",yylstack[yysp-4]],[";",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 149:/*! Production::    For : FOR ForExpression ";" Expression ";" Expression THEN Expression */ // default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-7,yysp);// END of default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR ForExpression ; Expression ; Expression THEN Expression",...[[yyvstack[yysp-6],yyvstack[yysp-4],yyvstack[yysp-2]],yy.Block.wrap(yyvstack[yysp])]),{rule:"FOR ForExpression ; Expression ; Expression THEN Expression",loc:{first_line:yylstack[yysp-7]&&yylstack[yysp-7].first_line,first_column:yylstack[yysp-7]&&yylstack[yysp-7].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-7]&&yylstack[yysp-7].src,type:yylstack[yysp-7]&&yylstack[yysp-7].type||yylstack[yysp-7]&&yylstack[yysp-7].type}},{"first":1,"last":8,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-7]],["ForExpression",yylstack[yysp-6]],[";",yylstack[yysp-5]],["Expression",yylstack[yysp-4]],[";",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 150:/*! Production::    For : FOR ForExpression WHEN Expression WHILST Expression Block */ // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-6,yysp);// END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR ForExpression WHEN Expression WHILST Expression Block",...[[yyvstack[yysp-5],yyvstack[yysp-3],yyvstack[yysp-1]],yyvstack[yysp]]),{rule:"FOR ForExpression WHEN Expression WHILST Expression Block",loc:{first_line:yylstack[yysp-6]&&yylstack[yysp-6].first_line,first_column:yylstack[yysp-6]&&yylstack[yysp-6].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-6]&&yylstack[yysp-6].src,type:yylstack[yysp-6]&&yylstack[yysp-6].type||yylstack[yysp-6]&&yylstack[yysp-6].type}},{"first":1,"last":7,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-6]],["ForExpression",yylstack[yysp-5]],["WHEN",yylstack[yysp-4]],["Expression",yylstack[yysp-3]],["WHILST",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 151:/*! Production::    For : FOR ForExpression WHEN Expression WHILST Expression THEN Block */ // default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-7,yysp);// END of default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR ForExpression WHEN Expression WHILST Expression THEN Block",...[[yyvstack[yysp-6],yyvstack[yysp-4],yyvstack[yysp-2]],yyvstack[yysp]]),{rule:"FOR ForExpression WHEN Expression WHILST Expression THEN Block",loc:{first_line:yylstack[yysp-7]&&yylstack[yysp-7].first_line,first_column:yylstack[yysp-7]&&yylstack[yysp-7].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-7]&&yylstack[yysp-7].src,type:yylstack[yysp-7]&&yylstack[yysp-7].type||yylstack[yysp-7]&&yylstack[yysp-7].type}},{"first":1,"last":8,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-7]],["ForExpression",yylstack[yysp-6]],["WHEN",yylstack[yysp-5]],["Expression",yylstack[yysp-4]],["WHILST",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 152:/*! Production::    For : FOR ForExpression WHEN Expression WHILST Expression THEN Expression */ // default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-7,yysp);// END of default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR ForExpression WHEN Expression WHILST Expression THEN Expression",...[[yyvstack[yysp-6],yyvstack[yysp-4],yyvstack[yysp-2]],yy.Block.wrap(yyvstack[yysp])]),{rule:"FOR ForExpression WHEN Expression WHILST Expression THEN Expression",loc:{first_line:yylstack[yysp-7]&&yylstack[yysp-7].first_line,first_column:yylstack[yysp-7]&&yylstack[yysp-7].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-7]&&yylstack[yysp-7].src,type:yylstack[yysp-7]&&yylstack[yysp-7].type||yylstack[yysp-7]&&yylstack[yysp-7].type}},{"first":1,"last":8,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-7]],["ForExpression",yylstack[yysp-6]],["WHEN",yylstack[yysp-5]],["Expression",yylstack[yysp-4]],["WHILST",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 153:/*! Production::    For : FOR ForAssignable FOR_OF Expression Block */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR ForAssignable FOR_OF Expression Block",...[[yyvstack[yysp-3][1],yyvstack[yysp-2],yyvstack[yysp-1]],yyvstack[yysp],yyvstack[yysp-3][2]]),{rule:"FOR ForAssignable FOR_OF Expression Block",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-4]],["ForAssignable",yylstack[yysp-3]],["FOR_OF",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 154:/*! Production::    For : FOR ForAssignable FOR_IN Expression Block */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR ForAssignable FOR_IN Expression Block",...[[yyvstack[yysp-3][1],yyvstack[yysp-2],yyvstack[yysp-1]],yyvstack[yysp],yyvstack[yysp-3][2]]),{rule:"FOR ForAssignable FOR_IN Expression Block",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-4]],["ForAssignable",yylstack[yysp-3]],["FOR_IN",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 155:/*! Production::    For : FOR ForAssignable FOR_OF Expression THEN Block */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR ForAssignable FOR_OF Expression THEN Block",...[[yyvstack[yysp-4][1],yyvstack[yysp-3],yyvstack[yysp-2]],yyvstack[yysp],yyvstack[yysp-4][2]]),{rule:"FOR ForAssignable FOR_OF Expression THEN Block",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-5]],["ForAssignable",yylstack[yysp-4]],["FOR_OF",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 156:/*! Production::    For : FOR ForAssignable FOR_IN Expression THEN Block */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR ForAssignable FOR_IN Expression THEN Block",...[[yyvstack[yysp-4][1],yyvstack[yysp-3],yyvstack[yysp-2]],yyvstack[yysp],yyvstack[yysp-4][2]]),{rule:"FOR ForAssignable FOR_IN Expression THEN Block",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-5]],["ForAssignable",yylstack[yysp-4]],["FOR_IN",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 157:/*! Production::    For : FOR ForAssignable FOR_OF Expression THEN Expression */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR ForAssignable FOR_OF Expression THEN Expression",...[[yyvstack[yysp-4][1],yyvstack[yysp-3],yyvstack[yysp-2]],yy.Block.wrap(yyvstack[yysp]),yyvstack[yysp-4][2]]),{rule:"FOR ForAssignable FOR_OF Expression THEN Expression",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-5]],["ForAssignable",yylstack[yysp-4]],["FOR_OF",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 158:/*! Production::    For : FOR ForAssignable FOR_IN Expression THEN Expression */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR ForAssignable FOR_IN Expression THEN Expression",...[[yyvstack[yysp-4][1],yyvstack[yysp-3],yyvstack[yysp-2]],yy.Block.wrap(yyvstack[yysp]),yyvstack[yysp-4][2]]),{rule:"FOR ForAssignable FOR_IN Expression THEN Expression",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-5]],["ForAssignable",yylstack[yysp-4]],["FOR_IN",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 159:/*! Production::    For : FOR Identifier "," Assignable ForAny Expression THEN Expression */ // default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-7,yysp);// END of default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR Identifier , Assignable ForAny Expression THEN Expression",...[[[yyvstack[yysp-6],yyvstack[yysp-4]],yyvstack[yysp-3],yyvstack[yysp-2]],yy.Block.wrap(yyvstack[yysp])]),{rule:"FOR Identifier , Assignable ForAny Expression THEN Expression",loc:{first_line:yylstack[yysp-7]&&yylstack[yysp-7].first_line,first_column:yylstack[yysp-7]&&yylstack[yysp-7].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-7]&&yylstack[yysp-7].src,type:yylstack[yysp-7]&&yylstack[yysp-7].type||yylstack[yysp-7]&&yylstack[yysp-7].type}},{"first":1,"last":8,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-7]],["Identifier",yylstack[yysp-6]],[",",yylstack[yysp-5]],["Assignable",yylstack[yysp-4]],["ForAny",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 160:/*! Production::    For : FOR Identifier "," Assignable ForAny Expression THEN Block */ // default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-7,yysp);// END of default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR Identifier , Assignable ForAny Expression THEN Block",...[[[yyvstack[yysp-6],yyvstack[yysp-4]],yyvstack[yysp-3],yyvstack[yysp-2]],yyvstack[yysp]]),{rule:"FOR Identifier , Assignable ForAny Expression THEN Block",loc:{first_line:yylstack[yysp-7]&&yylstack[yysp-7].first_line,first_column:yylstack[yysp-7]&&yylstack[yysp-7].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-7]&&yylstack[yysp-7].src,type:yylstack[yysp-7]&&yylstack[yysp-7].type||yylstack[yysp-7]&&yylstack[yysp-7].type}},{"first":1,"last":8,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-7]],["Identifier",yylstack[yysp-6]],[",",yylstack[yysp-5]],["Assignable",yylstack[yysp-4]],["ForAny",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 161:/*! Production::    For : FOR Identifier "," Assignable ForAny Expression Block */ // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-6,yysp);// END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR Identifier , Assignable ForAny Expression Block",...[[[yyvstack[yysp-5],yyvstack[yysp-3]],yyvstack[yysp-2],yyvstack[yysp-1]],yyvstack[yysp]]),{rule:"FOR Identifier , Assignable ForAny Expression Block",loc:{first_line:yylstack[yysp-6]&&yylstack[yysp-6].first_line,first_column:yylstack[yysp-6]&&yylstack[yysp-6].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-6]&&yylstack[yysp-6].src,type:yylstack[yysp-6]&&yylstack[yysp-6].type||yylstack[yysp-6]&&yylstack[yysp-6].type}},{"first":1,"last":7,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-6]],["Identifier",yylstack[yysp-5]],[",",yylstack[yysp-4]],["Assignable",yylstack[yysp-3]],["ForAny",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 162:/*! Production::    For : FOR DeclarationKeyword Identifier "," Assignable ForAny Expression THEN Expression */ // default action (generated by JISON mode classic/merge :: 9,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-8,yysp);// END of default action (generated by JISON mode classic/merge :: 9,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR DeclarationKeyword Identifier , Assignable ForAny Expression THEN Expression",...[[[yyvstack[yysp-6],yyvstack[yysp-4]],yyvstack[yysp-3],yyvstack[yysp-2]],yy.Block.wrap(yyvstack[yysp]),yyvstack[yysp-7]]),{rule:"FOR DeclarationKeyword Identifier , Assignable ForAny Expression THEN Expression",loc:{first_line:yylstack[yysp-8]&&yylstack[yysp-8].first_line,first_column:yylstack[yysp-8]&&yylstack[yysp-8].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-8]&&yylstack[yysp-8].src,type:yylstack[yysp-8]&&yylstack[yysp-8].type||yylstack[yysp-8]&&yylstack[yysp-8].type}},{"first":1,"last":9,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-8]],["DeclarationKeyword",yylstack[yysp-7]],["Identifier",yylstack[yysp-6]],[",",yylstack[yysp-5]],["Assignable",yylstack[yysp-4]],["ForAny",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 163:/*! Production::    For : FOR DeclarationKeyword Identifier "," Assignable ForAny Expression THEN Block */ // default action (generated by JISON mode classic/merge :: 9,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-8,yysp);// END of default action (generated by JISON mode classic/merge :: 9,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR DeclarationKeyword Identifier , Assignable ForAny Expression THEN Block",...[[[yyvstack[yysp-6],yyvstack[yysp-4]],yyvstack[yysp-3],yyvstack[yysp-2]],yyvstack[yysp-1],yyvstack[yysp-7]]),{rule:"FOR DeclarationKeyword Identifier , Assignable ForAny Expression THEN Block",loc:{first_line:yylstack[yysp-8]&&yylstack[yysp-8].first_line,first_column:yylstack[yysp-8]&&yylstack[yysp-8].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-8]&&yylstack[yysp-8].src,type:yylstack[yysp-8]&&yylstack[yysp-8].type||yylstack[yysp-8]&&yylstack[yysp-8].type}},{"first":1,"last":9,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-8]],["DeclarationKeyword",yylstack[yysp-7]],["Identifier",yylstack[yysp-6]],[",",yylstack[yysp-5]],["Assignable",yylstack[yysp-4]],["ForAny",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 164:/*! Production::    For : FOR DeclarationKeyword Identifier "," Assignable ForAny Expression Block */ // default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-7,yysp);// END of default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("FOR DeclarationKeyword Identifier , Assignable ForAny Expression Block",...[[[yyvstack[yysp-5],yyvstack[yysp-3]],yyvstack[yysp-2],yyvstack[yysp-1]],yyvstack[yysp],yyvstack[yysp-6]]),{rule:"FOR DeclarationKeyword Identifier , Assignable ForAny Expression Block",loc:{first_line:yylstack[yysp-7]&&yylstack[yysp-7].first_line,first_column:yylstack[yysp-7]&&yylstack[yysp-7].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-7]&&yylstack[yysp-7].src,type:yylstack[yysp-7]&&yylstack[yysp-7].type||yylstack[yysp-7]&&yylstack[yysp-7].type}},{"first":1,"last":8,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FOR",yylstack[yysp-7]],["DeclarationKeyword",yylstack[yysp-6]],["Identifier",yylstack[yysp-5]],[",",yylstack[yysp-4]],["Assignable",yylstack[yysp-3]],["ForAny",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 165:/*! Production::    For : Expression POSTFOR DeclarationKeyword Identifier "," Assignable ForAny Expression */ // default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-7,yysp);// END of default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("Expression POSTFOR DeclarationKeyword Identifier , Assignable ForAny Expression",...[[[yyvstack[yysp-4],yyvstack[yysp-2]],yyvstack[yysp-1],yyvstack[yysp]],yy.Block.wrap(yyvstack[yysp-7]),yyvstack[yysp-5]]),{rule:"Expression POSTFOR DeclarationKeyword Identifier , Assignable ForAny Expression",loc:{first_line:yylstack[yysp-7]&&yylstack[yysp-7].first_line,first_column:yylstack[yysp-7]&&yylstack[yysp-7].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-7]&&yylstack[yysp-7].src,type:yylstack[yysp-7]&&yylstack[yysp-7].type||yylstack[yysp-7]&&yylstack[yysp-7].type}},{"first":1,"last":8,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-7]],["POSTFOR",yylstack[yysp-6]],["DeclarationKeyword",yylstack[yysp-5]],["Identifier",yylstack[yysp-4]],[",",yylstack[yysp-3]],["Assignable",yylstack[yysp-2]],["ForAny",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 166:/*! Production::    For : Expression POSTFOR ForAssignable FOR_OF Expression */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("Expression POSTFOR ForAssignable FOR_OF Expression",...[[yyvstack[yysp-2][1],yyvstack[yysp-1],yyvstack[yysp]],yy.Block.wrap(yyvstack[yysp-4]),yyvstack[yysp-2][2]]),{rule:"Expression POSTFOR ForAssignable FOR_OF Expression",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-4]],["POSTFOR",yylstack[yysp-3]],["ForAssignable",yylstack[yysp-2]],["FOR_OF",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 167:/*! Production::    For : Expression POSTFOR ForAssignable FOR_IN Expression */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("Expression POSTFOR ForAssignable FOR_IN Expression",...[[yyvstack[yysp-2][1],yyvstack[yysp-1],yyvstack[yysp]],yy.Block.wrap(yyvstack[yysp-4]),yyvstack[yysp-2][2]]),{rule:"Expression POSTFOR ForAssignable FOR_IN Expression",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-4]],["POSTFOR",yylstack[yysp-3]],["ForAssignable",yylstack[yysp-2]],["FOR_IN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 168:/*! Production::    For : Expression POSTFOR Identifier "," Assignable ForAny Expression */ // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-6,yysp);// END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["For"]("Expression POSTFOR Identifier , Assignable ForAny Expression",...[[[yyvstack[yysp-4],yyvstack[yysp-2]],yyvstack[yysp-1],yyvstack[yysp]],yy.Block.wrap(yyvstack[yysp-6])]),{rule:"Expression POSTFOR Identifier , Assignable ForAny Expression",loc:{first_line:yylstack[yysp-6]&&yylstack[yysp-6].first_line,first_column:yylstack[yysp-6]&&yylstack[yysp-6].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-6]&&yylstack[yysp-6].src,type:yylstack[yysp-6]&&yylstack[yysp-6].type||yylstack[yysp-6]&&yylstack[yysp-6].type}},{"first":1,"last":7,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-6]],["POSTFOR",yylstack[yysp-5]],["Identifier",yylstack[yysp-4]],[",",yylstack[yysp-3]],["Assignable",yylstack[yysp-2]],["ForAny",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 169:/*! Production::    ForAssignable : DeclarationKeyword Assignable */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ForAssignable"]("DeclarationKeyword Assignable",...[yyvstack[yysp],yyvstack[yysp-1]]),{rule:"DeclarationKeyword Assignable",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["DeclarationKeyword",yylstack[yysp-1]],["Assignable",yylstack[yysp]]);break;case 170:/*! Production::    ForAssignable : Assignable */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ForAssignable"]("Assignable",...[yyvstack[yysp]]),{rule:"Assignable",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Assignable",yylstack[yysp]]);break;case 171:/*! Production::    Switch : SWITCH Expression INDENT Cases OUTDENT */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Switch"]("SWITCH Expression INDENT Cases OUTDENT",...[yyvstack[yysp-3],yyvstack[yysp-1]]),{rule:"SWITCH Expression INDENT Cases OUTDENT",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["SWITCH",yylstack[yysp-4]],["Expression",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Cases",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 172:/*! Production::    Switch : SWITCH INDENT Cases OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Switch"]("SWITCH INDENT Cases OUTDENT",...[false,yyvstack[yysp-1]]),{rule:"SWITCH INDENT Cases OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["SWITCH",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Cases",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 173:/*! Production::    Switch : SWITCH Expression "{{" INDENT Cases OUTDENT "}}" */ // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-6,yysp);// END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Switch"]("SWITCH Expression {{ INDENT Cases OUTDENT }}",...[yyvstack[yysp-5],yyvstack[yysp-2]]),{rule:"SWITCH Expression {{ INDENT Cases OUTDENT }}",loc:{first_line:yylstack[yysp-6]&&yylstack[yysp-6].first_line,first_column:yylstack[yysp-6]&&yylstack[yysp-6].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-6]&&yylstack[yysp-6].src,type:yylstack[yysp-6]&&yylstack[yysp-6].type||yylstack[yysp-6]&&yylstack[yysp-6].type}},{"first":1,"last":7,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["SWITCH",yylstack[yysp-6]],["Expression",yylstack[yysp-5]],["{{",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["Cases",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["}}",yylstack[yysp]]);break;case 174:/*! Production::    Switch : SWITCH "{{" INDENT Cases OUTDENT "}}" */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Switch"]("SWITCH {{ INDENT Cases OUTDENT }}",...[false,yyvstack[yysp-2]]),{rule:"SWITCH {{ INDENT Cases OUTDENT }}",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["SWITCH",yylstack[yysp-5]],["{{",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["Cases",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["}}",yylstack[yysp]]);break;case 175:/*! Production::    Cases : Case */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Cases"]("Case",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Case",yylstack[yysp-1]]);break;case 176:/*! Production::    Cases : Cases NEWLINE Case */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Cases"]("Cases NEWLINE Case",...[...yyvstack[yysp-2].contents,yyvstack[yysp]]),{rule:"Cases NEWLINE Case",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Cases",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["Case",yylstack[yysp]]);break;case 177:/*! Production::    Case : Clauses THEN Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Case"]("Clauses THEN Expression",...[yyvstack[yysp-2],yy.Block.wrap(yyvstack[yysp])]),{rule:"Clauses THEN Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Clauses",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 178:/*! Production::    Case : Clauses THEN Block */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Case"]("Clauses THEN Block",...[yyvstack[yysp-2],yyvstack[yysp].unwrap]),{rule:"Clauses THEN Block",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Clauses",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 179:/*! Production::    Case : Clauses Block */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Case"]("Clauses Block",...[yyvstack[yysp-1],yyvstack[yysp].unwrap]),{rule:"Clauses Block",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Clauses",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 180:/*! Production::    Case : Multicondition THEN Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Case"]("Multicondition THEN Expression",...[yyvstack[yysp-2],yy.Block.wrap(yyvstack[yysp])]),{rule:"Multicondition THEN Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Multicondition",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 181:/*! Production::    Case : Multicondition THEN Block */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Case"]("Multicondition THEN Block",...[yyvstack[yysp-2],yyvstack[yysp].unwrap]),{rule:"Multicondition THEN Block",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Multicondition",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 182:/*! Production::    Case : Multicondition Block */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Case"]("Multicondition Block",...[yyvstack[yysp-1],yyvstack[yysp].unwrap]),{rule:"Multicondition Block",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Multicondition",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 183:/*! Production::    Case : DEFAULT Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Case"]("DEFAULT Expression",...[false,yy.Block.wrap(yyvstack[yysp])]),{rule:"DEFAULT Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["DEFAULT",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 184:/*! Production::    Case : DEFAULT Block */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Case"]("DEFAULT Block",...[false,yyvstack[yysp].unwrap]),{rule:"DEFAULT Block",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["DEFAULT",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 185:/*! Production::    Case : Expression POSTCASE MulticheckClauses */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Case"]("Expression POSTCASE MulticheckClauses",...[yyvstack[yysp],yy.Block.wrap(yyvstack[yysp-2])]),{rule:"Expression POSTCASE MulticheckClauses",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-2]],["POSTCASE",yylstack[yysp-1]],["MulticheckClauses",yylstack[yysp]]);break;case 186:/*! Production::    Case : BREAK */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Case"]("BREAK",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["BREAK",yylstack[yysp-1]]);break;case 187:/*! Production::    Clauses : When */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Clauses"]("When",...[yyvstack[yysp].contents]),{rule:"When",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["When",yylstack[yysp]]);break;case 188:/*! Production::    Clauses : Clauses NEWLINE When */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Clauses"]("Clauses NEWLINE When",...[...yyvstack[yysp-2].contents,yyvstack[yysp].contents]),{rule:"Clauses NEWLINE When",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Clauses",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["When",yylstack[yysp]]);break;case 189:/*! Production::    Clauses : Clauses COMPOUND_OR When */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Clauses"]("Clauses COMPOUND_OR When",...[...yyvstack[yysp-2].contents,yyvstack[yysp].contents]),{rule:"Clauses COMPOUND_OR When",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Clauses",yylstack[yysp-2]],["COMPOUND_OR",yylstack[yysp-1]],["When",yylstack[yysp]]);break;case 190:/*! Production::    When : CASE Clause */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["When"]("CASE Clause",...[...yyvstack[yysp].contents]),{rule:"CASE Clause",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CASE",yylstack[yysp-1]],["Clause",yylstack[yysp]]);break;case 191:/*! Production::    When : IF Clause */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["When"]("IF Clause",...[...yyvstack[yysp].contents]),{rule:"IF Clause",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IF",yylstack[yysp-1]],["Clause",yylstack[yysp]]);break;case 192:/*! Production::    When : ON Clause */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["When"]("ON Clause",...[...yyvstack[yysp].contents]),{rule:"ON Clause",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ON",yylstack[yysp-1]],["Clause",yylstack[yysp]]);break;case 193:/*! Production::    When : WHEN Clause */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["When"]("WHEN Clause",...[...yyvstack[yysp].contents]),{rule:"WHEN Clause",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WHEN",yylstack[yysp-1]],["Clause",yylstack[yysp]]);break;case 194:/*! Production::    ForAny : FOR_FROM */case 195:/*! Production::    ForAny : FOR_AT */case 196:/*! Production::    ForAny : FOR_AS */case 301:/*! Production::    PropObj : Function */case 302:/*! Production::    PropObj : ClassFunction */case 316:/*! Production::    PropObj : Assignment */case 322:/*! Production::    ParamPropObj : ParamIdentifier */case 452:/*! Production::    OptVoids : Voids */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=yyvstack[yysp];break;case 197:/*! Production::    If : IfBlock */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["If"]("IfBlock",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["IfBlock",yylstack[yysp-1]]);break;case 198:/*! Production::    If : IfBlock Else */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["If"]("IfBlock Else",...[yyvstack[yysp-1],yyvstack[yysp]]),{rule:"IfBlock Else",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IfBlock",yylstack[yysp-1]],["Else",yylstack[yysp]]);break;case 199:/*! Production::    If : Expression "?" BlockExpression ":" BlockExpression */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["If"]("Expression ? BlockExpression : BlockExpression",...[new yy.IfBlock('IfBlock',yyvstack[yysp-4],yyvstack[yysp-2].unwrap),new yy.Else('Else',yyvstack[yysp].unwrap)]),{rule:"Expression ? BlockExpression : BlockExpression",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false,"quoteSyntax":true},{generated:undefined}).setTokens(["Expression",yylstack[yysp-4]],["?",yylstack[yysp-3]],["BlockExpression",yylstack[yysp-2]],[":",yylstack[yysp-1]],["BlockExpression",yylstack[yysp]]);break;case 200:/*! Production::    If : Expression "?" BlockExpression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["If"]("Expression ? BlockExpression",...[new yy.IfBlock('IfBlock',yyvstack[yysp-2],yyvstack[yysp].unwrap)]),{rule:"Expression ? BlockExpression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false,"quoteSyntax":true},{generated:undefined}).setTokens(["Expression",yylstack[yysp-2]],["?",yylstack[yysp-1]],["BlockExpression",yylstack[yysp]]);break;case 201:/*! Production::    If : Expression "?" INDENT BlockExpression ":" BlockExpression OUTDENT */ // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-6,yysp);// END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["If"]("Expression ? INDENT BlockExpression : BlockExpression OUTDENT",...[new yy.IfBlock('IfBlock',yyvstack[yysp-6],yyvstack[yysp-3].unwrap),new yy.Else('Else',yyvstack[yysp-1].unwrap)]),{rule:"Expression ? INDENT BlockExpression : BlockExpression OUTDENT",loc:{first_line:yylstack[yysp-6]&&yylstack[yysp-6].first_line,first_column:yylstack[yysp-6]&&yylstack[yysp-6].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-6]&&yylstack[yysp-6].src,type:yylstack[yysp-6]&&yylstack[yysp-6].type||yylstack[yysp-6]&&yylstack[yysp-6].type}},{"first":1,"last":7,"typeOf":1,"checkGenerated":false,"quoteSyntax":true},{generated:undefined}).setTokens(["Expression",yylstack[yysp-6]],["?",yylstack[yysp-5]],["INDENT",yylstack[yysp-4]],["BlockExpression",yylstack[yysp-3]],[":",yylstack[yysp-2]],["BlockExpression",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 202:/*! Production::    If : Expression POSTIF Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["If"]("Expression POSTIF Expression",...[yyvstack[yysp],yyvstack[yysp-2]]),{rule:"Expression POSTIF Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false,"postfix":true},{generated:undefined}).setTokens(["Expression",yylstack[yysp-2]],["POSTIF",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 203:/*! Production::    If : Statement POSTIF Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["If"]("Statement POSTIF Expression",...[yyvstack[yysp],yyvstack[yysp-2]]),{rule:"Statement POSTIF Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false,"postfix":true,"statement":true},{generated:undefined}).setTokens(["Statement",yylstack[yysp-2]],["POSTIF",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 204:/*! Production::    If : Expression POSTUNLESS Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["If"]("Expression POSTUNLESS Expression",...[yyvstack[yysp],yyvstack[yysp-2]]),{rule:"Expression POSTUNLESS Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false,"postfix":true,"unless":true},{generated:undefined}).setTokens(["Expression",yylstack[yysp-2]],["POSTUNLESS",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 205:/*! Production::    If : Statement POSTUNLESS Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["If"]("Statement POSTUNLESS Expression",...[yyvstack[yysp],yyvstack[yysp-2]]),{rule:"Statement POSTUNLESS Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false,"postfix":true,"statement":true,"unless":true},{generated:undefined}).setTokens(["Statement",yylstack[yysp-2]],["POSTUNLESS",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 206:/*! Production::    BlockExpression : Expression */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["BlockExpression"]("Expression",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Expression",yylstack[yysp-1]]);break;case 207:/*! Production::    BlockExpression : INDENT Expression OUTDENT */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["BlockExpression"]("INDENT Expression OUTDENT",...[yyvstack[yysp-1]]),{rule:"INDENT Expression OUTDENT",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["INDENT",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 208:/*! Production::    Try : TRY Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Try"]("TRY Expression",...[yy.Block.wrap(yyvstack[yysp])]),{rule:"TRY Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TRY",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 209:/*! Production::    Try : TRY Block */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Try"]("TRY Block",...[yyvstack[yysp]]),{rule:"TRY Block",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TRY",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 210:/*! Production::    Catch : CATCH Block */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Catch"]("CATCH Block",...[null,yyvstack[yysp]]),{rule:"CATCH Block",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CATCH",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 211:/*! Production::    Catch : CATCH Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Catch"]("CATCH Expression",...[null,yy.Block.wrap(yyvstack[yysp])]),{rule:"CATCH Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CATCH",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 212:/*! Production::    Catch : CATCH Identifier Block */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Catch"]("CATCH Identifier Block",...[yyvstack[yysp-1],yyvstack[yysp]]),{rule:"CATCH Identifier Block",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CATCH",yylstack[yysp-2]],["Identifier",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 213:/*! Production::    Catch : CATCH Identifier THEN Block */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Catch"]("CATCH Identifier THEN Block",...[yyvstack[yysp-2],yyvstack[yysp]]),{rule:"CATCH Identifier THEN Block",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CATCH",yylstack[yysp-3]],["Identifier",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 214:/*! Production::    Catch : CATCH Identifier THEN Expression */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Catch"]("CATCH Identifier THEN Expression",...[yyvstack[yysp-2],yy.Block.wrap(yyvstack[yysp])]),{rule:"CATCH Identifier THEN Expression",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CATCH",yylstack[yysp-3]],["Identifier",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 215:/*! Production::    Finally : FINALLY Block */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Finally"]("FINALLY Block",...[yyvstack[yysp]]),{rule:"FINALLY Block",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FINALLY",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 216:/*! Production::    Finally : FINALLY Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Finally"]("FINALLY Expression",...[yy.Block.wrap(yyvstack[yysp])]),{rule:"FINALLY Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FINALLY",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 217:/*! Production::    TryBlock : Try */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TryBlock"]("Try",...[yyvstack[yysp],null,null]),{rule:"Try",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Try",yylstack[yysp]]);break;case 218:/*! Production::    TryBlock : Try Catch */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TryBlock"]("Try Catch",...[yyvstack[yysp-1],yyvstack[yysp],null]),{rule:"Try Catch",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Try",yylstack[yysp-1]],["Catch",yylstack[yysp]]);break;case 219:/*! Production::    TryBlock : Try Catch Finally */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TryBlock"]("Try Catch Finally",...[yyvstack[yysp-2],yyvstack[yysp-1],yyvstack[yysp]]),{rule:"Try Catch Finally",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Try",yylstack[yysp-2]],["Catch",yylstack[yysp-1]],["Finally",yylstack[yysp]]);break;case 220:/*! Production::    Loop : LOOP Block */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Loop"]("LOOP Block",...[yyvstack[yysp].unwrap]),{rule:"LOOP Block",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["LOOP",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 221:/*! Production::    Loop : LOOP Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Loop"]("LOOP Expression",...[yy.Block.wrap(yyvstack[yysp]).unwrap]),{rule:"LOOP Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["LOOP",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 222:/*! Production::    WhileUntil : WHILE */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["WhileUntil"]("WHILE",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["WHILE",yylstack[yysp-1]]);break;case 223:/*! Production::    WhileUntil : UNTIL */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["WhileUntil"]("UNTIL",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["UNTIL",yylstack[yysp-1]]);break;case 224:/*! Production::    WhileUntil : POSTWHILE */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["WhileUntil"]("POSTWHILE",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["POSTWHILE",yylstack[yysp-1]]);break;case 225:/*! Production::    WhileUntil : POSTUNTIL */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["WhileUntil"]("POSTUNTIL",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["POSTUNTIL",yylstack[yysp-1]]);break;case 226:/*! Production::    ElseOtherwise : ELSE */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ElseOtherwise"]("ELSE",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["ELSE",yylstack[yysp-1]]);break;case 227:/*! Production::    ElseOtherwise : OTHERWISE */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ElseOtherwise"]("OTHERWISE",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["OTHERWISE",yylstack[yysp-1]]);break;case 228:/*! Production::    ElseOtherwise : OR */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ElseOtherwise"]("OR",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["OR",yylstack[yysp-1]]);break;case 229:/*! Production::    While : WhileUntil Expression THEN Block */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["While"]("WhileUntil Expression THEN Block",...[yyvstack[yysp-2],yyvstack[yysp].unwrap,yyvstack[yysp-3]]),{rule:"WhileUntil Expression THEN Block",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WhileUntil",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 230:/*! Production::    While : WhileUntil Expression THEN Expression */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["While"]("WhileUntil Expression THEN Expression",...[yyvstack[yysp-2],yy.Block.wrap(yyvstack[yysp]),yyvstack[yysp-3]]),{rule:"WhileUntil Expression THEN Expression",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WhileUntil",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 231:/*! Production::    While : WhileUntil "(" Expression ")" Expression */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["While"]("WhileUntil ( Expression ) Expression",...[yyvstack[yysp-2],yy.Block.wrap(yyvstack[yysp]),yyvstack[yysp-4]]),{rule:"WhileUntil ( Expression ) Expression",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WhileUntil",yylstack[yysp-4]],["(",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],[")",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 232:/*! Production::    While : WhileUntil Expression Block */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["While"]("WhileUntil Expression Block",...[yyvstack[yysp-1],yyvstack[yysp].unwrap,yyvstack[yysp-2]]),{rule:"WhileUntil Expression Block",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["WhileUntil",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 233:/*! Production::    While : Loop WhileUntil Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["While"]("Loop WhileUntil Expression",...[yyvstack[yysp],yyvstack[yysp-2].unwrap,yyvstack[yysp-1]]),{rule:"Loop WhileUntil Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Loop",yylstack[yysp-2]],["WhileUntil",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 234:/*! Production::    While : Loop NEWLINE WhileUntil Expression */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["While"]("Loop NEWLINE WhileUntil Expression",...[yyvstack[yysp],yyvstack[yysp-3].unwrap,yyvstack[yysp-1]]),{rule:"Loop NEWLINE WhileUntil Expression",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Loop",yylstack[yysp-3]],["NEWLINE",yylstack[yysp-2]],["WhileUntil",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 235:/*! Production::    While : Expression WhileUntil Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["While"]("Expression WhileUntil Expression",...[yyvstack[yysp],yy.Block.wrap(yyvstack[yysp-2]),yyvstack[yysp-1]]),{rule:"Expression WhileUntil Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-2]],["WhileUntil",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 236:/*! Production::    IfUnless : IF */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["IfUnless"]("IF",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["IF",yylstack[yysp-1]]);break;case 237:/*! Production::    IfUnless : UNLESS */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["IfUnless"]("UNLESS",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["UNLESS",yylstack[yysp-1]]);break;case 238:/*! Production::    Else : ElseOtherwise Block */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Else"]("ElseOtherwise Block",...[yyvstack[yysp]]),{rule:"ElseOtherwise Block",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ElseOtherwise",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 239:/*! Production::    Else : ElseOtherwise Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Else"]("ElseOtherwise Expression",...[yyvstack[yysp]]),{rule:"ElseOtherwise Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ElseOtherwise",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 240:/*! Production::    Else : ElseOtherwise Statement */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Else"]("ElseOtherwise Statement",...[yyvstack[yysp]]),{rule:"ElseOtherwise Statement",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ElseOtherwise",yylstack[yysp-1]],["Statement",yylstack[yysp]]);break;case 241:/*! Production::    Else : ElseOtherwise THEN Block */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Else"]("ElseOtherwise THEN Block",...[yyvstack[yysp]]),{rule:"ElseOtherwise THEN Block",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ElseOtherwise",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 242:/*! Production::    IfBlock : IfUnless "(" Expression ")" Expression */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IfBlock"]("IfUnless ( Expression ) Expression",...[yyvstack[yysp-2],yyvstack[yysp],yyvstack[yysp-4]]),{rule:"IfUnless ( Expression ) Expression",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IfUnless",yylstack[yysp-4]],["(",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],[")",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 243:/*! Production::    IfBlock : IfUnless "(" Expression ")" Statement */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IfBlock"]("IfUnless ( Expression ) Statement",...[yyvstack[yysp-2],yyvstack[yysp],yyvstack[yysp-4]]),{rule:"IfUnless ( Expression ) Statement",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IfUnless",yylstack[yysp-4]],["(",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],[")",yylstack[yysp-1]],["Statement",yylstack[yysp]]);break;case 244:/*! Production::    IfBlock : IfUnless Expression "{" Expression "}" */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IfBlock"]("IfUnless Expression { Expression }",...[yyvstack[yysp-3],yyvstack[yysp-1],yyvstack[yysp-4]]),{rule:"IfUnless Expression { Expression }",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IfUnless",yylstack[yysp-4]],["Expression",yylstack[yysp-3]],["{",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 245:/*! Production::    IfBlock : IfUnless Expression "{" Statement "}" */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IfBlock"]("IfUnless Expression { Statement }",...[yyvstack[yysp-3],yyvstack[yysp-1],yyvstack[yysp-4]]),{rule:"IfUnless Expression { Statement }",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IfUnless",yylstack[yysp-4]],["Expression",yylstack[yysp-3]],["{",yylstack[yysp-2]],["Statement",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 246:/*! Production::    IfBlock : IfUnless Expression THEN Expression */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IfBlock"]("IfUnless Expression THEN Expression",...[yyvstack[yysp-2],yyvstack[yysp],yyvstack[yysp-3]]),{rule:"IfUnless Expression THEN Expression",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IfUnless",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 247:/*! Production::    IfBlock : IfUnless Expression THEN Statement */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IfBlock"]("IfUnless Expression THEN Statement",...[yyvstack[yysp-2],yyvstack[yysp],yyvstack[yysp-3]]),{rule:"IfUnless Expression THEN Statement",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IfUnless",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Statement",yylstack[yysp]]);break;case 248:/*! Production::    IfBlock : IfUnless Expression THEN "{" Expression "}" */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IfBlock"]("IfUnless Expression THEN { Expression }",...[yyvstack[yysp-4],yyvstack[yysp-1],yyvstack[yysp-5]]),{rule:"IfUnless Expression THEN { Expression }",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IfUnless",yylstack[yysp-5]],["Expression",yylstack[yysp-4]],["THEN",yylstack[yysp-3]],["{",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 249:/*! Production::    IfBlock : IfUnless Expression THEN "{" Statement "}" */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IfBlock"]("IfUnless Expression THEN { Statement }",...[yyvstack[yysp-4],yyvstack[yysp-1],yyvstack[yysp-5]]),{rule:"IfUnless Expression THEN { Statement }",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IfUnless",yylstack[yysp-5]],["Expression",yylstack[yysp-4]],["THEN",yylstack[yysp-3]],["{",yylstack[yysp-2]],["Statement",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 250:/*! Production::    IfBlock : IfUnless Expression Block */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IfBlock"]("IfUnless Expression Block",...[yyvstack[yysp-1],yyvstack[yysp],yyvstack[yysp-2]]),{rule:"IfUnless Expression Block",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IfUnless",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 251:/*! Production::    IfBlock : IfUnless Expression THEN Block */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IfBlock"]("IfUnless Expression THEN Block",...[yyvstack[yysp-2],yyvstack[yysp],yyvstack[yysp-3]]),{rule:"IfUnless Expression THEN Block",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IfUnless",yylstack[yysp-3]],["Expression",yylstack[yysp-2]],["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 252:/*! Production::    Value : Assignable */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Value"]("Assignable",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Assignable",yylstack[yysp-1]]);break;case 253:/*! Production::    Value : Parenthetical */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Value"]("Parenthetical",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Parenthetical",yylstack[yysp-1]]);break;case 254:/*! Production::    Value : Literal */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Value"]("Literal",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Literal",yylstack[yysp-1]]);break;case 255:/*! Production::    Value : Invocation */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Value"]("Invocation",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Invocation",yylstack[yysp-1]]);break;case 256:/*! Production::    Value : Function */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Value"]("Function",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Function",yylstack[yysp-1]]);break;case 257:/*! Production::    Value : New */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Value"]("New",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["New",yylstack[yysp-1]]);break;case 258:/*! Production::    Value : This */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Value"]("This",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["This",yylstack[yysp-1]]);break;case 259:/*! Production::    Value : Super */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Value"]("Super",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Super",yylstack[yysp-1]]);break;case 260:/*! Production::    Value : SUCH */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Value"]("SUCH",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["SUCH",yylstack[yysp-1]]);break;case 261:/*! Production::    Invocation : Value FUNC_EXISTS TypeArguments? Arguments */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Invocation"]("Value FUNC_EXISTS TypeArguments? Arguments",...[yyvstack[yysp-3],yyvstack[yysp],yyvstack[yysp-1].unwrap]),{rule:"Value FUNC_EXISTS TypeArguments? Arguments",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false,"soak":true},{generated:undefined}).setTokens(["Value",yylstack[yysp-3]],["FUNC_EXISTS",yylstack[yysp-2]],["TypeArguments?",yylstack[yysp-1]],["Arguments",yylstack[yysp]]);break;case 262:/*! Production::    Invocation : Value "<(" TypeArguments ")>" Arguments */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Invocation"]("Value <( TypeArguments )> Arguments",...[yyvstack[yysp-4],yyvstack[yysp],yyvstack[yysp-2].setLoc(yylstack[yysp-3],yylstack[yysp-1])]),{rule:"Value <( TypeArguments )> Arguments",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Value",yylstack[yysp-4]],["<(",yylstack[yysp-3]],["TypeArguments",yylstack[yysp-2]],[")>",yylstack[yysp-1]],["Arguments",yylstack[yysp]]);break;case 263:/*! Production::    Invocation : Value Arguments */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Invocation"]("Value Arguments",...[yyvstack[yysp-1],yyvstack[yysp]]),{rule:"Value Arguments",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Value",yylstack[yysp-1]],["Arguments",yylstack[yysp]]);break;case 264:/*! Production::    Invocation : Value FUNC_EXISTS TypeArguments? String */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Invocation"]("Value FUNC_EXISTS TypeArguments? String",...[yyvstack[yysp-3],yyvstack[yysp],yyvstack[yysp-1].unwrap]),{rule:"Value FUNC_EXISTS TypeArguments? String",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false,"templ":true,"soak":true},{generated:undefined}).setTokens(["Value",yylstack[yysp-3]],["FUNC_EXISTS",yylstack[yysp-2]],["TypeArguments?",yylstack[yysp-1]],["String",yylstack[yysp]]);break;case 265:/*! Production::    Invocation : Value "<(" TypeArguments ")>" String */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Invocation"]("Value <( TypeArguments )> String",...[yyvstack[yysp-4],yyvstack[yysp],yyvstack[yysp-2].setLoc(yylstack[yysp-3],yylstack[yysp-1])]),{rule:"Value <( TypeArguments )> String",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false,"templ":true},{generated:undefined}).setTokens(["Value",yylstack[yysp-4]],["<(",yylstack[yysp-3]],["TypeArguments",yylstack[yysp-2]],[")>",yylstack[yysp-1]],["String",yylstack[yysp]]);break;case 266:/*! Production::    Invocation : Value String */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Invocation"]("Value String",...[yyvstack[yysp-1],yyvstack[yysp]]),{rule:"Value String",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false,"templ":true},{generated:undefined}).setTokens(["Value",yylstack[yysp-1]],["String",yylstack[yysp]]);break;case 267:/*! Production::    Invocation : SUPER FUNC_EXISTS Arguments */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Invocation"]("SUPER FUNC_EXISTS Arguments",...[yyvstack[yysp-2],yyvstack[yysp]]),{rule:"SUPER FUNC_EXISTS Arguments",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false,"soak":true},{generated:undefined}).setTokens(["SUPER",yylstack[yysp-2]],["FUNC_EXISTS",yylstack[yysp-1]],["Arguments",yylstack[yysp]]);break;case 268:/*! Production::    Invocation : SUPER "<(" TypeArguments ")>" Arguments */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Invocation"]("SUPER <( TypeArguments )> Arguments",...[yyvstack[yysp-4],yyvstack[yysp],yyvstack[yysp-2].setLoc(yylstack[yysp-3],yylstack[yysp-1])]),{rule:"SUPER <( TypeArguments )> Arguments",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["SUPER",yylstack[yysp-4]],["<(",yylstack[yysp-3]],["TypeArguments",yylstack[yysp-2]],[")>",yylstack[yysp-1]],["Arguments",yylstack[yysp]]);break;case 269:/*! Production::    Invocation : SUPER Arguments */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Invocation"]("SUPER Arguments",...[yyvstack[yysp-1],yyvstack[yysp]]),{rule:"SUPER Arguments",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["SUPER",yylstack[yysp-1]],["Arguments",yylstack[yysp]]);break;case 270:/*! Production::    Arguments : CALL_START CALL_END */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Arguments"]("CALL_START CALL_END",...[/* */]),{rule:"CALL_START CALL_END",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CALL_START",yylstack[yysp-1]],["CALL_END",yylstack[yysp]]);break;case 271:/*! Production::    Arguments : CALL_START ArgList OptComma CALL_END */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Arguments"]("CALL_START ArgList OptComma CALL_END",...[yyvstack[yysp-2]]),{rule:"CALL_START ArgList OptComma CALL_END",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CALL_START",yylstack[yysp-3]],["ArgList",yylstack[yysp-2]],["OptComma",yylstack[yysp-1]],["CALL_END",yylstack[yysp]]);break;case 272:/*! Production::    Arguments : CALL_START INDENT ArgList OptComma OUTDENT CALL_END */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Arguments"]("CALL_START INDENT ArgList OptComma OUTDENT CALL_END",...[yyvstack[yysp-3]]),{rule:"CALL_START INDENT ArgList OptComma OUTDENT CALL_END",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false,"indented":true},{generated:undefined}).setTokens(["CALL_START",yylstack[yysp-5]],["INDENT",yylstack[yysp-4]],["ArgList",yylstack[yysp-3]],["OptComma",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["CALL_END",yylstack[yysp]]);break;case 273:/*! Production::    ArgList : Arg */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ArgList"]("Arg",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Arg",yylstack[yysp-1]]);break;case 274:/*! Production::    ArgList : ArgList "," Arg */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ArgList"]("ArgList , Arg",...[...yyvstack[yysp-2].contents,yyvstack[yysp]]),{rule:"ArgList , Arg",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ArgList",yylstack[yysp-2]],[",",yylstack[yysp-1]],["Arg",yylstack[yysp]]);break;case 275:/*! Production::    ArgList : ArgList OptComma NEWLINE Arg */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ArgList"]("ArgList OptComma NEWLINE Arg",...[...yyvstack[yysp-3].contents,yylstack[yysp-1].generated,yyvstack[yysp]]),{rule:"ArgList OptComma NEWLINE Arg",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ArgList",yylstack[yysp-3]],["OptComma",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["Arg",yylstack[yysp]]);break;case 276:/*! Production::    ArgList : ArgList OptComma INDENT ArgList OptComma OUTDENT */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ArgList"]("ArgList OptComma INDENT ArgList OptComma OUTDENT",...[...yyvstack[yysp-5].contents,false,...yyvstack[yysp-2].contents]),{rule:"ArgList OptComma INDENT ArgList OptComma OUTDENT",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ArgList",yylstack[yysp-5]],["OptComma",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["ArgList",yylstack[yysp-2]],["OptComma",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 277:/*! Production::    Arg : Expression */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Arg"]("Expression",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Expression",yylstack[yysp-1]]);break;case 278:/*! Production::    Arg : "..." Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Arg"]("... Expression",...[yyvstack[yysp]]),{rule:"... Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false,"expansion":true},{generated:undefined}).setTokens(["...",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 279:/*! Production::    Arg : Expression "..." */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Arg"]("Expression ...",...[yyvstack[yysp-1]]),{rule:"Expression ...",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false,"expansion":true},{generated:undefined}).setTokens(["Expression",yylstack[yysp-1]],["...",yylstack[yysp]]);break;case 280:/*! Production::    New : NEW Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["New"]("NEW Expression",...[yyvstack[yysp]]),{rule:"NEW Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["NEW",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 281:/*! Production::    Super : SUPER "." PROPERTY */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Super"]("SUPER . PROPERTY",...[Object.assign([yyvstack[yysp]],{loc:yylstack[yysp]})]),{rule:"SUPER . PROPERTY",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["SUPER",yylstack[yysp-2]],[".",yylstack[yysp-1]],["PROPERTY",yylstack[yysp]]);break;case 282:/*! Production::    Super : SUPER INDEX_START PROPERTY INDEX_END */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Super"]("SUPER INDEX_START PROPERTY INDEX_END",...[yyvstack[yysp-1]]),{rule:"SUPER INDEX_START PROPERTY INDEX_END",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["SUPER",yylstack[yysp-3]],["INDEX_START",yylstack[yysp-2]],["PROPERTY",yylstack[yysp-1]],["INDEX_END",yylstack[yysp]]);break;case 283:/*! Production::    This : THIS */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["This"]("THIS",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["THIS",yylstack[yysp-1]]);break;case 284:/*! Production::    Parenthetical : "(" Expression ")" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Parenthetical"]("( Expression )",...[yyvstack[yysp-1]]),{rule:"( Expression )",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["(",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],[")",yylstack[yysp]]);break;case 285:/*! Production::    Parenthetical : "(" Body ")" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Parenthetical"]("( Body )",...[yyvstack[yysp-1]]),{rule:"( Body )",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["(",yylstack[yysp-2]],["Body",yylstack[yysp-1]],[")",yylstack[yysp]]);break;case 286:/*! Production::    Parenthetical : "(" INDENT Body OUTDENT ")" */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Parenthetical"]("( INDENT Body OUTDENT )",...[yyvstack[yysp-2]]),{rule:"( INDENT Body OUTDENT )",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["(",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["Body",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],[")",yylstack[yysp]]);break;case 287:/*! Production::    OptComma : %epsilon */case 451:/*! Production::    OptVoids : %epsilon */ // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(null,null,null,null,true);// END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
this.$=undefined;break;case 288:/*! Production::    OptComma : "," */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["OptComma"](",",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens([",",yylstack[yysp-1]]);break;case 289:/*! Production::    Object : "{" "}" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Object"]("{ }",...[[]]),{rule:"{ }",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 290:/*! Production::    Object : "{" PropList OptComma "}" */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Object"]("{ PropList OptComma }",...[yyvstack[yysp-2]]),{rule:"{ PropList OptComma }",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false,"indentOf":1},{generated:undefined,indented:yylstack[yysp-3].indented}).setTokens(["{",yylstack[yysp-3]],["PropList",yylstack[yysp-2]],["OptComma",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 291:/*! Production::    Object : "{" INDENT PropList OUTDENT "}" */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Object"]("{ INDENT PropList OUTDENT }",...[yyvstack[yysp-2]]),{rule:"{ INDENT PropList OUTDENT }",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false,"indented":true},{generated:undefined}).setTokens(["{",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["PropList",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 292:/*! Production::    PropList : PropObj */case 297:/*! Production::    ParamPropList : ParamPropObj */case 445:/*! Production::    ParamArrayArg : ParamAssignable */case 449:/*! Production::    ArrayArg : Expression */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp]];break;case 293:/*! Production::    PropList : PropList "," PropObj */case 298:/*! Production::    ParamPropList : ParamPropList "," ParamPropObj */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=yyvstack[yysp-2].push(yyvstack[yysp])&&yyvstack[yysp-2];break;case 294:/*! Production::    PropList : PropList OptComma NEWLINE PropObj */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=yyvstack[yysp-3].push(yylstack[yysp-1].generated,yyvstack[yysp])&&yyvstack[yysp-3];break;case 295:/*! Production::    PropList : PropList OptComma INDENT PropList OUTDENT */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=yyvstack[yysp-4].concat(false,...[yyvstack[yysp-1]]);break;case 296:/*! Production::    ParamPropList : %epsilon */ // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(null,null,null,null,true);// END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
this.$=[];break;case 299:/*! Production::    ParamPropList : ParamPropList OptComma NEWLINE ParamPropObj */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=yyvstack[yysp-3].push(yyvstack[yysp])&&yyvstack[yysp-3];break;case 300:/*! Production::    ParamPropList : ParamPropList OptComma INDENT ParamPropObj OUTDENT */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=yyvstack[yysp-4].push(yyvstack[yysp-1])&&yyvstack[yysp-4];break;case 303:/*! Production::    PropObj : PROPERTY ":" Expression */case 306:/*! Production::    PropObj : AlphaNum ":" Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-2],yyvstack[yysp],[yylstack[yysp-2],yylstack[yysp]]];break;case 304:/*! Production::    PropObj : PROPERTY ":" Block */case 307:/*! Production::    PropObj : AlphaNum ":" Block */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-2],yy.Array.from(yyvstack[yysp]),[yylstack[yysp-2],yylstack[yysp],true]];break;case 305:/*! Production::    PropObj : PROPERTY ":" INDENT Expression OUTDENT */case 308:/*! Production::    PropObj : AlphaNum ":" INDENT Expression OUTDENT */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-4],yyvstack[yysp-1],[yylstack[yysp-4],yylstack[yysp],true]];break;case 309:/*! Production::    PropObj : "[" Expression "]" ":" Expression */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-3],yyvstack[yysp],[yylstack[yysp-4],yylstack[yysp]]];break;case 310:/*! Production::    PropObj : "[" Expression "]" ":" INDENT Expression OUTDENT */ // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-6,yysp);// END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-5],yyvstack[yysp-1],[yylstack[yysp-6],yylstack[yysp-1],true]];break;case 311:/*! Production::    PropObj : "[" Expression "]" ":" Block */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-3],yy.Array.from(yyvstack[yysp]),[yylstack[yysp-4],yylstack[yysp],true]];break;case 312:/*! Production::    PropObj : PROPERTY ":" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-1],false,[yylstack[yysp-1],yylstack[yysp]]];break;case 313:/*! Production::    PropObj : "..." PROPERTY ":" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-1],false,[yylstack[yysp-2],yylstack[yysp]],true];break;case 314:/*! Production::    PropObj : PROPERTY ":" "..." */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-2],false,[yylstack[yysp-2],yylstack[yysp]],true];break;case 315:/*! Production::    PropObj : Identifier */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp][1],false,[yylstack[yysp],yylstack[yysp]]];break;case 317:/*! Production::    PropObj : "..." Value */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=yyvstack[yysp];break;case 318:/*! Production::    PropObj : Value "..." */case 323:/*! Production::    ParamPropObj : ParamIdentifier ":" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=yyvstack[yysp-1];break;case 319:/*! Production::    ParamPropObj : PROPERTY ":" ParamAssignable */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-2],yyvstack[yysp],,,yylstack[yysp-2]];break;case 320:/*! Production::    ParamPropObj : PROPERTY ":" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-1],,,,yylstack[yysp-1]];break;case 321:/*! Production::    ParamPropObj : PROPERTY ":" Defaults Expression */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-3],,yyvstack[yysp],,yylstack[yysp-3]];break;case 324:/*! Production::    ParamPropObj : ParamIdentifier Defaults Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-2],,yyvstack[yysp]];break;case 325:/*! Production::    ParamPropObj : "..." PROPERTY ":" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-1],,,true,yylstack[yysp-1]];break;case 326:/*! Production::    ParamPropObj : PROPERTY ":" "..." */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=[yyvstack[yysp-2],,,true,yylstack[yysp-2]];break;case 327:/*! Production::    Literal : AlphaNum */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Literal"]("AlphaNum",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["AlphaNum",yylstack[yysp-1]]);break;case 328:/*! Production::    Literal : Regex */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Literal"]("Regex",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Regex",yylstack[yysp-1]]);break;case 329:/*! Production::    Literal : UNDEFINED */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Literal"]("UNDEFINED",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["UNDEFINED",yylstack[yysp-1]]);break;case 330:/*! Production::    Literal : INFINITY */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Literal"]("INFINITY",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["INFINITY",yylstack[yysp-1]]);break;case 331:/*! Production::    Literal : BOOL */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Literal"]("BOOL",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["BOOL",yylstack[yysp-1]]);break;case 332:/*! Production::    Literal : NULL */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Literal"]("NULL",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["NULL",yylstack[yysp-1]]);break;case 333:/*! Production::    Literal : NAN */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Literal"]("NAN",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["NAN",yylstack[yysp-1]]);break;case 334:/*! Production::    AlphaNum : String */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["AlphaNum"]("String",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["String",yylstack[yysp-1]]);break;case 335:/*! Production::    AlphaNum : NUMBER */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["AlphaNum"]("NUMBER",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["NUMBER",yylstack[yysp-1]]);break;case 336:/*! Production::    String : STRING */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["String"]("STRING",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["STRING",yylstack[yysp-1]]);break;case 337:/*! Production::    String : StringWithInterpolations */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["String"]("StringWithInterpolations",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["StringWithInterpolations",yylstack[yysp-1]]);break;case 338:/*! Production::    JSX : JSX_START Interpolations JSX_END */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["JSX"]("JSX_START Interpolations JSX_END",...[yyvstack[yysp-1],yyvstack[yysp-2]]),{rule:"JSX_START Interpolations JSX_END",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["JSX_START",yylstack[yysp-2]],["Interpolations",yylstack[yysp-1]],["JSX_END",yylstack[yysp]]);break;case 339:/*! Production::    StringWithInterpolations : STRING_START Interpolations STRING_END */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["StringWithInterpolations"]("STRING_START Interpolations STRING_END",...[yyvstack[yysp-1],yyvstack[yysp-2]]),{rule:"STRING_START Interpolations STRING_END",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["STRING_START",yylstack[yysp-2]],["Interpolations",yylstack[yysp-1]],["STRING_END",yylstack[yysp]]);break;case 340:/*! Production::    Interpolations : Interpolation */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Interpolations"]("Interpolation",...[yyvstack[yysp]]),{rule:"Interpolation",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Interpolation",yylstack[yysp]]);break;case 341:/*! Production::    Interpolations : Interpolations Interpolation */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Interpolations"]("Interpolations Interpolation",...[...yyvstack[yysp-1].contents,yyvstack[yysp]]),{rule:"Interpolations Interpolation",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Interpolations",yylstack[yysp-1]],["Interpolation",yylstack[yysp]]);break;case 342:/*! Production::    Interpolations : Interpolations INDENT Interpolations OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Interpolations"]("Interpolations INDENT Interpolations OUTDENT",...[...yyvstack[yysp-3].contents,1,...yyvstack[yysp-1].contents,-1]),{rule:"Interpolations INDENT Interpolations OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Interpolations",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Interpolations",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 343:/*! Production::    Interpolation : INTERPOLATION_START Expression INTERPOLATION_END */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Interpolation"]("INTERPOLATION_START Expression INTERPOLATION_END",...[yyvstack[yysp-1]]),{rule:"INTERPOLATION_START Expression INTERPOLATION_END",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["INTERPOLATION_START",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["INTERPOLATION_END",yylstack[yysp]]);break;case 344:/*! Production::    Interpolation : String */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Interpolation"]("String",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["String",yylstack[yysp-1]]);break;case 345:/*! Production::    Regex : REGEX */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Regex"]("REGEX",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["REGEX",yylstack[yysp-1]]);break;case 346:/*! Production::    Regex : RegexWithInterpolations */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Regex"]("RegexWithInterpolations",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["RegexWithInterpolations",yylstack[yysp-1]]);break;case 347:/*! Production::    RegexWithInterpolations : REGEX_START RegexInterpolations REGEX_END */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["RegexWithInterpolations"]("REGEX_START RegexInterpolations REGEX_END",...[yyvstack[yysp-1],yyvstack[yysp]]),{rule:"REGEX_START RegexInterpolations REGEX_END",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["REGEX_START",yylstack[yysp-2]],["RegexInterpolations",yylstack[yysp-1]],["REGEX_END",yylstack[yysp]]);break;case 348:/*! Production::    RegexInterpolations : RegexInterpolation */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["RegexInterpolations"]("RegexInterpolation",...[yyvstack[yysp]]),{rule:"RegexInterpolation",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["RegexInterpolation",yylstack[yysp]]);break;case 349:/*! Production::    RegexInterpolations : RegexInterpolations RegexInterpolation */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["RegexInterpolations"]("RegexInterpolations RegexInterpolation",...[...yyvstack[yysp-1].contents,yyvstack[yysp]]),{rule:"RegexInterpolations RegexInterpolation",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["RegexInterpolations",yylstack[yysp-1]],["RegexInterpolation",yylstack[yysp]]);break;case 350:/*! Production::    RegexInterpolation : INTERPOLATION_START Expression INTERPOLATION_END */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["RegexInterpolation"]("INTERPOLATION_START Expression INTERPOLATION_END",...[yyvstack[yysp-1]]),{rule:"INTERPOLATION_START Expression INTERPOLATION_END",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["INTERPOLATION_START",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["INTERPOLATION_END",yylstack[yysp]]);break;case 351:/*! Production::    RegexInterpolation : Regex */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["RegexInterpolation"]("Regex",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Regex",yylstack[yysp-1]]);break;case 352:/*! Production::    ClassFunctionPrelude : ClassFunctionTag */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ClassFunctionPrelude"]("ClassFunctionTag",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["ClassFunctionTag",yylstack[yysp-1]]);break;case 353:/*! Production::    ClassFunctionPrelude : ClassFunctionPrelude ClassFunctionTag */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassFunctionPrelude"]("ClassFunctionPrelude ClassFunctionTag",...[...yyvstack[yysp-1].addTag(yyvstack[yysp])]),{rule:"ClassFunctionPrelude ClassFunctionTag",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ClassFunctionPrelude",yylstack[yysp-1]],["ClassFunctionTag",yylstack[yysp]]);break;case 354:/*! Production::    ClassFunctionTag : FUNCTION */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassFunctionTag"]("FUNCTION",...[yyvstack[yysp],yylstack[yysp]]),{rule:"FUNCTION",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["FUNCTION",yylstack[yysp]]);break;case 355:/*! Production::    ClassFunctionTag : STATIC */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassFunctionTag"]("STATIC",...[yyvstack[yysp],yylstack[yysp]]),{rule:"STATIC",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["STATIC",yylstack[yysp]]);break;case 356:/*! Production::    ClassFunctionTag : GET */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassFunctionTag"]("GET",...[yyvstack[yysp],yylstack[yysp]]),{rule:"GET",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["GET",yylstack[yysp]]);break;case 357:/*! Production::    ClassFunctionTag : SET */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassFunctionTag"]("SET",...[yyvstack[yysp],yylstack[yysp]]),{rule:"SET",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["SET",yylstack[yysp]]);break;case 358:/*! Production::    ClassFunctionTag : ASYNC */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassFunctionTag"]("ASYNC",...[yyvstack[yysp],yylstack[yysp]]),{rule:"ASYNC",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["ASYNC",yylstack[yysp]]);break;case 359:/*! Production::    FunctionPrelude : FunctionTag */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["FunctionPrelude"]("FunctionTag",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["FunctionTag",yylstack[yysp-1]]);break;case 360:/*! Production::    FunctionPrelude : FunctionPrelude FunctionTag */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionPrelude"]("FunctionPrelude FunctionTag",...[...yyvstack[yysp-1].addTag(yyvstack[yysp])]),{rule:"FunctionPrelude FunctionTag",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FunctionPrelude",yylstack[yysp-1]],["FunctionTag",yylstack[yysp]]);break;case 361:/*! Production::    FunctionTag : FUNCTION */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionTag"]("FUNCTION",...[yyvstack[yysp],yylstack[yysp]]),{rule:"FUNCTION",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["FUNCTION",yylstack[yysp]]);break;case 362:/*! Production::    FunctionTag : ASYNC */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionTag"]("ASYNC",...[yyvstack[yysp],yylstack[yysp]]),{rule:"ASYNC",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["ASYNC",yylstack[yysp]]);break;case 363:/*! Production::    FunctionInterlude : "<(" TypeArguments ")>" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionInterlude"]("<( TypeArguments )>",...[{generics:yyvstack[yysp-1].setLoc(yylstack[yysp-2],yylstack[yysp-1])}]),{rule:"<( TypeArguments )>",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["<(",yylstack[yysp-2]],["TypeArguments",yylstack[yysp-1]],[")>",yylstack[yysp]]);break;case 364:/*! Production::    FunctionInterlude : IDENTIFIER TypeArguments? */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionInterlude"]("IDENTIFIER TypeArguments?",...[{id:yyvstack[yysp-1],generics:yyvstack[yysp].unwrap}]),{rule:"IDENTIFIER TypeArguments?",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IDENTIFIER",yylstack[yysp-1]],["TypeArguments?",yylstack[yysp]]);break;case 365:/*! Production::    FunctionInterlude : IDENTIFIER TypeArguments? Params */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionInterlude"]("IDENTIFIER TypeArguments? Params",...[{id:yyvstack[yysp-2],params:yyvstack[yysp],generics:yyvstack[yysp-1].unwrap}]),{rule:"IDENTIFIER TypeArguments? Params",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IDENTIFIER",yylstack[yysp-2]],["TypeArguments?",yylstack[yysp-1]],["Params",yylstack[yysp]]);break;case 366:/*! Production::    FunctionInterlude : IDENTIFIER TypeArguments? WITH */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionInterlude"]("IDENTIFIER TypeArguments? WITH",...[{id:yyvstack[yysp-2],generics:yyvstack[yysp-1].unwrap}]),{rule:"IDENTIFIER TypeArguments? WITH",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IDENTIFIER",yylstack[yysp-2]],["TypeArguments?",yylstack[yysp-1]],["WITH",yylstack[yysp]]);break;case 367:/*! Production::    FunctionInterlude : IDENTIFIER TypeArguments? WITH Params */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionInterlude"]("IDENTIFIER TypeArguments? WITH Params",...[{id:yyvstack[yysp-3],generics:yyvstack[yysp-2].unwrap,params:yyvstack[yysp]}]),{rule:"IDENTIFIER TypeArguments? WITH Params",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IDENTIFIER",yylstack[yysp-3]],["TypeArguments?",yylstack[yysp-2]],["WITH",yylstack[yysp-1]],["Params",yylstack[yysp]]);break;case 368:/*! Production::    FunctionInterlude : TypeArguments? Params */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionInterlude"]("TypeArguments? Params",...[{generics:yyvstack[yysp-1].unwrap,params:yyvstack[yysp]}]),{rule:"TypeArguments? Params",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp]&&yylstack[yysp].type}},{"first":2,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeArguments?",yylstack[yysp-1]],["Params",yylstack[yysp]]);break;case 369:/*! Production::    FunctionInterlude : TypeArguments? WITH */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionInterlude"]("TypeArguments? WITH",...[{generics:yyvstack[yysp-1].unwrap}]),{rule:"TypeArguments? WITH",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp]&&yylstack[yysp].type}},{"first":2,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeArguments?",yylstack[yysp-1]],["WITH",yylstack[yysp]]);break;case 370:/*! Production::    FunctionInterlude : TypeArguments? WITH Params */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionInterlude"]("TypeArguments? WITH Params",...[{generics:yyvstack[yysp-2].unwrap,params:yyvstack[yysp]}]),{rule:"TypeArguments? WITH Params",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":2,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeArguments?",yylstack[yysp-2]],["WITH",yylstack[yysp-1]],["Params",yylstack[yysp]]);break;case 371:/*! Production::    FunctionPostlude : Expression */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionPostlude"]("Expression",...[yy.Block.wrap(yyvstack[yysp]).setLoc(yylstack[yysp])]),{rule:"Expression",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Expression",yylstack[yysp]]);break;case 372:/*! Production::    FunctionPostlude : Statement */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionPostlude"]("Statement",...[yy.Block.wrap(yyvstack[yysp]).setLoc(yylstack[yysp])]),{rule:"Statement",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Statement",yylstack[yysp]]);break;case 373:/*! Production::    FunctionPostlude : Block */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionPostlude"]("Block",...[yyvstack[yysp].unwrap.setLoc(yylstack[yysp])]),{rule:"Block",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src}},{"first":1,"last":1,"typeOf":0,"checkGenerated":false},{generated:undefined}).setTokens(["Block",yylstack[yysp]]);break;case 374:/*! Production::    FunctionPostlude : THEN Block */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionPostlude"]("THEN Block",...[yyvstack[yysp].unwrap.setLoc(yylstack[yysp-1],yylstack[yysp])]),{rule:"THEN Block",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["THEN",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 375:/*! Production::    FunctionPostlude : THEN Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionPostlude"]("THEN Expression",...[yy.Block.wrap(yyvstack[yysp]).setLoc(yylstack[yysp])]),{rule:"THEN Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["THEN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 376:/*! Production::    FunctionPostlude : THEN Statement */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionPostlude"]("THEN Statement",...[yy.Block.wrap(yyvstack[yysp]).setLoc(yylstack[yysp])]),{rule:"THEN Statement",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["THEN",yylstack[yysp-1]],["Statement",yylstack[yysp]]);break;case 377:/*! Production::    Function : FunctionPrelude FunctionInterlude? FUNC_DIRECTIVE? FunctionPostlude? */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Function"]("FunctionPrelude FunctionInterlude? FUNC_DIRECTIVE? FunctionPostlude?",...[yyvstack[yysp-3],yyvstack[yysp-2].unwrap||{},yyvstack[yysp].unwrap,yyvstack[yysp-1].unwrap]),{rule:"FunctionPrelude FunctionInterlude? FUNC_DIRECTIVE? FunctionPostlude?",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp-3]&&yylstack[yysp-3].last_line,last_column:yylstack[yysp-3]&&yylstack[yysp-3].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FunctionPrelude",yylstack[yysp-3]],["FunctionInterlude?",yylstack[yysp-2]],["FUNC_DIRECTIVE?",yylstack[yysp-1]],["FunctionPostlude?",yylstack[yysp]]);break;case 378:/*! Production::    FunctionInterlude? : %epsilon */ // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(null,null,null,null,true);// END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionInterlude?"]("",...[undefined]),{rule:"",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src}},{"first":0,"last":0,"typeOf":0,"checkGenerated":false},{generated:undefined}).setTokens();break;case 379:/*! Production::    FunctionInterlude? : FunctionInterlude */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["FunctionInterlude?"]("FunctionInterlude",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["FunctionInterlude",yylstack[yysp-1]]);break;case 380:/*! Production::    FunctionPostlude? : %epsilon */ // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(null,null,null,null,true);// END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FunctionPostlude?"]("",...[undefined]),{rule:"",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src}},{"first":0,"last":0,"typeOf":0,"checkGenerated":false},{generated:undefined}).setTokens();break;case 381:/*! Production::    FunctionPostlude? : FunctionPostlude */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["FunctionPostlude?"]("FunctionPostlude",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["FunctionPostlude",yylstack[yysp-1]]);break;case 382:/*! Production::    FUNC_DIRECTIVE? : %epsilon */ // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(null,null,null,null,true);// END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["FUNC_DIRECTIVE?"]("",...[undefined]),{rule:"",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src}},{"first":0,"last":0,"typeOf":0,"checkGenerated":false},{generated:undefined}).setTokens();break;case 383:/*! Production::    FUNC_DIRECTIVE? : FUNC_DIRECTIVE */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["FUNC_DIRECTIVE?"]("FUNC_DIRECTIVE",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["FUNC_DIRECTIVE",yylstack[yysp-1]]);break;case 384:/*! Production::    ClassFunction : ClassFunctionPrelude FunctionInterlude */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassFunction"]("ClassFunctionPrelude FunctionInterlude",...[yyvstack[yysp-1],yyvstack[yysp],yy.Block.wrap()]),{rule:"ClassFunctionPrelude FunctionInterlude",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ClassFunctionPrelude",yylstack[yysp-1]],["FunctionInterlude",yylstack[yysp]]);break;case 385:/*! Production::    ClassFunction : ClassFunctionPrelude FunctionInterlude FunctionPostlude */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassFunction"]("ClassFunctionPrelude FunctionInterlude FunctionPostlude",...[yyvstack[yysp-2],yyvstack[yysp-1],yyvstack[yysp]]),{rule:"ClassFunctionPrelude FunctionInterlude FunctionPostlude",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ClassFunctionPrelude",yylstack[yysp-2]],["FunctionInterlude",yylstack[yysp-1]],["FunctionPostlude",yylstack[yysp]]);break;case 386:/*! Production::    ClassFunction : FunctionInterlude */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassFunction"]("FunctionInterlude",...[new yy.ClassFunctionPrelude(null),yyvstack[yysp],yy.Block.wrap()]),{rule:"FunctionInterlude",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["FunctionInterlude",yylstack[yysp]]);break;case 387:/*! Production::    ClassFunction : FunctionInterlude FunctionPostlude */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassFunction"]("FunctionInterlude FunctionPostlude",...[new yy.ClassFunctionPrelude(null),yyvstack[yysp-1],yyvstack[yysp]]),{rule:"FunctionInterlude FunctionPostlude",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FunctionInterlude",yylstack[yysp-1]],["FunctionPostlude",yylstack[yysp]]);break;case 388:/*! Production::    TypeArguments? : %epsilon */ // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(null,null,null,null,true);// END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeArguments?"]("",...[undefined]),{rule:"",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src}},{"first":0,"last":0,"typeOf":0,"checkGenerated":false},{generated:undefined}).setTokens();break;case 389:/*! Production::    TypeArguments? : "<(" TypeArguments ")>" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeArguments?"]("<( TypeArguments )>",...[yyvstack[yysp-1]]),{rule:"<( TypeArguments )>",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["<(",yylstack[yysp-2]],["TypeArguments",yylstack[yysp-1]],[")>",yylstack[yysp]]);break;case 390:/*! Production::    TypeArguments? : "<(" INDENT TypeArguments OUTDENT ")>" */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeArguments?"]("<( INDENT TypeArguments OUTDENT )>",...[yyvstack[yysp-2]]),{rule:"<( INDENT TypeArguments OUTDENT )>",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["<(",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["TypeArguments",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],[")>",yylstack[yysp]]);break;case 391:/*! Production::    Params : PARAM_START PARAM_END */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Params"]("PARAM_START PARAM_END",...[[]]),{rule:"PARAM_START PARAM_END",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":2,"checkGenerated":false},{generated:undefined}).setTokens(["PARAM_START",yylstack[yysp-1]],["PARAM_END",yylstack[yysp]]);break;case 392:/*! Production::    Params : PARAM_START ParamList PARAM_END */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Params"]("PARAM_START ParamList PARAM_END",...[yyvstack[yysp-1].setLoc(yylstack[yysp-2],yylstack[yysp])]),{rule:"PARAM_START ParamList PARAM_END",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":3,"checkGenerated":false},{generated:undefined}).setTokens(["PARAM_START",yylstack[yysp-2]],["ParamList",yylstack[yysp-1]],["PARAM_END",yylstack[yysp]]);break;case 393:/*! Production::    ParamList : Param */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamList"]("Param",...[yyvstack[yysp]]),{rule:"Param",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Param",yylstack[yysp]]);break;case 394:/*! Production::    ParamList : ParamList "," Param */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamList"]("ParamList , Param",...[...yyvstack[yysp-2].addParam(yyvstack[yysp])]),{rule:"ParamList , Param",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ParamList",yylstack[yysp-2]],[",",yylstack[yysp-1]],["Param",yylstack[yysp]]);break;case 395:/*! Production::    ParamList : ParamList OptComma NEWLINE Param */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamList"]("ParamList OptComma NEWLINE Param",...[...yyvstack[yysp-3].addParam(yyvstack[yysp])]),{rule:"ParamList OptComma NEWLINE Param",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ParamList",yylstack[yysp-3]],["OptComma",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["Param",yylstack[yysp]]);break;case 396:/*! Production::    ParamList : ParamList OptComma INDENT ParamList OptComma OUTDENT */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamList"]("ParamList OptComma INDENT ParamList OptComma OUTDENT",...[...yyvstack[yysp-5].addParams(yyvstack[yysp-2].contents)]),{rule:"ParamList OptComma INDENT ParamList OptComma OUTDENT",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ParamList",yylstack[yysp-5]],["OptComma",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["ParamList",yylstack[yysp-2]],["OptComma",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 397:/*! Production::    Param : ParamAssignable */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Param"]("ParamAssignable",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["ParamAssignable",yylstack[yysp-1]]);break;case 398:/*! Production::    Assign : Assignment */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Assign"]("Assignment",...[yyvstack[yysp]]),{rule:"Assignment",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Assignment",yylstack[yysp]]);break;case 399:/*! Production::    Assignment : Assignable AssignKeyword Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Assignment"]("Assignable AssignKeyword Expression",...[yyvstack[yysp-2],yyvstack[yysp],yyvstack[yysp-1]]),{rule:"Assignable AssignKeyword Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Assignable",yylstack[yysp-2]],["AssignKeyword",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 400:/*! Production::    Assignment : Assignable AssignKeyword INDENT Expression OUTDENT */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Assignment"]("Assignable AssignKeyword INDENT Expression OUTDENT",...[yyvstack[yysp-4],yyvstack[yysp-1],yyvstack[yysp-3]]),{rule:"Assignable AssignKeyword INDENT Expression OUTDENT",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Assignable",yylstack[yysp-4]],["AssignKeyword",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 401:/*! Production::    Assignment : Assignable AssignKeyword NEWLINE Expression */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Assignment"]("Assignable AssignKeyword NEWLINE Expression",...[yyvstack[yysp-3],yyvstack[yysp],yyvstack[yysp-2]]),{rule:"Assignable AssignKeyword NEWLINE Expression",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Assignable",yylstack[yysp-3]],["AssignKeyword",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 402:/*! Production::    Assignment : Assignable AssignKeyword Block */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Assignment"]("Assignable AssignKeyword Block",...[yyvstack[yysp-2],yy.Array.from(yyvstack[yysp]),yyvstack[yysp-1]]),{rule:"Assignable AssignKeyword Block",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Assignable",yylstack[yysp-2]],["AssignKeyword",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 403:/*! Production::    AssignKeyword : AS */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["AssignKeyword"]("AS",...[yylstack[yysp].origin]),{rule:"AS",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["AS",yylstack[yysp]]);break;case 404:/*! Production::    AssignKeyword : AT */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["AssignKeyword"]("AT",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["AT",yylstack[yysp-1]]);break;case 405:/*! Production::    AssignKeyword : FROM */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["AssignKeyword"]("FROM",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["FROM",yylstack[yysp-1]]);break;case 406:/*! Production::    Assignable : Identifier */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Assignable"]("Identifier",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Identifier",yylstack[yysp-1]]);break;case 407:/*! Production::    Assignable : Object */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Assignable"]("Object",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Object",yylstack[yysp-1]]);break;case 408:/*! Production::    Assignable : Array */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Assignable"]("Array",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Array",yylstack[yysp-1]]);break;case 409:/*! Production::    Assignable : Value Access */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Assignable"]("Value Access",...[yyvstack[yysp-1],yyvstack[yysp]]),{rule:"Value Access",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":2,"checkGenerated":false},{generated:undefined}).setTokens(["Value",yylstack[yysp-1]],["Access",yylstack[yysp]]);break;case 410:/*! Production::    Assignable : Expression IN Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Assignable"]("Expression IN Expression",...[yyvstack[yysp],yyvstack[yysp-2]]),{rule:"Expression IN Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Expression",yylstack[yysp-2]],["IN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 411:/*! Production::    Defaults : AS */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Defaults"]("AS",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["AS",yylstack[yysp-1]]);break;case 412:/*! Production::    Defaults : DEFAULTS */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Defaults"]("DEFAULTS",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["DEFAULTS",yylstack[yysp-1]]);break;case 413:/*! Production::    ParamAssignable : ParamIdentifier */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ParamAssignable"]("ParamIdentifier",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["ParamIdentifier",yylstack[yysp-1]]);break;case 414:/*! Production::    ParamAssignable : ParamObject */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ParamAssignable"]("ParamObject",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["ParamObject",yylstack[yysp-1]]);break;case 415:/*! Production::    ParamAssignable : ParamObject Defaults Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy.ParamAssignable('ParamObject',yyvstack[yysp-2].defaults(yyvstack[yysp])).setLocation(yylstack[yysp-2],yylstack[yysp]);break;case 416:/*! Production::    ParamAssignable : ParamArray */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ParamAssignable"]("ParamArray",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["ParamArray",yylstack[yysp-1]]);break;case 417:/*! Production::    ParamAssignable : ParamArray Defaults Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy.ParamAssignable('ParamArray',yyvstack[yysp-2].defaults(yyvstack[yysp])).setLocation(yylstack[yysp-2],yylstack[yysp]);break;case 418:/*! Production::    ParamObject : "{" ParamPropList "}" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamObject"]("{ ParamPropList }",...[yyvstack[yysp-1]]),{rule:"{ ParamPropList }",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":3,"checkGenerated":false},{generated:undefined}).setTokens(["{",yylstack[yysp-2]],["ParamPropList",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 419:/*! Production::    ParamObject : "{" "}" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamObject"]("{ }",...[[]]),{rule:"{ }",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src}},{"first":1,"last":2,"typeOf":0,"checkGenerated":false},{generated:undefined}).setTokens(["{",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 420:/*! Production::    Identifier : IDENTIFIER */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Identifier"]("IDENTIFIER",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["IDENTIFIER",yylstack[yysp-1]]);break;case 421:/*! Production::    ParamIdentifier : IDENTIFIER */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamIdentifier"]("IDENTIFIER",...[yyvstack[yysp]]),{rule:"IDENTIFIER",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["IDENTIFIER",yylstack[yysp]]);break;case 422:/*! Production::    ParamIdentifier : "..." IDENTIFIER */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamIdentifier"]("... IDENTIFIER",...[yyvstack[yysp]]),{rule:"... IDENTIFIER",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":2,"checkGenerated":false,"expansion":true},{generated:undefined}).setTokens(["...",yylstack[yysp-1]],["IDENTIFIER",yylstack[yysp]]);break;case 423:/*! Production::    ParamIdentifier : IDENTIFIER "..." */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamIdentifier"]("IDENTIFIER ...",...[yyvstack[yysp-1]]),{rule:"IDENTIFIER ...",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false,"expansion":true},{generated:undefined}).setTokens(["IDENTIFIER",yylstack[yysp-1]],["...",yylstack[yysp]]);break;case 424:/*! Production::    ParamIdentifier : IDENTIFIER Defaults Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamIdentifier"]("IDENTIFIER Defaults Expression",...[yyvstack[yysp-2],,yyvstack[yysp]]),{rule:"IDENTIFIER Defaults Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IDENTIFIER",yylstack[yysp-2]],["Defaults",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 425:/*! Production::    ParamIdentifier : THIS "." PROPERTY */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamIdentifier"]("THIS . PROPERTY",...[yyvstack[yysp],true]),{rule:"THIS . PROPERTY",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":3,"checkGenerated":false},{generated:undefined}).setTokens(["THIS",yylstack[yysp-2]],[".",yylstack[yysp-1]],["PROPERTY",yylstack[yysp]]);break;case 426:/*! Production::    ParamIdentifier : THIS "." PROPERTY Defaults Expression */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamIdentifier"]("THIS . PROPERTY Defaults Expression",...[yyvstack[yysp-2],true,yyvstack[yysp]]),{rule:"THIS . PROPERTY Defaults Expression",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":3,"checkGenerated":false},{generated:undefined}).setTokens(["THIS",yylstack[yysp-4]],[".",yylstack[yysp-3]],["PROPERTY",yylstack[yysp-2]],["Defaults",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 427:/*! Production::    ParamIdentifier : THIS "." PROPERTY "..." */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamIdentifier"]("THIS . PROPERTY ...",...[yyvstack[yysp-1],true]),{rule:"THIS . PROPERTY ...",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":3,"checkGenerated":false,"expansion":true},{generated:undefined}).setTokens(["THIS",yylstack[yysp-3]],[".",yylstack[yysp-2]],["PROPERTY",yylstack[yysp-1]],["...",yylstack[yysp]]);break;case 428:/*! Production::    ParamIdentifier : "..." THIS "." PROPERTY */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamIdentifier"]("... THIS . PROPERTY",...[yyvstack[yysp],true]),{rule:"... THIS . PROPERTY",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":4,"checkGenerated":false,"expansion":true},{generated:undefined}).setTokens(["...",yylstack[yysp-3]],["THIS",yylstack[yysp-2]],[".",yylstack[yysp-1]],["PROPERTY",yylstack[yysp]]);break;case 429:/*! Production::    ParamIdentifier : THIS */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamIdentifier"]("THIS",...[yyvstack[yysp],,,true]),{rule:"THIS",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["THIS",yylstack[yysp]]);break;case 430:/*! Production::    Access : "." PROPERTY */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Access"](". PROPERTY",...[Object.assign([yyvstack[yysp]],{loc:yylstack[yysp]}),yylstack[yysp-1].origin==='?.']),{rule:". PROPERTY",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":2,"checkGenerated":false},{generated:undefined}).setTokens([".",yylstack[yysp-1]],["PROPERTY",yylstack[yysp]]);break;case 431:/*! Production::    Access : INDEX_START Expression INDEX_END */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Access"]("INDEX_START Expression INDEX_END",...[yyvstack[yysp-1]]),{rule:"INDEX_START Expression INDEX_END",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":3,"checkGenerated":false},{generated:undefined}).setTokens(["INDEX_START",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["INDEX_END",yylstack[yysp]]);break;case 432:/*! Production::    ParamArray : "[" "]" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamArray"]("[ ]",...[/* */]),{rule:"[ ]",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src}},{"first":1,"last":2,"typeOf":0,"checkGenerated":false},{generated:undefined}).setTokens(["[",yylstack[yysp-1]],["]",yylstack[yysp]]);break;case 433:/*! Production::    ParamArray : "[" ParamArrayList OptVoids "]" */case 434:/*! Production::    ParamArray : "[" ParamArrayList OptVoids "]" */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ParamArray"]("[ ParamArrayList OptVoids ]",...[yyvstack[yysp-2]]),{rule:"[ ParamArrayList OptVoids ]",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":4,"checkGenerated":false},{generated:undefined}).setTokens(["[",yylstack[yysp-3]],["ParamArrayList",yylstack[yysp-2]],["OptVoids",yylstack[yysp-1]],["]",yylstack[yysp]]);break;case 435:/*! Production::    Array : "[" "]" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Array"]("[ ]",...[/* */]),{rule:"[ ]",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":1},{generated:yylstack[yysp-1].generated}).setTokens(["[",yylstack[yysp-1]],["]",yylstack[yysp]]);break;case 436:/*! Production::    Array : "[" ArrayList OptVoids "]" */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Array"]("[ ArrayList OptVoids ]",...[...yyvstack[yysp-2]]),{rule:"[ ArrayList OptVoids ]",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":1},{generated:yylstack[yysp-3].generated}).setTokens(["[",yylstack[yysp-3]],["ArrayList",yylstack[yysp-2]],["OptVoids",yylstack[yysp-1]],["]",yylstack[yysp]]);break;case 437:/*! Production::    Array : "[" INDENT ArrayList OptVoids OUTDENT "]" */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Array"]("[ INDENT ArrayList OptVoids OUTDENT ]",...[...yyvstack[yysp-3]]),{rule:"[ INDENT ArrayList OptVoids OUTDENT ]",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":1,"indented":true},{generated:yylstack[yysp-5].generated}).setTokens(["[",yylstack[yysp-5]],["INDENT",yylstack[yysp-4]],["ArrayList",yylstack[yysp-3]],["OptVoids",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["]",yylstack[yysp]]);break;case 438:/*! Production::    ParamArrayList : ParamArrayArg */case 441:/*! Production::    ArrayList : ArrayArg */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=[...yyvstack[yysp]];break;case 439:/*! Production::    ParamArrayList : ParamArrayList "," ParamArrayArg */case 442:/*! Production::    ArrayList : ArrayList "," ArrayArg */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=yyvstack[yysp-2].concat(yyvstack[yysp]);break;case 440:/*! Production::    ParamArrayList : ParamArrayList OptComma NEWLINE ParamArrayArg */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=yyvstack[yysp-3].concat(yyvstack[yysp]);break;case 443:/*! Production::    ArrayList : ArrayList OptComma INDENT ArrayList OptVoids OUTDENT */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=yyvstack[yysp-5].concat(false,yyvstack[yysp-2]);break;case 444:/*! Production::    ArrayList : ArrayList OptComma NEWLINE ArrayArg */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=yyvstack[yysp-3].concat(yylstack[yysp-1].generated,yyvstack[yysp]);break;case 446:/*! Production::    ParamArrayArg : Voids ParamAssignable */case 450:/*! Production::    ArrayArg : Voids Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=[...yyvstack[yysp-1],yyvstack[yysp]];break;case 447:/*! Production::    ArrayArg : "..." Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=[Object.assign(yyvstack[yysp],{expansion:true})];break;case 448:/*! Production::    ArrayArg : Expression "..." */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=[Object.assign(yyvstack[yysp-1],{expansion:true})];break;case 453:/*! Production::    Voids : "," */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=[null];break;case 454:/*! Production::    Voids : "," Voids */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=[null,...yyvstack[yysp-1]];break;case 455:/*! Production::    Voids : "," NEWLINE Voids */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=[null,...yyvstack[yysp-1]];break;case 456:/*! Production::    Statement : Return */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Statement"]("Return",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Return",yylstack[yysp-1]]);break;case 457:/*! Production::    Statement : BREAK Identifier */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Statement"]("BREAK Identifier",...[yyvstack[yysp]]),{rule:"BREAK Identifier",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["BREAK",yylstack[yysp-1]],["Identifier",yylstack[yysp]]);break;case 458:/*! Production::    Statement : BREAK */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Statement"]("BREAK",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["BREAK",yylstack[yysp-1]]);break;case 459:/*! Production::    Statement : CONTINUE Identifier */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Statement"]("CONTINUE Identifier",...[yyvstack[yysp]]),{rule:"CONTINUE Identifier",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["CONTINUE",yylstack[yysp-1]],["Identifier",yylstack[yysp]]);break;case 460:/*! Production::    Statement : CONTINUE */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Statement"]("CONTINUE",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["CONTINUE",yylstack[yysp-1]]);break;case 461:/*! Production::    Statement : Import */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Statement"]("Import",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Import",yylstack[yysp-1]]);break;case 462:/*! Production::    Statement : Export */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Statement"]("Export",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Export",yylstack[yysp-1]]);break;case 463:/*! Production::    Statement : Declare */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Statement"]("Declare",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Declare",yylstack[yysp-1]]);break;case 464:/*! Production::    Statement : THROW Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Statement"]("THROW Expression",...[yyvstack[yysp]]),{rule:"THROW Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["THROW",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 465:/*! Production::    Statement : THROW INDENT Expression OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Statement"]("THROW INDENT Expression OUTDENT",...[yyvstack[yysp-1]]),{rule:"THROW INDENT Expression OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["THROW",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 466:/*! Production::    Statement : DELETE Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Statement"]("DELETE Expression",...[yyvstack[yysp]]),{rule:"DELETE Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["DELETE",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 467:/*! Production::    Statement : Type */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Statement"]("Type",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Type",yylstack[yysp-1]]);break;case 468:/*! Production::    Statement : Interface */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Statement"]("Interface",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Interface",yylstack[yysp-1]]);break;case 469:/*! Production::    Interface : INTERFACE Identifier TypeArguments? IntExtends? InterfaceBody */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Interface"]("INTERFACE Identifier TypeArguments? IntExtends? InterfaceBody",...[yyvstack[yysp-3],yyvstack[yysp-2],yyvstack[yysp],yyvstack[yysp-1].unwrap]),{rule:"INTERFACE Identifier TypeArguments? IntExtends? InterfaceBody",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["INTERFACE",yylstack[yysp-4]],["Identifier",yylstack[yysp-3]],["TypeArguments?",yylstack[yysp-2]],["IntExtends?",yylstack[yysp-1]],["InterfaceBody",yylstack[yysp]]);break;case 470:/*! Production::    Interface : INTERFACE Identifier TypeArguments? IntExtends? INDENT InterfaceBody OUTDENT */ // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-6,yysp);// END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Interface"]("INTERFACE Identifier TypeArguments? IntExtends? INDENT InterfaceBody OUTDENT",...[yyvstack[yysp-5],yyvstack[yysp-4],yyvstack[yysp-1],yyvstack[yysp-3].unwrap]),{rule:"INTERFACE Identifier TypeArguments? IntExtends? INDENT InterfaceBody OUTDENT",loc:{first_line:yylstack[yysp-6]&&yylstack[yysp-6].first_line,first_column:yylstack[yysp-6]&&yylstack[yysp-6].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-6]&&yylstack[yysp-6].src,type:yylstack[yysp-6]&&yylstack[yysp-6].type||yylstack[yysp-6]&&yylstack[yysp-6].type}},{"first":1,"last":7,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["INTERFACE",yylstack[yysp-6]],["Identifier",yylstack[yysp-5]],["TypeArguments?",yylstack[yysp-4]],["IntExtends?",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["InterfaceBody",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 471:/*! Production::    IntExtends? : %epsilon */ // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(null,null,null,null,true);// END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IntExtends?"]("",...[undefined]),{rule:"",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src}},{"first":0,"last":0,"typeOf":0,"checkGenerated":false},{generated:undefined}).setTokens();break;case 472:/*! Production::    IntExtends? : EXTENDS ExtendsNames */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IntExtends?"]("EXTENDS ExtendsNames",...[yyvstack[yysp]]),{rule:"EXTENDS ExtendsNames",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["EXTENDS",yylstack[yysp-1]],["ExtendsNames",yylstack[yysp]]);break;case 473:/*! Production::    ClassImplements? : %epsilon */ // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(null,null,null,null,true);// END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassImplements?"]("",...[undefined]),{rule:"",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src}},{"first":0,"last":0,"typeOf":0,"checkGenerated":false},{generated:undefined}).setTokens();break;case 474:/*! Production::    ClassImplements? : IMPLEMENTS ExtendsNames */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ClassImplements?"]("IMPLEMENTS ExtendsNames",...[yyvstack[yysp]]),{rule:"IMPLEMENTS ExtendsNames",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IMPLEMENTS",yylstack[yysp-1]],["ExtendsNames",yylstack[yysp]]);break;case 475:/*! Production::    ExtendsNames : ExtendsNames "," ExtendsName */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ExtendsNames"]("ExtendsNames , ExtendsName",...[...yyvstack[yysp-2].contents,yyvstack[yysp]]),{rule:"ExtendsNames , ExtendsName",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ExtendsNames",yylstack[yysp-2]],[",",yylstack[yysp-1]],["ExtendsName",yylstack[yysp]]);break;case 476:/*! Production::    ExtendsNames : ExtendsNames OptComma NEWLINE ExtendsName */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ExtendsNames"]("ExtendsNames OptComma NEWLINE ExtendsName",...[...yyvstack[yysp-3].contents,yyvstack[yysp]]),{rule:"ExtendsNames OptComma NEWLINE ExtendsName",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ExtendsNames",yylstack[yysp-3]],["OptComma",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["ExtendsName",yylstack[yysp]]);break;case 477:/*! Production::    ExtendsNames : ExtendsName */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ExtendsNames"]("ExtendsName",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["ExtendsName",yylstack[yysp-1]]);break;case 478:/*! Production::    ExtendsName : Identifier TypeArguments? */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ExtendsName"]("Identifier TypeArguments?",...[yyvstack[yysp-1],yyvstack[yysp].unwrap]),{rule:"Identifier TypeArguments?",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Identifier",yylstack[yysp-1]],["TypeArguments?",yylstack[yysp]]);break;case 479:/*! Production::    InterfaceBody : %epsilon */ // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(null,null,null,null,true);// END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceBody"]("",...[[]]),{rule:"",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src}},{"first":0,"last":0,"typeOf":0,"checkGenerated":false},{generated:undefined}).setTokens();break;case 480:/*! Production::    InterfaceBody : "{" "}" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceBody"]("{ }",...[[]]),{rule:"{ }",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 481:/*! Production::    InterfaceBody : InterfaceBody OptComma NEWLINE InterfaceBody */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceBody"]("InterfaceBody OptComma NEWLINE InterfaceBody",...[[...yyvstack[yysp-3].unwrap,...yyvstack[yysp].unwrap]]),{rule:"InterfaceBody OptComma NEWLINE InterfaceBody",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["InterfaceBody",yylstack[yysp-3]],["OptComma",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["InterfaceBody",yylstack[yysp]]);break;case 482:/*! Production::    InterfaceBody : "{" InterfaceProperties "}" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceBody"]("{ InterfaceProperties }",...[yyvstack[yysp-1].contents]),{rule:"{ InterfaceProperties }",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{",yylstack[yysp-2]],["InterfaceProperties",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 483:/*! Production::    InterfaceBody : "{" INDENT InterfaceProperties OUTDENT "}" */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceBody"]("{ INDENT InterfaceProperties OUTDENT }",...[yyvstack[yysp-2].contents]),{rule:"{ INDENT InterfaceProperties OUTDENT }",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["InterfaceProperties",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 484:/*! Production::    InterfaceBody : InterfaceProperties */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceBody"]("InterfaceProperties",...[yyvstack[yysp].contents]),{rule:"InterfaceProperties",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["InterfaceProperties",yylstack[yysp]]);break;case 485:/*! Production::    InterfaceBody : INDENT InterfaceProperties OUTDENT */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceBody"]("INDENT InterfaceProperties OUTDENT",...[yyvstack[yysp-1].contents]),{rule:"INDENT InterfaceProperties OUTDENT",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["INDENT",yylstack[yysp-2]],["InterfaceProperties",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 486:/*! Production::    InterfaceProperties : InterfaceProperty */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["InterfaceProperties"]("InterfaceProperty",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["InterfaceProperty",yylstack[yysp-1]]);break;case 487:/*! Production::    InterfaceProperties : InterfaceProperties "," InterfaceProperty */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperties"]("InterfaceProperties , InterfaceProperty",...[...yyvstack[yysp-2].contents,yyvstack[yysp]]),{rule:"InterfaceProperties , InterfaceProperty",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["InterfaceProperties",yylstack[yysp-2]],[",",yylstack[yysp-1]],["InterfaceProperty",yylstack[yysp]]);break;case 488:/*! Production::    InterfaceProperties : InterfaceProperties OptComma NEWLINE InterfaceProperty */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperties"]("InterfaceProperties OptComma NEWLINE InterfaceProperty",...[...yyvstack[yysp-3].contents,yyvstack[yysp]]),{rule:"InterfaceProperties OptComma NEWLINE InterfaceProperty",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["InterfaceProperties",yylstack[yysp-3]],["OptComma",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["InterfaceProperty",yylstack[yysp]]);break;case 489:/*! Production::    InterfaceProperties : InterfaceProperties OptComma INDENT InterfaceProperties OUTDENT */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperties"]("InterfaceProperties OptComma INDENT InterfaceProperties OUTDENT",...[...yyvstack[yysp-4].contents,...yyvstack[yysp-1].contents]),{rule:"InterfaceProperties OptComma INDENT InterfaceProperties OUTDENT",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["InterfaceProperties",yylstack[yysp-4]],["OptComma",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["InterfaceProperties",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 490:/*! Production::    InterfaceProperties : InterfaceProperties "," "{" InterfaceProperties "}" */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperties"]("InterfaceProperties , { InterfaceProperties }",...[...yyvstack[yysp-4].contents,...yyvstack[yysp-1].contents]),{rule:"InterfaceProperties , { InterfaceProperties }",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["InterfaceProperties",yylstack[yysp-4]],[",",yylstack[yysp-3]],["{",yylstack[yysp-2]],["InterfaceProperties",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 491:/*! Production::    InterfaceProperties : InterfaceProperties OptComma NEWLINE "{" InterfaceProperties "}" */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperties"]("InterfaceProperties OptComma NEWLINE { InterfaceProperties }",...[...yyvstack[yysp-5].contents,...yyvstack[yysp-1].contents]),{rule:"InterfaceProperties OptComma NEWLINE { InterfaceProperties }",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["InterfaceProperties",yylstack[yysp-5]],["OptComma",yylstack[yysp-4]],["NEWLINE",yylstack[yysp-3]],["{",yylstack[yysp-2]],["InterfaceProperties",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 492:/*! Production::    InterfaceProperties : InterfaceProperties OptComma INDENT "{" InterfaceProperties "}" OUTDENT */ // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-6,yysp);// END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperties"]("InterfaceProperties OptComma INDENT { InterfaceProperties } OUTDENT",...[...yyvstack[yysp-6].contents,...yyvstack[yysp-2].contents]),{rule:"InterfaceProperties OptComma INDENT { InterfaceProperties } OUTDENT",loc:{first_line:yylstack[yysp-6]&&yylstack[yysp-6].first_line,first_column:yylstack[yysp-6]&&yylstack[yysp-6].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-6]&&yylstack[yysp-6].src,type:yylstack[yysp-6]&&yylstack[yysp-6].type||yylstack[yysp-6]&&yylstack[yysp-6].type}},{"first":1,"last":7,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["InterfaceProperties",yylstack[yysp-6]],["OptComma",yylstack[yysp-5]],["INDENT",yylstack[yysp-4]],["{",yylstack[yysp-3]],["InterfaceProperties",yylstack[yysp-2]],["}",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 493:/*! Production::    InterfaceProperties : InterfaceProperties OptComma INDENT "{" INDENT InterfaceProperties OUTDENT "}" OUTDENT */ // default action (generated by JISON mode classic/merge :: 9,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-8,yysp);// END of default action (generated by JISON mode classic/merge :: 9,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperties"]("InterfaceProperties OptComma INDENT { INDENT InterfaceProperties OUTDENT } OUTDENT",...[...yyvstack[yysp-8].contents,...yyvstack[yysp-3].contents]),{rule:"InterfaceProperties OptComma INDENT { INDENT InterfaceProperties OUTDENT } OUTDENT",loc:{first_line:yylstack[yysp-8]&&yylstack[yysp-8].first_line,first_column:yylstack[yysp-8]&&yylstack[yysp-8].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-8]&&yylstack[yysp-8].src,type:yylstack[yysp-8]&&yylstack[yysp-8].type||yylstack[yysp-8]&&yylstack[yysp-8].type}},{"first":1,"last":9,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["InterfaceProperties",yylstack[yysp-8]],["OptComma",yylstack[yysp-7]],["INDENT",yylstack[yysp-6]],["{",yylstack[yysp-5]],["INDENT",yylstack[yysp-4]],["InterfaceProperties",yylstack[yysp-3]],["OUTDENT",yylstack[yysp-2]],["}",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 494:/*! Production::    InterfaceProperty : READONLY Identifier IntTypeSentence? */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperty"]("READONLY Identifier IntTypeSentence?",...[yyvstack[yysp-1],yyvstack[yysp].unwrap||yylstack[yysp-1].type,{readonly:true}]),{rule:"READONLY Identifier IntTypeSentence?",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["READONLY",yylstack[yysp-2]],["Identifier",yylstack[yysp-1]],["IntTypeSentence?",yylstack[yysp]]);break;case 495:/*! Production::    InterfaceProperty : READONLY PROPERTY ":" InlineType */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperty"]("READONLY PROPERTY : InlineType",...[new yy.Identifier(null,yyvstack[yysp-2]).setLoc(yylstack[yysp-2]),yyvstack[yysp],{readonly:true}]),{rule:"READONLY PROPERTY : InlineType",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["READONLY",yylstack[yysp-3]],["PROPERTY",yylstack[yysp-2]],[":",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 496:/*! Production::    InterfaceProperty : READONLY "[" Identifier "]" IntTypeSentence? */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperty"]("READONLY [ Identifier ] IntTypeSentence?",...[yyvstack[yysp-2],yyvstack[yysp].unwrap||yylstack[yysp-1].type,{readonly:true,indexed:true}]),{rule:"READONLY [ Identifier ] IntTypeSentence?",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["READONLY",yylstack[yysp-4]],["[",yylstack[yysp-3]],["Identifier",yylstack[yysp-2]],["]",yylstack[yysp-1]],["IntTypeSentence?",yylstack[yysp]]);break;case 497:/*! Production::    InterfaceProperty : READONLY "[" "{" PROPERTY ":" TypeSentence "}" "]" IntTypeSentence? */ // default action (generated by JISON mode classic/merge :: 9,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-8,yysp);// END of default action (generated by JISON mode classic/merge :: 9,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperty"]("READONLY [ { PROPERTY : TypeSentence } ] IntTypeSentence?",...[new yy.Identifier(null,yyvstack[yysp-5]).setLoc({...yylstack[yysp-5],type:{nodes:yyvstack[yysp-3],loc:yylstack[yysp-3]}}),yyvstack[yysp].unwrap||yylstack[yysp-1].type,{readonly:true,indexed:true}]),{rule:"READONLY [ { PROPERTY : TypeSentence } ] IntTypeSentence?",loc:{first_line:yylstack[yysp-8]&&yylstack[yysp-8].first_line,first_column:yylstack[yysp-8]&&yylstack[yysp-8].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-8]&&yylstack[yysp-8].src,type:yylstack[yysp-8]&&yylstack[yysp-8].type||yylstack[yysp-8]&&yylstack[yysp-8].type}},{"first":1,"last":8,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["READONLY",yylstack[yysp-8]],["[",yylstack[yysp-7]],["{",yylstack[yysp-6]],["PROPERTY",yylstack[yysp-5]],[":",yylstack[yysp-4]],["TypeSentence",yylstack[yysp-3]],["}",yylstack[yysp-2]],["]",yylstack[yysp-1]],["IntTypeSentence?",yylstack[yysp]]);break;case 498:/*! Production::    InterfaceProperty : NEW TypeArguments? Params IntTypeSentence? */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperty"]("NEW TypeArguments? Params IntTypeSentence?",...[null,yyvstack[yysp].unwrap||yylstack[yysp-1].type,{news:true,params:yyvstack[yysp-1],args:yyvstack[yysp-2].unwrap}]),{rule:"NEW TypeArguments? Params IntTypeSentence?",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["NEW",yylstack[yysp-3]],["TypeArguments?",yylstack[yysp-2]],["Params",yylstack[yysp-1]],["IntTypeSentence?",yylstack[yysp]]);break;case 499:/*! Production::    InterfaceProperty : IntTypeSpecifiers Identifier TypeArguments? Params IntTypeSentence? */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperty"]("IntTypeSpecifiers Identifier TypeArguments? Params IntTypeSentence?",...[yyvstack[yysp-3],yyvstack[yysp].unwrap||yylstack[yysp-1].type,{...yyvstack[yysp-4].unwrap,params:yyvstack[yysp-1],args:yyvstack[yysp-2]}]),{rule:"IntTypeSpecifiers Identifier TypeArguments? Params IntTypeSentence?",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":2,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IntTypeSpecifiers",yylstack[yysp-4]],["Identifier",yylstack[yysp-3]],["TypeArguments?",yylstack[yysp-2]],["Params",yylstack[yysp-1]],["IntTypeSentence?",yylstack[yysp]]);break;case 500:/*! Production::    InterfaceProperty : Identifier TypeArguments? Params IntTypeSentence? */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperty"]("Identifier TypeArguments? Params IntTypeSentence?",...[yyvstack[yysp-3],yyvstack[yysp].unwrap||yylstack[yysp-1].type,{params:yyvstack[yysp-1],args:yyvstack[yysp-2]}]),{rule:"Identifier TypeArguments? Params IntTypeSentence?",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Identifier",yylstack[yysp-3]],["TypeArguments?",yylstack[yysp-2]],["Params",yylstack[yysp-1]],["IntTypeSentence?",yylstack[yysp]]);break;case 501:/*! Production::    InterfaceProperty : Identifier IntTypeSentence? */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperty"]("Identifier IntTypeSentence?",...[yyvstack[yysp-1],yyvstack[yysp].unwrap||yylstack[yysp-1].type,{}]),{rule:"Identifier IntTypeSentence?",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Identifier",yylstack[yysp-1]],["IntTypeSentence?",yylstack[yysp]]);break;case 502:/*! Production::    InterfaceProperty : PROPERTY ":" InlineType */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperty"]("PROPERTY : InlineType",...[new yy.Identifier(null,yyvstack[yysp-2]).setLoc(yylstack[yysp-2]),Object.assign(yyvstack[yysp],{optional:yylstack[yysp-1].origin==="?:"})]),{rule:"PROPERTY : InlineType",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PROPERTY",yylstack[yysp-2]],[":",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 503:/*! Production::    InterfaceProperty : "[" Identifier "]" IntTypeSentence? */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperty"]("[ Identifier ] IntTypeSentence?",...[yyvstack[yysp-2],yyvstack[yysp].unwrap||yylstack[yysp-1].type,{indexed:true}]),{rule:"[ Identifier ] IntTypeSentence?",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["[",yylstack[yysp-3]],["Identifier",yylstack[yysp-2]],["]",yylstack[yysp-1]],["IntTypeSentence?",yylstack[yysp]]);break;case 504:/*! Production::    InterfaceProperty : "[" "{" PROPERTY ":" TypeSentence "}" "]" IntTypeSentence? */ // default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-7,yysp);// END of default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InterfaceProperty"]("[ { PROPERTY : TypeSentence } ] IntTypeSentence?",...[Object.assign(new yy.Identifier(null,yyvstack[yysp-5]).setLoc({...yylstack[yysp-5],type:{nodes:yyvstack[yysp-3],loc:yylstack[yysp-3]}}),{optional:yylstack[yysp-4].origin==="?:"}),yyvstack[yysp].unwrap||yylstack[yysp-1].type,{indexed:true}]),{rule:"[ { PROPERTY : TypeSentence } ] IntTypeSentence?",loc:{first_line:yylstack[yysp-7]&&yylstack[yysp-7].first_line,first_column:yylstack[yysp-7]&&yylstack[yysp-7].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-7]&&yylstack[yysp-7].src,type:yylstack[yysp-7]&&yylstack[yysp-7].type||yylstack[yysp-7]&&yylstack[yysp-7].type}},{"first":1,"last":7,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["[",yylstack[yysp-7]],["{",yylstack[yysp-6]],["PROPERTY",yylstack[yysp-5]],[":",yylstack[yysp-4]],["TypeSentence",yylstack[yysp-3]],["}",yylstack[yysp-2]],["]",yylstack[yysp-1]],["IntTypeSentence?",yylstack[yysp]]);break;case 505:/*! Production::    IntTypeSentence? : %epsilon */ // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(null,null,null,null,true);// END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IntTypeSentence?"]("",...[undefined]),{rule:"",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src}},{"first":0,"last":0,"typeOf":0,"checkGenerated":false},{generated:undefined}).setTokens();break;case 506:/*! Production::    IntTypeSentence? : ":" InlineType */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IntTypeSentence?"](": InlineType",...[Object.assign(yyvstack[yysp],{optional:yylstack[yysp-1].origin==="?:"})]),{rule:": InlineType",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens([":",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 507:/*! Production::    IntTypeSentence? : ":" INDENT TypeSentence OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IntTypeSentence?"](": INDENT TypeSentence OUTDENT",...[Object.assign(yyvstack[yysp-1],{optional:yylstack[yysp-3].origin==="?:"})]),{rule:": INDENT TypeSentence OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens([":",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["TypeSentence",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 508:/*! Production::    IntTypeSentence? : ":" NEWLINE InlineType */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IntTypeSentence?"](": NEWLINE InlineType",...[Object.assign(yyvstack[yysp],{optional:yylstack[yysp-2].origin==="?:"})]),{rule:": NEWLINE InlineType",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens([":",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 509:/*! Production::    IntTypeSpecifiers : GET */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IntTypeSpecifiers"]("GET",...[{getter:true}]),{rule:"GET",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["GET",yylstack[yysp]]);break;case 510:/*! Production::    IntTypeSpecifiers : SET */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["IntTypeSpecifiers"]("SET",...[{setter:true}]),{rule:"SET",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["SET",yylstack[yysp]]);break;case 511:/*! Production::    Type : TYPE TypeDeclaration */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Type"]("TYPE TypeDeclaration",...[yyvstack[yysp]]),{rule:"TYPE TypeDeclaration",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TYPE",yylstack[yysp-1]],["TypeDeclaration",yylstack[yysp]]);break;case 512:/*! Production::    Type : TYPE INDENT TypeDeclaration OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Type"]("TYPE INDENT TypeDeclaration OUTDENT",...[yyvstack[yysp-1]]),{rule:"TYPE INDENT TypeDeclaration OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TYPE",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["TypeDeclaration",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 513:/*! Production::    Type : TYPE NEWLINE TypeDeclaration */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Type"]("TYPE NEWLINE TypeDeclaration",...[yyvstack[yysp]]),{rule:"TYPE NEWLINE TypeDeclaration",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TYPE",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["TypeDeclaration",yylstack[yysp]]);break;case 514:/*! Production::    TypeDeclaration : Identifier TypeArguments? AS InlineType */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeDeclaration"]("Identifier TypeArguments? AS InlineType",...[yyvstack[yysp-3],yyvstack[yysp],yyvstack[yysp-2].unwrap]),{rule:"Identifier TypeArguments? AS InlineType",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Identifier",yylstack[yysp-3]],["TypeArguments?",yylstack[yysp-2]],["AS",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 515:/*! Production::    TypeDeclaration : Identifier TypeArguments? AS INDENT TypeSentence OUTDENT */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeDeclaration"]("Identifier TypeArguments? AS INDENT TypeSentence OUTDENT",...[yyvstack[yysp-5],yyvstack[yysp-1],yyvstack[yysp-4].unwrap]),{rule:"Identifier TypeArguments? AS INDENT TypeSentence OUTDENT",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Identifier",yylstack[yysp-5]],["TypeArguments?",yylstack[yysp-4]],["AS",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["TypeSentence",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 516:/*! Production::    TypeDeclaration : Identifier TypeArguments? AS NEWLINE TypeSentence */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeDeclaration"]("Identifier TypeArguments? AS NEWLINE TypeSentence",...[yyvstack[yysp-4],yyvstack[yysp],yyvstack[yysp-3].unwrap]),{rule:"Identifier TypeArguments? AS NEWLINE TypeSentence",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Identifier",yylstack[yysp-4]],["TypeArguments?",yylstack[yysp-3]],["AS",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["TypeSentence",yylstack[yysp]]);break;case 517:/*! Production::    TypeSentence : TypeValue */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeSentence"]("TypeValue",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TypeValue",yylstack[yysp-1]]);break;case 518:/*! Production::    TypeSentence : TYPE_JOIN */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeSentence"]("TYPE_JOIN",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TYPE_JOIN",yylstack[yysp-1]]);break;case 519:/*! Production::    TypeSentence : TypeSentence TypeValue */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeSentence"]("TypeSentence TypeValue",...[...yyvstack[yysp-1].contents,yyvstack[yysp]]),{rule:"TypeSentence TypeValue",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeSentence",yylstack[yysp-1]],["TypeValue",yylstack[yysp]]);break;case 520:/*! Production::    TypeSentence : TypeSentence TYPE_JOIN */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeSentence"]("TypeSentence TYPE_JOIN",...[...yyvstack[yysp-1].contents,yyvstack[yysp]]),{rule:"TypeSentence TYPE_JOIN",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeSentence",yylstack[yysp-1]],["TYPE_JOIN",yylstack[yysp]]);break;case 521:/*! Production::    TypeSentence : TypeSentence INDENT TypeSentence OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeSentence"]("TypeSentence INDENT TypeSentence OUTDENT",...[...yyvstack[yysp-3].contents,1,...yyvstack[yysp-1].contents,-1]),{rule:"TypeSentence INDENT TypeSentence OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeSentence",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["TypeSentence",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 522:/*! Production::    TypeSentence : TypeSentence NEWLINE TypeValue */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeSentence"]("TypeSentence NEWLINE TypeValue",...[...yyvstack[yysp-2].contents,0,yyvstack[yysp]]),{rule:"TypeSentence NEWLINE TypeValue",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeSentence",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["TypeValue",yylstack[yysp]]);break;case 523:/*! Production::    TypeSentence : TypeSentence NEWLINE TYPE_JOIN */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeSentence"]("TypeSentence NEWLINE TYPE_JOIN",...[...yyvstack[yysp-2].contents,0,yyvstack[yysp]]),{rule:"TypeSentence NEWLINE TYPE_JOIN",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeSentence",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["TYPE_JOIN",yylstack[yysp]]);break;case 524:/*! Production::    TypeValue : TypeArray */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeValue"]("TypeArray",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TypeArray",yylstack[yysp-1]]);break;case 525:/*! Production::    TypeValue : TypeObject */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeValue"]("TypeObject",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TypeObject",yylstack[yysp-1]]);break;case 526:/*! Production::    TypeValue : Literal */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeValue"]("Literal",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Literal",yylstack[yysp-1]]);break;case 527:/*! Production::    TypeValue : Identifier */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeValue"]("Identifier",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Identifier",yylstack[yysp-1]]);break;case 528:/*! Production::    TypeValue : VOID */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeValue"]("VOID",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["VOID",yylstack[yysp-1]]);break;case 529:/*! Production::    TypeValue : TAG */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeValue"]("TAG",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TAG",yylstack[yysp-1]]);break;case 530:/*! Production::    TypeValue : TypeWithArguments */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeValue"]("TypeWithArguments",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TypeWithArguments",yylstack[yysp-1]]);break;case 531:/*! Production::    TypeValue : TypeAccess */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeValue"]("TypeAccess",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TypeAccess",yylstack[yysp-1]]);break;case 532:/*! Production::    TypeValue : TypeFunction */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeValue"]("TypeFunction",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TypeFunction",yylstack[yysp-1]]);break;case 533:/*! Production::    TypeValue : TypeofKeyof */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeValue"]("TypeofKeyof",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TypeofKeyof",yylstack[yysp-1]]);break;case 534:/*! Production::    TypeValue : TypeWrapped */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeValue"]("TypeWrapped",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TypeWrapped",yylstack[yysp-1]]);break;case 535:/*! Production::    TypeofKeyof : KEYOF TypeValue */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeofKeyof"]("KEYOF TypeValue",...[yyvstack[yysp],yyvstack[yysp-1]]),{rule:"KEYOF TypeValue",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["KEYOF",yylstack[yysp-1]],["TypeValue",yylstack[yysp]]);break;case 536:/*! Production::    TypeofKeyof : TYPEOF TypeValue */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeofKeyof"]("TYPEOF TypeValue",...[yyvstack[yysp],yyvstack[yysp-1]]),{rule:"TYPEOF TypeValue",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TYPEOF",yylstack[yysp-1]],["TypeValue",yylstack[yysp]]);break;case 537:/*! Production::    TypeWrapped : "(" TypeSentence ")" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeWrapped"]("( TypeSentence )",...[yyvstack[yysp-1]]),{rule:"( TypeSentence )",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["(",yylstack[yysp-2]],["TypeSentence",yylstack[yysp-1]],[")",yylstack[yysp]]);break;case 538:/*! Production::    TypeWrapped : "(" INDENT TypeSentence OUTDENT ")" */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeWrapped"]("( INDENT TypeSentence OUTDENT )",...[yyvstack[yysp-2]]),{rule:"( INDENT TypeSentence OUTDENT )",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false,"indented":true},{generated:undefined}).setTokens(["(",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["TypeSentence",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],[")",yylstack[yysp]]);break;case 539:/*! Production::    TypeAccess : TypeValue INDEX_START TypeSentence INDEX_END */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeAccess"]("TypeValue INDEX_START TypeSentence INDEX_END",...[yyvstack[yysp-3],yyvstack[yysp-1]]),{rule:"TypeValue INDEX_START TypeSentence INDEX_END",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeValue",yylstack[yysp-3]],["INDEX_START",yylstack[yysp-2]],["TypeSentence",yylstack[yysp-1]],["INDEX_END",yylstack[yysp]]);break;case 540:/*! Production::    TypeAccess : TypeValue INDEX_START INDENT TypeSentence OUTDENT INDEX_END */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeAccess"]("TypeValue INDEX_START INDENT TypeSentence OUTDENT INDEX_END",...[yyvstack[yysp-5],yyvstack[yysp-3]]),{rule:"TypeValue INDEX_START INDENT TypeSentence OUTDENT INDEX_END",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false,"indented":true},{generated:undefined}).setTokens(["TypeValue",yylstack[yysp-5]],["INDEX_START",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["TypeSentence",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["INDEX_END",yylstack[yysp]]);break;case 541:/*! Production::    TypeAccess : TypeValue "." PROPERTY */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeAccess"]("TypeValue . PROPERTY",...[yyvstack[yysp-2],new yy.String('STRING',"'"+yyvstack[yysp]+"'").setLoc(yylstack[yysp])]),{rule:"TypeValue . PROPERTY",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeValue",yylstack[yysp-2]],[".",yylstack[yysp-1]],["PROPERTY",yylstack[yysp]]);break;case 542:/*! Production::    TypeAccess : TypeValue IN TypeValue */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeAccess"]("TypeValue IN TypeValue",...[yyvstack[yysp],new yy.TypeSentence('TypeValue',yyvstack[yysp-2]).setLoc(yylstack[yysp-2])]),{rule:"TypeValue IN TypeValue",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeValue",yylstack[yysp-2]],["IN",yylstack[yysp-1]],["TypeValue",yylstack[yysp]]);break;case 543:/*! Production::    TypeFunction : Params FUNC_DIRECTIVE InlineType */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeFunction"]("Params FUNC_DIRECTIVE InlineType",...[yyvstack[yysp-2],yyvstack[yysp]]),{rule:"Params FUNC_DIRECTIVE InlineType",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Params",yylstack[yysp-2]],["FUNC_DIRECTIVE",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 544:/*! Production::    TypeFunction : FUNC_DIRECTIVE InlineType */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeFunction"]("FUNC_DIRECTIVE InlineType",...[new yy.Params(null,[]),yyvstack[yysp]]),{rule:"FUNC_DIRECTIVE InlineType",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["FUNC_DIRECTIVE",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 545:/*! Production::    TypeFunction : NEW Params FUNC_DIRECTIVE InlineType */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeFunction"]("NEW Params FUNC_DIRECTIVE InlineType",...[yyvstack[yysp-2],yyvstack[yysp],yyvstack[yysp-3]]),{rule:"NEW Params FUNC_DIRECTIVE InlineType",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["NEW",yylstack[yysp-3]],["Params",yylstack[yysp-2]],["FUNC_DIRECTIVE",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 546:/*! Production::    TypeFunction : NEW FUNC_DIRECTIVE InlineType */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeFunction"]("NEW FUNC_DIRECTIVE InlineType",...[new yy.Params(null,[]),yyvstack[yysp],yyvstack[yysp-2]]),{rule:"NEW FUNC_DIRECTIVE InlineType",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["NEW",yylstack[yysp-2]],["FUNC_DIRECTIVE",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 547:/*! Production::    TypeWithArguments : TypeValue INDEX_START INDEX_END */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeWithArguments"]("TypeValue INDEX_START INDEX_END",...[{isArray:true,type:yyvstack[yysp-2]}]),{rule:"TypeValue INDEX_START INDEX_END",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeValue",yylstack[yysp-2]],["INDEX_START",yylstack[yysp-1]],["INDEX_END",yylstack[yysp]]);break;case 548:/*! Production::    TypeWithArguments : Identifier "<(" TypeArguments ")>" */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeWithArguments"]("Identifier <( TypeArguments )>",...[{type:yyvstack[yysp-3],arguments:yyvstack[yysp-1]}]),{rule:"Identifier <( TypeArguments )>",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Identifier",yylstack[yysp-3]],["<(",yylstack[yysp-2]],["TypeArguments",yylstack[yysp-1]],[")>",yylstack[yysp]]);break;case 549:/*! Production::    TypeWithArguments : Identifier "<(" INDENT TypeArguments OUTDENT ")>" */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeWithArguments"]("Identifier <( INDENT TypeArguments OUTDENT )>",...[{type:yyvstack[yysp-5],arguments:yyvstack[yysp-2]}]),{rule:"Identifier <( INDENT TypeArguments OUTDENT )>",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Identifier",yylstack[yysp-5]],["<(",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["TypeArguments",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],[")>",yylstack[yysp]]);break;case 550:/*! Production::    TypeArguments : TypeArgument */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeArguments"]("TypeArgument",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TypeArgument",yylstack[yysp-1]]);break;case 551:/*! Production::    TypeArguments : TypeArguments "," TypeArgument */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeArguments"]("TypeArguments , TypeArgument",...[...yyvstack[yysp-2].contents,yyvstack[yysp]]),{rule:"TypeArguments , TypeArgument",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeArguments",yylstack[yysp-2]],[",",yylstack[yysp-1]],["TypeArgument",yylstack[yysp]]);break;case 552:/*! Production::    TypeArguments : TypeArguments OptComma NEWLINE TypeArgument */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeArguments"]("TypeArguments OptComma NEWLINE TypeArgument",...[...yyvstack[yysp-3].contents,yyvstack[yysp]]),{rule:"TypeArguments OptComma NEWLINE TypeArgument",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeArguments",yylstack[yysp-3]],["OptComma",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["TypeArgument",yylstack[yysp]]);break;case 553:/*! Production::    TypeArguments : TypeArguments OptComma INDENT TypeArgument OUTDENT */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeArguments"]("TypeArguments OptComma INDENT TypeArgument OUTDENT",...[...yyvstack[yysp-4].contents,yyvstack[yysp-1]]),{rule:"TypeArguments OptComma INDENT TypeArgument OUTDENT",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeArguments",yylstack[yysp-4]],["OptComma",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["TypeArgument",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 554:/*! Production::    TypeArgument : Identifier */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeArgument"]("Identifier",...[yyvstack[yysp]]),{rule:"Identifier",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Identifier",yylstack[yysp]]);break;case 555:/*! Production::    TypeArgument : Identifier EXTENDS Identifier */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeArgument"]("Identifier EXTENDS Identifier",...[yyvstack[yysp-2],yyvstack[yysp]]),{rule:"Identifier EXTENDS Identifier",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Identifier",yylstack[yysp-2]],["EXTENDS",yylstack[yysp-1]],["Identifier",yylstack[yysp]]);break;case 556:/*! Production::    TypeArgument : TypeWithArguments */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeArgument"]("TypeWithArguments",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TypeWithArguments",yylstack[yysp-1]]);break;case 557:/*! Production::    InlineType : TypeValue */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["InlineType"]("TypeValue",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TypeValue",yylstack[yysp-1]]);break;case 558:/*! Production::    InlineType : TYPE_JOIN */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["InlineType"]("TYPE_JOIN",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TYPE_JOIN",yylstack[yysp-1]]);break;case 559:/*! Production::    InlineType : InlineType TypeValue */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InlineType"]("InlineType TypeValue",...[...yyvstack[yysp-1].contents,yyvstack[yysp]]),{rule:"InlineType TypeValue",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["InlineType",yylstack[yysp-1]],["TypeValue",yylstack[yysp]]);break;case 560:/*! Production::    InlineType : InlineType TYPE_JOIN */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InlineType"]("InlineType TYPE_JOIN",...[...yyvstack[yysp-1].contents,yyvstack[yysp]]),{rule:"InlineType TYPE_JOIN",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["InlineType",yylstack[yysp-1]],["TYPE_JOIN",yylstack[yysp]]);break;case 561:/*! Production::    InlineType : InlineType INDENT TypeSentence OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["InlineType"]("InlineType INDENT TypeSentence OUTDENT",...[...yyvstack[yysp-3].contents,1,...yyvstack[yysp-1].contents,-1]),{rule:"InlineType INDENT TypeSentence OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["InlineType",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["TypeSentence",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 562:/*! Production::    TypeObject : "{" "}" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObject"]("{ }",...[/* */]),{rule:"{ }",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 563:/*! Production::    TypeObject : "{" TypeObjProps "}" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObject"]("{ TypeObjProps }",...[...yyvstack[yysp-1].contents]),{rule:"{ TypeObjProps }",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{",yylstack[yysp-2]],["TypeObjProps",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 564:/*! Production::    TypeObject : "{" INDENT TypeObjProps OUTDENT "}" */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObject"]("{ INDENT TypeObjProps OUTDENT }",...[...yyvstack[yysp-2].contents]),{rule:"{ INDENT TypeObjProps OUTDENT }",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false,"indented":true},{generated:undefined}).setTokens(["{",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["TypeObjProps",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 565:/*! Production::    TypeObjProps : TypeObjProp */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeObjProps"]("TypeObjProp",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["TypeObjProp",yylstack[yysp-1]]);break;case 566:/*! Production::    TypeObjProps : TypeObjProps "," TypeObjProp */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProps"]("TypeObjProps , TypeObjProp",...[...yyvstack[yysp-2].contents,yyvstack[yysp]]),{rule:"TypeObjProps , TypeObjProp",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeObjProps",yylstack[yysp-2]],[",",yylstack[yysp-1]],["TypeObjProp",yylstack[yysp]]);break;case 567:/*! Production::    TypeObjProps : TypeObjProps OptComma NEWLINE TypeObjProp */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProps"]("TypeObjProps OptComma NEWLINE TypeObjProp",...[...yyvstack[yysp-3].contents,yylstack[yysp-1].generated&&1||0,yyvstack[yysp]]),{rule:"TypeObjProps OptComma NEWLINE TypeObjProp",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeObjProps",yylstack[yysp-3]],["OptComma",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["TypeObjProp",yylstack[yysp]]);break;case 568:/*! Production::    TypeObjProps : TypeObjProps OptComma INDENT TypeObjProps OUTDENT */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProps"]("TypeObjProps OptComma INDENT TypeObjProps OUTDENT",...[...yyvstack[yysp-4].contents,2,...yyvstack[yysp-1].contents]),{rule:"TypeObjProps OptComma INDENT TypeObjProps OUTDENT",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeObjProps",yylstack[yysp-4]],["OptComma",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["TypeObjProps",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 569:/*! Production::    TypeObjProp : Identifier */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProp"]("Identifier",...[yyvstack[yysp]]),{rule:"Identifier",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Identifier",yylstack[yysp]]);break;case 570:/*! Production::    TypeObjProp : PROPERTY ":" InlineType */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProp"]("PROPERTY : InlineType",...[yyvstack[yysp-2],yyvstack[yysp],yylstack[yysp-1].origin==='?:']),{rule:"PROPERTY : InlineType",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PROPERTY",yylstack[yysp-2]],[":",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 571:/*! Production::    TypeObjProp : PROPERTY ":" NEWLINE InlineType */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProp"]("PROPERTY : NEWLINE InlineType",...[yyvstack[yysp-3],yyvstack[yysp],yylstack[yysp-2].origin==='?:']),{rule:"PROPERTY : NEWLINE InlineType",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PROPERTY",yylstack[yysp-3]],[":",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 572:/*! Production::    TypeObjProp : PROPERTY ":" INDENT TypeSentence OUTDENT */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProp"]("PROPERTY : INDENT TypeSentence OUTDENT",...[yyvstack[yysp-4],yyvstack[yysp-1],yylstack[yysp-3].origin==='?:']),{rule:"PROPERTY : INDENT TypeSentence OUTDENT",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PROPERTY",yylstack[yysp-4]],[":",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["TypeSentence",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 573:/*! Production::    TypeObjProp : PROPERTY ":" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProp"]("PROPERTY :",...[yyvstack[yysp-1],,yylstack[yysp].origin==='?:']),{rule:"PROPERTY :",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PROPERTY",yylstack[yysp-1]],[":",yylstack[yysp]]);break;case 574:/*! Production::    TypeObjProp : "[" PROPERTY ":" TypeSentence "]" ":" InlineType */ // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-6,yysp);// END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProp"]("[ PROPERTY : TypeSentence ] : InlineType",...[yyvstack[yysp-5],yyvstack[yysp],,{isDynamicKey:true,keyType:yyvstack[yysp-3]}]),{rule:"[ PROPERTY : TypeSentence ] : InlineType",loc:{first_line:yylstack[yysp-6]&&yylstack[yysp-6].first_line,first_column:yylstack[yysp-6]&&yylstack[yysp-6].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-6]&&yylstack[yysp-6].src,type:yylstack[yysp-6]&&yylstack[yysp-6].type||yylstack[yysp-6]&&yylstack[yysp-6].type}},{"first":1,"last":7,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["[",yylstack[yysp-6]],["PROPERTY",yylstack[yysp-5]],[":",yylstack[yysp-4]],["TypeSentence",yylstack[yysp-3]],["]",yylstack[yysp-2]],[":",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 575:/*! Production::    TypeObjProp : "[" PROPERTY ":" TypeSentence "]" ":" NEWLINE InlineType */ // default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-7,yysp);// END of default action (generated by JISON mode classic/merge :: 8,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProp"]("[ PROPERTY : TypeSentence ] : NEWLINE InlineType",...[yyvstack[yysp-6],yyvstack[yysp],,{isDynamicKey:true,keyType:yyvstack[yysp-4]}]),{rule:"[ PROPERTY : TypeSentence ] : NEWLINE InlineType",loc:{first_line:yylstack[yysp-7]&&yylstack[yysp-7].first_line,first_column:yylstack[yysp-7]&&yylstack[yysp-7].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-7]&&yylstack[yysp-7].src,type:yylstack[yysp-7]&&yylstack[yysp-7].type||yylstack[yysp-7]&&yylstack[yysp-7].type}},{"first":1,"last":8,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["[",yylstack[yysp-7]],["PROPERTY",yylstack[yysp-6]],[":",yylstack[yysp-5]],["TypeSentence",yylstack[yysp-4]],["]",yylstack[yysp-3]],[":",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 576:/*! Production::    TypeObjProp : "[" PROPERTY ":" TypeSentence "]" ":" INDENT TypeSentence OUTDENT */ // default action (generated by JISON mode classic/merge :: 9,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-8,yysp);// END of default action (generated by JISON mode classic/merge :: 9,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProp"]("[ PROPERTY : TypeSentence ] : INDENT TypeSentence OUTDENT",...[yyvstack[yysp-7],yyvstack[yysp-1],,{isDynamicKey:true,keyType:yyvstack[yysp-5]}]),{rule:"[ PROPERTY : TypeSentence ] : INDENT TypeSentence OUTDENT",loc:{first_line:yylstack[yysp-8]&&yylstack[yysp-8].first_line,first_column:yylstack[yysp-8]&&yylstack[yysp-8].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-8]&&yylstack[yysp-8].src,type:yylstack[yysp-8]&&yylstack[yysp-8].type||yylstack[yysp-8]&&yylstack[yysp-8].type}},{"first":1,"last":9,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["[",yylstack[yysp-8]],["PROPERTY",yylstack[yysp-7]],[":",yylstack[yysp-6]],["TypeSentence",yylstack[yysp-5]],["]",yylstack[yysp-4]],[":",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["TypeSentence",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 577:/*! Production::    TypeObjProp : "[" Identifier "]" ":" InlineType */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProp"]("[ Identifier ] : InlineType",...[yyvstack[yysp-3],yyvstack[yysp],,{isDynamicKey:true,keyType:yylstack[yysp-3].type}]),{rule:"[ Identifier ] : InlineType",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["[",yylstack[yysp-4]],["Identifier",yylstack[yysp-3]],["]",yylstack[yysp-2]],[":",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 578:/*! Production::    TypeObjProp : "[" Identifier "]" ":" NEWLINE InlineType */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProp"]("[ Identifier ] : NEWLINE InlineType",...[yyvstack[yysp-4],yyvstack[yysp],,{isDynamicKey:true,keyType:yylstack[yysp-4].type}]),{rule:"[ Identifier ] : NEWLINE InlineType",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["[",yylstack[yysp-5]],["Identifier",yylstack[yysp-4]],["]",yylstack[yysp-3]],[":",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 579:/*! Production::    TypeObjProp : "[" Identifier "]" ":" INDENT TypeSentence OUTDENT */ // default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-6,yysp);// END of default action (generated by JISON mode classic/merge :: 7,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeObjProp"]("[ Identifier ] : INDENT TypeSentence OUTDENT",...[yyvstack[yysp-5],yyvstack[yysp-1],,{isDynamicKey:true,keyType:yylstack[yysp-5].type}]),{rule:"[ Identifier ] : INDENT TypeSentence OUTDENT",loc:{first_line:yylstack[yysp-6]&&yylstack[yysp-6].first_line,first_column:yylstack[yysp-6]&&yylstack[yysp-6].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-6]&&yylstack[yysp-6].src,type:yylstack[yysp-6]&&yylstack[yysp-6].type||yylstack[yysp-6]&&yylstack[yysp-6].type}},{"first":1,"last":7,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["[",yylstack[yysp-6]],["Identifier",yylstack[yysp-5]],["]",yylstack[yysp-4]],[":",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["TypeSentence",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 580:/*! Production::    TypeArray : "[" TypeArrayItems "]" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeArray"]("[ TypeArrayItems ]",...[...yyvstack[yysp-1].contents]),{rule:"[ TypeArrayItems ]",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["[",yylstack[yysp-2]],["TypeArrayItems",yylstack[yysp-1]],["]",yylstack[yysp]]);break;case 581:/*! Production::    TypeArray : "[" INDENT TypeArrayItems OUTDENT "]" */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeArray"]("[ INDENT TypeArrayItems OUTDENT ]",...[...yyvstack[yysp-2].contents]),{rule:"[ INDENT TypeArrayItems OUTDENT ]",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false,"indented":true},{generated:undefined}).setTokens(["[",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["TypeArrayItems",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["]",yylstack[yysp]]);break;case 582:/*! Production::    TypeArrayItems : InlineType */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["TypeArrayItems"]("InlineType",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["InlineType",yylstack[yysp-1]]);break;case 583:/*! Production::    TypeArrayItems : TypeArrayItems OptComma NEWLINE InlineType */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeArrayItems"]("TypeArrayItems OptComma NEWLINE InlineType",...[...yyvstack[yysp-3].contents,yylstack[yysp-1].generated&&1||0,yyvstack[yysp]]),{rule:"TypeArrayItems OptComma NEWLINE InlineType",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeArrayItems",yylstack[yysp-3]],["OptComma",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 584:/*! Production::    TypeArrayItems : TypeArrayItems OptComma INDENT TypeSentence OUTDENT */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeArrayItems"]("TypeArrayItems OptComma INDENT TypeSentence OUTDENT",...[...yyvstack[yysp-4].contents,2,yyvstack[yysp-1]]),{rule:"TypeArrayItems OptComma INDENT TypeSentence OUTDENT",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeArrayItems",yylstack[yysp-4]],["OptComma",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["TypeSentence",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 585:/*! Production::    TypeArrayItems : TypeArrayItems "," InlineType */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["TypeArrayItems"]("TypeArrayItems , InlineType",...[...yyvstack[yysp-2].contents,yyvstack[yysp]]),{rule:"TypeArrayItems , InlineType",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["TypeArrayItems",yylstack[yysp-2]],[",",yylstack[yysp-1]],["InlineType",yylstack[yysp]]);break;case 586:/*! Production::    Declare : DeclarationKeyword Declarations */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Declare"]("DeclarationKeyword Declarations",...[{keyword:yyvstack[yysp-1],statements:yyvstack[yysp]},[yylstack[yysp-1],yylstack[yysp]]]),{rule:"DeclarationKeyword Declarations",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["DeclarationKeyword",yylstack[yysp-1]],["Declarations",yylstack[yysp]]);break;case 587:/*! Production::    Declare : DeclarationKeyword INDENT Declarations OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Declare"]("DeclarationKeyword INDENT Declarations OUTDENT",...[{keyword:yyvstack[yysp-3],statements:yyvstack[yysp-1],indented:true},[yylstack[yysp-3],yylstack[yysp-1]]]),{rule:"DeclarationKeyword INDENT Declarations OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["DeclarationKeyword",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Declarations",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 588:/*! Production::    DeclarationKeyword : VAR */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["DeclarationKeyword"]("VAR",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["VAR",yylstack[yysp-1]]);break;case 589:/*! Production::    DeclarationKeyword : LET */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["DeclarationKeyword"]("LET",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["LET",yylstack[yysp-1]]);break;case 590:/*! Production::    DeclarationKeyword : CONST */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["DeclarationKeyword"]("CONST",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["CONST",yylstack[yysp-1]]);break;case 591:/*! Production::    Declarations : Declaration */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Declarations"]("Declaration",...[yyvstack[yysp].unwrap]),{rule:"Declaration",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["Declaration",yylstack[yysp]]);break;case 592:/*! Production::    Declarations : Declarations "," Declaration */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Declarations"]("Declarations , Declaration",...[...yyvstack[yysp-2].contents,yyvstack[yysp].unwrap]),{rule:"Declarations , Declaration",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Declarations",yylstack[yysp-2]],[",",yylstack[yysp-1]],["Declaration",yylstack[yysp]]);break;case 593:/*! Production::    Declarations : Declarations OptComma NEWLINE Declaration */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Declarations"]("Declarations OptComma NEWLINE Declaration",...[...yyvstack[yysp-3].contents,yylstack[yysp-1].generated,yyvstack[yysp].unwrap]),{rule:"Declarations OptComma NEWLINE Declaration",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Declarations",yylstack[yysp-3]],["OptComma",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["Declaration",yylstack[yysp]]);break;case 594:/*! Production::    Declarations : Declarations OptComma INDENT Declarations OUTDENT */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Declarations"]("Declarations OptComma INDENT Declarations OUTDENT",...[...yyvstack[yysp-4].contents,false,...yyvstack[yysp-1].contents]),{rule:"Declarations OptComma INDENT Declarations OUTDENT",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Declarations",yylstack[yysp-4]],["OptComma",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Declarations",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 595:/*! Production::    Declaration : Assignable */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Declaration"]("Assignable",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Assignable",yylstack[yysp-1]]);break;case 596:/*! Production::    Declaration : Assignable AssignKeyword Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Declaration"]("Assignable AssignKeyword Expression",...[new yy.Assignment('Assignable AssignKeyword Expression',yyvstack[yysp-2],yyvstack[yysp],yyvstack[yysp-1]).setLoc(yylstack[yysp-2],yylstack[yysp])]),{rule:"Assignable AssignKeyword Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Assignable",yylstack[yysp-2]],["AssignKeyword",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 597:/*! Production::    Declaration : Assignable AssignKeyword INDENT Expression OUTDENT */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Declaration"]("Assignable AssignKeyword INDENT Expression OUTDENT",...[new yy.Assignment('Assignable AssignKeyword INDENT Expression OUTDENT',yyvstack[yysp-4],yyvstack[yysp-1],yyvstack[yysp-3]).setLoc(yylstack[yysp-4],yylstack[yysp])]),{rule:"Assignable AssignKeyword INDENT Expression OUTDENT",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Assignable",yylstack[yysp-4]],["AssignKeyword",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 598:/*! Production::    Declaration : Assignable AssignKeyword Block */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Declaration"]("Assignable AssignKeyword Block",...[new yy.Assignment('Assignable AssignKeyword Block',yyvstack[yysp-2],yy.Array.from(yyvstack[yysp]),yyvstack[yysp-1]).setLoc(yylstack[yysp-2],yylstack[yysp])]),{rule:"Assignable AssignKeyword Block",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Assignable",yylstack[yysp-2]],["AssignKeyword",yylstack[yysp-1]],["Block",yylstack[yysp]]);break;case 599:/*! Production::    Return : RETURN */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Return"]("RETURN",...[undefined]),{rule:"RETURN",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["RETURN",yylstack[yysp]]);break;case 600:/*! Production::    Return : RETURN Expression */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Return"]("RETURN Expression",...[yyvstack[yysp]]),{rule:"RETURN Expression",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["RETURN",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 601:/*! Production::    Return : RETURN INDENT Expression OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Return"]("RETURN INDENT Expression OUTDENT",...[yyvstack[yysp-1]]),{rule:"RETURN INDENT Expression OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["RETURN",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 602:/*! Production::    Return : RETURN INDENT Body OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Return"]("RETURN INDENT Body OUTDENT",...[yyvstack[yysp-1]]),{rule:"RETURN INDENT Body OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["RETURN",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Body",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 603:/*! Production::    Import : IMPORT ImportList FROM STRING */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Import"]("IMPORT ImportList FROM STRING",...[{_imports:yyvstack[yysp-2],_from:yyvstack[yysp]}]),{rule:"IMPORT ImportList FROM STRING",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IMPORT",yylstack[yysp-3]],["ImportList",yylstack[yysp-2]],["FROM",yylstack[yysp-1]],["STRING",yylstack[yysp]]);break;case 604:/*! Production::    Import : IMPORT Identifier FROM STRING */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Import"]("IMPORT Identifier FROM STRING",...[{_default:yyvstack[yysp-2],_from:yyvstack[yysp]}]),{rule:"IMPORT Identifier FROM STRING",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IMPORT",yylstack[yysp-3]],["Identifier",yylstack[yysp-2]],["FROM",yylstack[yysp-1]],["STRING",yylstack[yysp]]);break;case 605:/*! Production::    Import : IMPORT Identifier OptSeparator ImportList FROM STRING */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Import"]("IMPORT Identifier OptSeparator ImportList FROM STRING",...[{_default:yyvstack[yysp-4],_imports:yyvstack[yysp-2],_from:yyvstack[yysp]}]),{rule:"IMPORT Identifier OptSeparator ImportList FROM STRING",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["IMPORT",yylstack[yysp-5]],["Identifier",yylstack[yysp-4]],["OptSeparator",yylstack[yysp-3]],["ImportList",yylstack[yysp-2]],["FROM",yylstack[yysp-1]],["STRING",yylstack[yysp]]);break;case 606:/*! Production::    OptSeparator : %epsilon */ // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(null,null,null,null,true);// END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["OptSeparator"]("",...[undefined]),{rule:"",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp-1]&&yylstack[yysp-1].last_line,last_column:yylstack[yysp-1]&&yylstack[yysp-1].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src}},{"first":0,"last":0,"typeOf":0,"checkGenerated":false},{generated:undefined}).setTokens();break;case 607:/*! Production::    OptSeparator : "," */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["OptSeparator"](",",...[undefined]),{rule:",",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens([",",yylstack[yysp]]);break;case 608:/*! Production::    OptSeparator : OptComma NEWLINE */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["OptSeparator"]("OptComma NEWLINE",...[1]),{rule:"OptComma NEWLINE",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["OptComma",yylstack[yysp-1]],["NEWLINE",yylstack[yysp]]);break;case 609:/*! Production::    Export : EXPORT ExportList */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Export"]("EXPORT ExportList",...[{list:yyvstack[yysp]}]),{rule:"EXPORT ExportList",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["EXPORT",yylstack[yysp-1]],["ExportList",yylstack[yysp]]);break;case 610:/*! Production::    Export : EXPORT INDENT ExportList OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Export"]("EXPORT INDENT ExportList OUTDENT",...[{list:yyvstack[yysp-1]}]),{rule:"EXPORT INDENT ExportList OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["EXPORT",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["ExportList",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 611:/*! Production::    Export : EXPORT DEFAULT Expression */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Export"]("EXPORT DEFAULT Expression",...[{defaults:yyvstack[yysp]}]),{rule:"EXPORT DEFAULT Expression",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["EXPORT",yylstack[yysp-2]],["DEFAULT",yylstack[yysp-1]],["Expression",yylstack[yysp]]);break;case 612:/*! Production::    Export : EXPORT INDENT DEFAULT Expression OUTDENT */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Export"]("EXPORT INDENT DEFAULT Expression OUTDENT",...[{defaults:yyvstack[yysp-1]}]),{rule:"EXPORT INDENT DEFAULT Expression OUTDENT",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["EXPORT",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["DEFAULT",yylstack[yysp-2]],["Expression",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 613:/*! Production::    Export : EXPORT Declare */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Export"]("EXPORT Declare",...[{declarations:yyvstack[yysp]}]),{rule:"EXPORT Declare",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["EXPORT",yylstack[yysp-1]],["Declare",yylstack[yysp]]);break;case 614:/*! Production::    Export : EXPORT INDENT Declare OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Export"]("EXPORT INDENT Declare OUTDENT",...[{declarations:yyvstack[yysp-1]}]),{rule:"EXPORT INDENT Declare OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["EXPORT",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Declare",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 615:/*! Production::    Export : EXPORT Exportable */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Export"]("EXPORT Exportable",...[{exportable:yyvstack[yysp].unwrap}]),{rule:"EXPORT Exportable",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["EXPORT",yylstack[yysp-1]],["Exportable",yylstack[yysp]]);break;case 616:/*! Production::    Export : EXPORT INDENT Exportable OUTDENT */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["Export"]("EXPORT INDENT Exportable OUTDENT",...[{exportable:yyvstack[yysp-1].unwrap}]),{rule:"EXPORT INDENT Exportable OUTDENT",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["EXPORT",yylstack[yysp-3]],["INDENT",yylstack[yysp-2]],["Exportable",yylstack[yysp-1]],["OUTDENT",yylstack[yysp]]);break;case 617:/*! Production::    ImportList : Identifier */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ImportList"]("Identifier",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Identifier",yylstack[yysp-1]]);break;case 618:/*! Production::    ImportList : "*" AS Identifier */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ImportList"]("* AS Identifier",...[yyvstack[yysp]]),{rule:"* AS Identifier",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false,"_isAll":true},{generated:undefined}).setTokens(["*",yylstack[yysp-2]],["AS",yylstack[yysp-1]],["Identifier",yylstack[yysp]]);break;case 619:/*! Production::    ImportList : "{" ImportNames OptComma "}" */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ImportList"]("{ ImportNames OptComma }",...[yyvstack[yysp-2]]),{rule:"{ ImportNames OptComma }",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{",yylstack[yysp-3]],["ImportNames",yylstack[yysp-2]],["OptComma",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 620:/*! Production::    ImportList : "{{" INDENT ImportNames OptComma OUTDENT "}}" */ // default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-5,yysp);// END of default action (generated by JISON mode classic/merge :: 6,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ImportList"]("{{ INDENT ImportNames OptComma OUTDENT }}",...[yyvstack[yysp-3]]),{rule:"{{ INDENT ImportNames OptComma OUTDENT }}",loc:{first_line:yylstack[yysp-5]&&yylstack[yysp-5].first_line,first_column:yylstack[yysp-5]&&yylstack[yysp-5].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-5]&&yylstack[yysp-5].src,type:yylstack[yysp-5]&&yylstack[yysp-5].type||yylstack[yysp-5]&&yylstack[yysp-5].type}},{"first":1,"last":6,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{{",yylstack[yysp-5]],["INDENT",yylstack[yysp-4]],["ImportNames",yylstack[yysp-3]],["OptComma",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["}}",yylstack[yysp]]);break;case 621:/*! Production::    ExportList : "{" ExportNames "}" */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ExportList"]("{ ExportNames }",...[yyvstack[yysp-1]]),{rule:"{ ExportNames }",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{",yylstack[yysp-2]],["ExportNames",yylstack[yysp-1]],["}",yylstack[yysp]]);break;case 622:/*! Production::    ExportList : "{{" INDENT ExportNames OUTDENT "}}" */ // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-4,yysp);// END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ExportList"]("{{ INDENT ExportNames OUTDENT }}",...[yyvstack[yysp-2]]),{rule:"{{ INDENT ExportNames OUTDENT }}",loc:{first_line:yylstack[yysp-4]&&yylstack[yysp-4].first_line,first_column:yylstack[yysp-4]&&yylstack[yysp-4].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-4]&&yylstack[yysp-4].src,type:yylstack[yysp-4]&&yylstack[yysp-4].type||yylstack[yysp-4]&&yylstack[yysp-4].type}},{"first":1,"last":5,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["{{",yylstack[yysp-4]],["INDENT",yylstack[yysp-3]],["ExportNames",yylstack[yysp-2]],["OUTDENT",yylstack[yysp-1]],["}}",yylstack[yysp]]);break;case 623:/*! Production::    ExportNames : ExportName */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ExportNames"]("ExportName",...[yyvstack[yysp].contents]),{rule:"ExportName",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["ExportName",yylstack[yysp]]);break;case 624:/*! Production::    ExportNames : ExportNames "," ExportName */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ExportNames"]("ExportNames , ExportName",...[...yyvstack[yysp-2].contents,yyvstack[yysp].contents]),{rule:"ExportNames , ExportName",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ExportNames",yylstack[yysp-2]],[",",yylstack[yysp-1]],["ExportName",yylstack[yysp]]);break;case 625:/*! Production::    ExportNames : ExportNames OptComma NEWLINE ExportName */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ExportNames"]("ExportNames OptComma NEWLINE ExportName",...[...yyvstack[yysp-3].contents,yyvstack[yysp].contents]),{rule:"ExportNames OptComma NEWLINE ExportName",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ExportNames",yylstack[yysp-3]],["OptComma",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["ExportName",yylstack[yysp]]);break;case 626:/*! Production::    ExportName : PROPERTY ":" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ExportName"]("PROPERTY :",...[new yy.Identifier(0,yyvstack[yysp-1]).setLoc(yylstack[yysp-1])]),{rule:"PROPERTY :",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PROPERTY",yylstack[yysp-1]],[":",yylstack[yysp]]);break;case 627:/*! Production::    ExportName : PROPERTY ":" Identifier */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ExportName"]("PROPERTY : Identifier",...[new yy.Identifier(0,yyvstack[yysp-2]).setLoc(yylstack[yysp-2]),yyvstack[yysp]]),{rule:"PROPERTY : Identifier",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PROPERTY",yylstack[yysp-2]],[":",yylstack[yysp-1]],["Identifier",yylstack[yysp]]);break;case 628:/*! Production::    ExportName : PROPERTY ":" AS Identifier */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ExportName"]("PROPERTY : AS Identifier",...[new yy.Identifier(0,yyvstack[yysp-3]).setLoc(yylstack[yysp-3]),yyvstack[yysp]]),{rule:"PROPERTY : AS Identifier",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PROPERTY",yylstack[yysp-3]],[":",yylstack[yysp-2]],["AS",yylstack[yysp-1]],["Identifier",yylstack[yysp]]);break;case 629:/*! Production::    ExportName : Identifier */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ExportName"]("Identifier",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Identifier",yylstack[yysp-1]]);break;case 630:/*! Production::    ExportName : Identifier AS DEFAULT */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ExportName"]("Identifier AS DEFAULT",...[yyvstack[yysp-2],,true]),{rule:"Identifier AS DEFAULT",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Identifier",yylstack[yysp-2]],["AS",yylstack[yysp-1]],["DEFAULT",yylstack[yysp]]);break;case 631:/*! Production::    ExportName : Identifier AS Identifier */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ExportName"]("Identifier AS Identifier",...[yyvstack[yysp-2],yyvstack[yysp]]),{rule:"Identifier AS Identifier",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Identifier",yylstack[yysp-2]],["AS",yylstack[yysp-1]],["Identifier",yylstack[yysp]]);break;case 632:/*! Production::    Exportable : Class */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Exportable"]("Class",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Class",yylstack[yysp-1]]);break;case 633:/*! Production::    Exportable : Function */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["Exportable"]("Function",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Function",yylstack[yysp-1]]);break;case 634:/*! Production::    ImportNames : ImportName */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ImportNames"]("ImportName",...[yyvstack[yysp].contents]),{rule:"ImportName",loc:{first_line:yylstack[yysp]&&yylstack[yysp].first_line,first_column:yylstack[yysp]&&yylstack[yysp].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp]&&yylstack[yysp].src,type:yylstack[yysp]&&yylstack[yysp].type||yylstack[yysp]&&yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}},{"first":1,"last":1,"typeOf":1,"checkGenerated":false,"origin":1},{generated:undefined}).setTokens(["ImportName",yylstack[yysp]]);break;case 635:/*! Production::    ImportNames : ImportNames "," ImportName */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ImportNames"]("ImportNames , ImportName",...[...yyvstack[yysp-2].contents,yyvstack[yysp].contents]),{rule:"ImportNames , ImportName",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ImportNames",yylstack[yysp-2]],[",",yylstack[yysp-1]],["ImportName",yylstack[yysp]]);break;case 636:/*! Production::    ImportNames : ImportNames OptComma NEWLINE ImportName */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ImportNames"]("ImportNames OptComma NEWLINE ImportName",...[...yyvstack[yysp-3].contents,yyvstack[yysp].contents]),{rule:"ImportNames OptComma NEWLINE ImportName",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["ImportNames",yylstack[yysp-3]],["OptComma",yylstack[yysp-2]],["NEWLINE",yylstack[yysp-1]],["ImportName",yylstack[yysp]]);break;case 637:/*! Production::    ImportName : PROPERTY ":" */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-1,yysp);// END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ImportName"]("PROPERTY :",...[new yy.Identifier(0,yyvstack[yysp-1]).setLoc(yylstack[yysp-1]),,[yylstack[yysp-1],yylstack[yysp]]]),{rule:"PROPERTY :",loc:{first_line:yylstack[yysp-1]&&yylstack[yysp-1].first_line,first_column:yylstack[yysp-1]&&yylstack[yysp-1].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-1]&&yylstack[yysp-1].src,type:yylstack[yysp-1]&&yylstack[yysp-1].type||yylstack[yysp-1]&&yylstack[yysp-1].type}},{"first":1,"last":2,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PROPERTY",yylstack[yysp-1]],[":",yylstack[yysp]]);break;case 638:/*! Production::    ImportName : PROPERTY ":" Identifier */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ImportName"]("PROPERTY : Identifier",...[new yy.Identifier(0,yyvstack[yysp-2]).setLoc(yylstack[yysp-2]),yyvstack[yysp]]),{rule:"PROPERTY : Identifier",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PROPERTY",yylstack[yysp-2]],[":",yylstack[yysp-1]],["Identifier",yylstack[yysp]]);break;case 639:/*! Production::    ImportName : PROPERTY ":" AS Identifier */ // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-3,yysp);// END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ImportName"]("PROPERTY : AS Identifier",...[new yy.Identifier(0,yyvstack[yysp-3]).setLoc(yylstack[yysp-3]),yyvstack[yysp]]),{rule:"PROPERTY : AS Identifier",loc:{first_line:yylstack[yysp-3]&&yylstack[yysp-3].first_line,first_column:yylstack[yysp-3]&&yylstack[yysp-3].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-3]&&yylstack[yysp-3].src,type:yylstack[yysp-3]&&yylstack[yysp-3].type||yylstack[yysp-3]&&yylstack[yysp-3].type}},{"first":1,"last":4,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["PROPERTY",yylstack[yysp-3]],[":",yylstack[yysp-2]],["AS",yylstack[yysp-1]],["Identifier",yylstack[yysp]]);break;case 640:/*! Production::    ImportName : Identifier AS Identifier */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ImportName"]("Identifier AS Identifier",...[yyvstack[yysp-2],yyvstack[yysp]]),{rule:"Identifier AS Identifier",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["Identifier",yylstack[yysp-2]],["AS",yylstack[yysp-1]],["Identifier",yylstack[yysp]]);break;case 641:/*! Production::    ImportName : DEFAULT AS Identifier */ // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
this._$=yyparser.yyMergeLocationInfo(yysp-2,yysp);// END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
this.$=Object.assign(new yy["ImportName"]("DEFAULT AS Identifier",...[new yy.Identifier(null,'default').setLoc(yylstack[yysp-2]),yyvstack[yysp]]),{rule:"DEFAULT AS Identifier",loc:{first_line:yylstack[yysp-2]&&yylstack[yysp-2].first_line,first_column:yylstack[yysp-2]&&yylstack[yysp-2].first_column,last_line:yylstack[yysp]&&yylstack[yysp].last_line,last_column:yylstack[yysp]&&yylstack[yysp].last_column,src:yylstack[yysp-2]&&yylstack[yysp-2].src,type:yylstack[yysp-2]&&yylstack[yysp-2].type||yylstack[yysp-2]&&yylstack[yysp-2].type}},{"first":1,"last":3,"typeOf":1,"checkGenerated":false},{generated:undefined}).setTokens(["DEFAULT",yylstack[yysp-2]],["AS",yylstack[yysp-1]],["Identifier",yylstack[yysp]]);break;case 642:/*! Production::    ImportName : Identifier */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
this._$=yylstack[yysp];// END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
this.$=new yy["ImportName"]("Identifier",...[yyvstack[yysp]]).setLocation({first_line:yylstack[yysp].first_line,first_column:yylstack[yysp].first_column,last_line:yylstack[yysp].last_line,last_column:yylstack[yysp].last_column,src:yylstack[yysp].src,type:yylstack[yysp].type,origin:yylstack[yysp]&&yylstack[yysp].origin}).setTokens(["Identifier",yylstack[yysp-1]]);break;}},table:bt({len:u([115,1,2,0,7,57,0,92,92,s,[0,3],112,111,s,[0,9],94,s,[0,4],190,6,18,114,5,2,111,6,114,113,91,97,111,5,12,145,2,91,s,[0,8],7,92,s,[111,5],s,[112,3],s,[0,9],114,114,c,[5,4],s,[0,7],6,148,111,0,c,[77,9],125,0,127,118,s,[0,9],7,0,7,117,c,[58,4],113,111,c,[34,5],s,[111,4],0,114,c,[120,10],s,[0,4],64,0,64,s,[0,15],125,0,0,97,111,2,97,0,5,39,0,0,1,111,116,97,113,1,9,1,6,1,0,17,c,[56,3],5,1,s,[0,3],91,113,0,91,52,0,s,[3,3],99,57,114,111,5,2,2,60,114,3,4,61,55,54,119,1,91,114,95,92,40,3,97,12,0,2,114,113,c,[42,5],10,10,12,2,11,11,14,0,5,5,115,s,[0,3],8,c,[131,4],c,[9,4],97,94,s,[97,4],111,97,111,97,111,0,53,129,97,0,54,2,113,2,39,0,1,1,144,0,0,40,145,3,97,114,57,90,90,c,[26,3],c,[110,3],125,0,58,0,1,56,118,112,61,50,59,12,120,119,0,118,119,c,[212,5],116,0,111,58,111,70,7,c,[78,3],8,0,s,[97,3],114,2,58,90,113,s,[97,9],0,97,0,0,90,53,6,40,5,0,10,8,3,s,[0,9],41,8,1,39,3,37,37,40,12,0,53,0,5,114,0,58,111,54,2,1,1,6,5,1,2,4,0,1,5,c,[221,3],111,1,1,97,c,[11,4],5,114,2,5,115,1,0,1,99,114,0,54,97,s,[111,6],62,63,111,119,c,[438,4],51,114,53,6,0,s,[124,4],119,c,[376,3],97,91,92,91,111,4,5,39,2,0,c,[218,3],114,0,2,2,1,13,2,c,[344,4],c,[358,4],1,1,5,c,[312,3],9,3,0,6,0,0,9,111,0,97,c,[368,5],7,53,0,97,90,4,s,[53,3],0,0,c,[52,3],0,1,193,0,5,145,0,144,54,113,114,0,124,12,97,3,127,5,119,114,57,1,61,0,120,s,[0,4],97,90,0,114,1,119,c,[552,5],57,c,[45,3],c,[178,3],60,s,[111,3],113,1,54,c,[275,5],6,40,2,2,40,41,1,37,5,40,43,109,0,109,c,[17,4],c,[109,3],3,39,125,1,39,109,109,41,39,c,[17,4],0,3,117,5,c,[58,3],s,[0,3],c,[387,4],2,8,7,2,c,[230,3],c,[120,3],c,[445,3],7,3,4,0,112,113,c,[147,3],c,[274,3],102,4,0,97,156,97,53,53,57,57,60,111,55,2,c,[349,3],114,c,[423,3],c,[247,3],0,125,s,[7,4],2,c,[328,3],114,91,111,0,4,2,124,123,95,91,0,98,93,5,c,[442,3],114,97,c,[265,3],c,[239,3],10,11,0,97,59,59,62,1,12,0,8,2,17,0,c,[316,3],14,1,c,[182,3],54,97,8,s,[0,5],c,[36,4],0,144,0,144,0,156,54,4,97,90,129,0,90,111,0,124,125,c,[22,3],57,c,[58,3],c,[4,3],c,[149,4],c,[227,3],0,113,116,c,[361,3],0,111,97,97,60,0,113,c,[159,5],0,38,38,c,[627,4],41,39,c,[215,3],2,41,5,109,0,39,0,7,2,5,44,1,1,125,39,125,c,[19,3],39,38,41,c,[53,3],114,0,3,1,c,[227,3],c,[280,4],c,[3,3],4,c,[5,4],c,[16,3],54,125,39,39,91,17,13,91,0,4,3,2,93,1,c,[503,3],98,c,[445,3],c,[111,3],c,[379,5],60,c,[37,3],54,0,0,124,c,[5,3],c,[60,3],97,0,4,95,c,[13,4],c,[390,3],55,0,2,91,4,c,[493,3],c,[216,3],c,[23,3],c,[27,4],5,c,[674,4],6,6,0,111,c,[380,3],c,[702,3],12,s,[0,5],c,[173,4],c,[202,3],c,[29,3],54,54,114,7,0,1,60,111,c,[52,4],5,c,[169,3],39,43,1,41,c,[385,3],1,43,s,[39,3],1,125,41,109,c,[23,4],c,[223,4],c,[4,4],c,[354,3],125,1,0,4,5,11,0,5,11,13,2,91,1,3,2,3,2,c,[51,3],1,1,57,57,c,[105,3],97,57,c,[69,3],0,91,c,[299,3],c,[877,3],4,0,c,[178,3],97,0,3,62,0,1,c,[439,5],0,0,57,114,c,[68,3],111,c,[714,3],1,1,43,c,[246,3],c,[109,3],43,s,[41,3],0,c,[40,4],0,102,c,[15,4],5,0,11,11,12,0,c,[78,3],91,2,91,c,[252,3],125,91,c,[197,3],c,[1044,4],c,[64,3],c,[711,3],s,[0,5],54,c,[778,4],c,[141,4],c,[158,3],c,[106,3],c,[50,3],5,12,c,[40,4],91,c,[153,3],c,[347,3],c,[132,3],c,[482,3],c,[168,5],c,[99,4],c,[83,3],11,c,[22,3],0,41,97,0,c,[48,4],c,[779,3],41,c,[123,4],c,[97,3],0,c,[3,3],0,0]),symbol:u([1,s,[3,5,1],15,21,24,s,[27,4,1],33,34,s,[41,4,1],65,69,70,71,74,75,76,81,87,90,93,100,s,[103,5,1],110,111,113,117,s,[121,9,1],131,135,136,138,142,s,[148,4,1],154,s,[158,8,1],167,169,170,172,178,182,183,184,189,191,197,199,202,203,204,206,207,209,210,211,s,[215,4,1],220,s,[225,5,1],232,233,238,239,242,251,252,254,258,262,269,270,280,297,298,301,302,304,1,1,26,1,16,22,26,32,98,99,1,4,5,s,[8,7,1],16,19,c,[17,3],s,[35,5,1],41,42,s,[45,20,1],86,98,99,c,[138,4],146,s,[173,5,1],179,204,c,[57,10],s,[15,6,1],22,23,25,26,31,c,[64,6],40,c,[65,22],66,67,72,73,78,s,[82,5,1],89,91,s,[95,5,1],101,102,s,[104,6,1],112,114,115,116,119,120,128,131,134,s,[142,6,1],152,258,c,[92,92],c,[365,12],31,c,[366,52],c,[363,47],c,[477,64],c,[474,48],c,[315,83],c,[314,6],212,227,229,260,c,[683,6],s,[8,60,1],s,[69,8,1],78,s,[81,7,1],89,90,91,93,s,[95,23,1],s,[119,11,1],131,134,c,[278,4],s,[143,10,1],c,[284,54],8,15,67,142,258,305,15,31,67,74,76,88,138,c,[66,3],184,c,[33,3],297,298,306,309,c,[531,109],s,[299,4,1],304,26,31,142,258,281,142,c,[652,13],c,[540,99],26,c,[81,4],204,c,[117,71],s,[187,5,1],c,[771,50],c,[352,8],c,[521,4],c,[773,179],200,c,[91,52],c,[754,3],77,78,80,c,[1182,36],186,247,c,[532,112],c,[782,3],71,181,15,24,72,116,121,142,249,250,256,257,259,261,c,[995,75],s,[80,8,1],c,[996,61],182,142,c,[1551,85],c,[368,6],253,128,131,133,227,229,230,231,c,[98,90],205,208,c,[465,111],c,[111,456],c,[2204,112],c,[112,232],c,[1657,50],s,[181,4,1],c,[114,174],c,[113,45],c,[3133,49],23,78,112,114,119,212,c,[1576,144],239,240,243,247,c,[1054,227],11,12,c,[113,13],c,[341,9],c,[122,48],171,172,175,178,180,c,[236,49],16,c,[616,20],c,[448,3],c,[118,12],116,117,118,c,[120,13],s,[139,4,1],c,[245,35],221,223,c,[122,7],s,[236,5,1],242,246,247,c,[127,19],17,21,24,25,c,[744,31],116,c,[367,65],264,266,268,c,[118,8],133,135,136,s,[232,4,1],c,[2085,8],c,[260,8],22,24,c,[741,5],c,[740,3],c,[500,50],c,[877,48],c,[1999,405],c,[3321,60],c,[224,55],198,c,[2557,493],c,[2890,341],c,[2440,106],c,[336,163],c,[64,69],c,[2189,120],c,[4015,90],c,[5853,7],c,[461,111],c,[6023,12],c,[210,87],78,114,128,131,247,c,[210,3],29,33,69,71,117,c,[183,7],c,[182,3],142,156,157,c,[148,3],c,[147,3],248,258,s,[283,8,1],292,295,118,c,[3831,150],c,[3079,3],c,[114,44],s,[213,6,1],c,[579,185],c,[3479,49],145,8,15,17,26,67,142,145,219,303,143,88,118,142,258,310,311,31,15,c,[5865,28],c,[472,99],c,[134,3],307,308,31,c,[362,90],219,c,[208,108],c,[6072,5],c,[5258,91],c,[90,9],19,c,[7044,42],c,[6213,5],281,78,143,247,c,[152,18],c,[3977,3],c,[153,34],77,c,[154,25],s,[117,4,1],c,[156,3],s,[140,8,1],152,153,247,c,[98,10],19,31,c,[162,27],67,73,c,[164,14],181,c,[777,13],c,[4257,102],c,[743,111],c,[6486,5],18,82,84,85,c,[291,9],c,[387,3],23,c,[292,27],78,c,[44,3],c,[294,7],c,[4426,3],128,131,c,[355,4],c,[6788,114],17,18,82,18,82,98,99,c,[181,60],c,[693,10],c,[61,3],c,[60,27],82,c,[696,15],c,[748,10],c,[587,29],c,[54,15],c,[471,26],82,87,88,90,92,93,94,c,[294,44],s,[192,4,1],c,[479,38],c,[1217,91],201,c,[2727,114],c,[6848,87],c,[6847,8],c,[300,54],c,[1160,26],c,[93,11],272,c,[2238,4],31,c,[2239,35],71,80,248,c,[2014,97],c,[6962,12],31,68,c,[455,12],c,[4630,53],c,[1251,113],c,[113,49],17,26,31,72,219,69,16,17,c,[328,4],72,143,147,255,c,[10,12],20,c,[11,5],116,c,[12,3],121,142,c,[14,3],c,[364,5],c,[26,3],16,c,[52,3],116,118,121,142,222,224,259,15,17,24,25,c,[304,3],c,[302,4],263,265,268,c,[170,4],182,c,[7289,3],73,181,c,[199,8],c,[5685,6],c,[769,101],31,128,130,c,[5071,4],231,c,[3729,135],c,[5889,4],c,[1003,139],c,[773,45],c,[8812,95],c,[191,186],c,[97,201],c,[9405,201],c,[208,326],c,[2488,10],26,c,[3237,42],c,[6714,73],c,[1716,26],c,[6716,30],c,[390,97],c,[279,10],22,c,[280,43],22,26,c,[1989,113],114,212,c,[4610,40],118,c,[10218,143],245,c,[2557,40],c,[7831,144],247,c,[2702,100],c,[3939,114],c,[4110,57],c,[268,90],c,[90,180],c,[1479,118],c,[2969,4],c,[4924,26],c,[8143,100],c,[11893,10],17,19,23,c,[332,8],c,[4216,23],c,[4213,9],116,c,[4214,3],146,20,c,[11952,11],20,23,c,[1391,28],c,[57,15],c,[8258,118],c,[474,39],c,[355,14],c,[1954,68],c,[345,48],c,[656,4],c,[61,12],c,[60,30],c,[982,8],c,[397,11],c,[396,44],c,[3039,4],71,74,78,80,c,[589,5],237,240,c,[9144,7],16,c,[413,3],c,[1447,9],c,[3361,86],241,c,[3477,19],c,[987,10],19,21,23,c,[129,10],c,[206,7],c,[1575,23],c,[154,8],c,[813,3],86,c,[157,3],c,[1564,3],c,[159,7],c,[1560,3],c,[1559,3],c,[163,14],c,[348,4],c,[167,11],c,[239,6],c,[119,97],c,[348,4],c,[119,12],c,[118,118],182,c,[4136,4],219,267,268,c,[895,9],c,[778,30],c,[893,116],c,[892,81],17,19,c,[1568,9],c,[831,29],116,c,[5338,34],c,[4236,91],c,[1291,4],c,[9416,32],c,[399,27],268,c,[9501,3],137,232,233,235,c,[188,111],31,128,131,132,c,[4543,4],c,[4029,303],c,[6227,102],c,[6403,12],c,[6221,30],c,[6220,18],c,[271,90],c,[9606,113],c,[4794,388],c,[97,672],c,[4660,10],c,[15220,43],c,[9156,3],c,[2875,3],c,[4363,40],c,[3558,3],79,219,17,c,[3078,4],77,78,79,119,146,c,[10,5],c,[8,3],23,119,146,c,[66,20],155,c,[67,16],291,292,295,296,16,24,31,c,[8645,3],293,294,69,c,[4664,19],c,[49,20],69,71,248,c,[4706,35],292,295,c,[37,41],c,[166,27],s,[282,7,1],c,[40,3],c,[7052,11],c,[8518,44],120,c,[343,8],c,[297,3],115,c,[8780,39],c,[9347,76],c,[1836,11],c,[2607,37],115,c,[2608,120],c,[5623,11],c,[685,43],26,32,128,128,c,[15218,6],8,15,c,[9368,3],26,142,258,c,[4216,3],219,20,c,[5,3],32,143,c,[9378,7],32,c,[201,111],32,32,c,[1074,97],c,[228,10],c,[9470,5],c,[7393,21],c,[227,89],c,[15451,6],c,[719,3],32,c,[719,9],c,[7514,107],32,143,c,[9351,98],271,c,[8498,114],c,[6110,54],c,[5172,208],c,[111,555],c,[9810,13],26,c,[6175,28],c,[9812,20],c,[62,62],253,c,[347,137],c,[9876,94],26,32,15,26,c,[9025,3],91,181,c,[6537,42],89,c,[1185,7],c,[9077,9],c,[1347,116],c,[1345,28],c,[161,8],c,[2112,9],98,99,c,[17187,7],c,[12392,76],c,[14705,124],c,[124,296],c,[849,114],c,[10633,166],c,[3772,135],181,c,[10726,92],c,[183,90],185,c,[1564,111],142,258,273,274,c,[3972,5],c,[8565,39],71,248,c,[10597,5],c,[10282,115],c,[10944,114],26,32,16,26,69,15,24,c,[474,3],c,[4027,3],c,[4026,5],26,31,c,[14260,289],c,[111,158],23,118,c,[8280,5],c,[3837,3],20,c,[471,3],c,[11277,3],c,[11259,3],c,[7165,3],c,[7164,3],15,24,c,[11260,7],c,[10111,220],c,[11768,166],c,[111,47],c,[16634,7],c,[4950,44],134,c,[3842,105],c,[97,90],c,[11932,3],c,[2905,10],c,[5537,44],c,[53,106],26,32,c,[1627,5],120,c,[20370,147],c,[8579,32],244,c,[12377,16],79,219,c,[10166,144],248,c,[343,143],248,c,[4741,54],c,[10849,113],c,[1987,119],c,[3244,119],11,12,c,[106,9],175,c,[5721,98],c,[2337,8],c,[11594,3],c,[5710,19],c,[10166,70],c,[10165,29],c,[5720,11],c,[9643,22],c,[6445,47],c,[19288,158],c,[9166,14],c,[9165,43],c,[10402,11],c,[10116,43],c,[10007,8],c,[9995,120],c,[1966,187],c,[540,114],25,c,[9538,15],c,[422,9],c,[9938,85],c,[9937,10],c,[6620,7],267,268,c,[9835,49],c,[2156,17],c,[57,48],17,c,[116,10],c,[2565,44],c,[9232,12],c,[5581,30],c,[15635,30],c,[21083,396],c,[9477,38],c,[1287,10],19,20,c,[616,43],c,[279,111],c,[2686,5],c,[8535,9],26,c,[8536,33],c,[4519,3],c,[22972,4],c,[8579,40],c,[40,9],120,c,[8388,31],118,c,[8466,37],c,[11084,5],c,[8587,39],296,c,[1183,6],29,c,[1180,3],c,[45,31],c,[13109,3],c,[1436,15],c,[2795,6],c,[59,4],c,[1440,30],69,c,[2787,3],c,[7612,26],119,c,[245,9],c,[2773,3],c,[7617,7],c,[125,3],c,[109,109],c,[4243,5],24,c,[8900,5],20,c,[6,3],c,[316,39],c,[163,109],c,[397,16],c,[9068,40],c,[437,218],15,c,[20834,4],c,[9377,34],c,[9287,21],c,[861,20],c,[189,109],c,[5572,5],c,[9297,3],c,[8577,14],c,[2081,27],c,[18647,47],c,[9299,29],c,[2079,5],c,[9304,49],c,[1404,8],145,16,26,16,26,32,c,[9115,4],311,c,[8898,4],142,143,258,142,258,142,258,c,[10,3],c,[83,10],c,[4259,45],c,[73,3],308,26,c,[74,7],88,c,[73,6],c,[1503,108],c,[8974,4],c,[18466,203],c,[5236,121],c,[1817,21],c,[1170,36],c,[9215,39],c,[9214,42],258,275,276,277,279,c,[6487,4],c,[358,102],c,[8026,9],c,[13099,3],c,[2360,7],c,[13097,39],c,[13096,18],c,[13332,16],c,[13092,12],c,[5847,144],c,[96,9],c,[18389,29],c,[5318,25],c,[52,27],83,c,[53,24],c,[14919,48],c,[57,66],c,[12448,30],86,c,[295,5],c,[3215,13],196,c,[8796,112],c,[18781,55],26,c,[10582,27],c,[8004,105],c,[119,65],c,[8122,155],82,c,[203,3],195,c,[5,5],c,[9034,124],c,[11147,44],c,[21421,125],c,[9385,3],40,c,[9386,3],c,[7,21],26,c,[11153,98],c,[8666,204],c,[8386,112],c,[6920,3],185,c,[19166,28],c,[5749,15],c,[120,14],c,[5747,15],166,168,c,[125,31],c,[24056,27],c,[16038,34],c,[123,83],c,[18654,94],c,[8936,91],219,c,[2440,97],c,[19943,53],c,[20038,41],c,[11968,13],c,[8966,119],c,[9732,199],68,c,[2061,14],c,[214,102],c,[8687,5],c,[9172,5],c,[10,5],c,[27223,7],c,[2741,105],c,[6518,3],c,[5851,31],72,c,[2694,24],c,[59,62],c,[20231,5],c,[60,35],143,146,147,c,[62,7],c,[9010,3],c,[20284,10],c,[20269,6],224,259,26,31,c,[290,3],c,[9498,7],c,[23,3],c,[9016,115],20,25,c,[20400,4],26,c,[9141,7],265,268,26,c,[14184,197],c,[29405,128],c,[241,13],31,32,c,[9051,5],231,22,114,c,[26441,145],c,[8443,144],c,[3979,156],c,[17664,11],c,[8599,43],16,26,c,[24049,99],c,[7536,96],c,[19921,213],c,[7172,136],c,[8654,99],c,[18944,125],c,[8909,3],c,[18541,50],c,[5377,121],c,[171,171],20,c,[8648,195],c,[19361,5],c,[303,53],c,[18184,56],c,[18580,113],c,[116,99],c,[115,10],c,[15718,112],c,[16887,194],c,[5669,72],c,[8553,101],c,[7068,53],c,[8303,35],c,[8383,7],c,[38,34],c,[13028,44],c,[6732,10],c,[8466,23],c,[7643,156],c,[3482,3],c,[6923,40],c,[4292,5],c,[7989,111],c,[305,37],c,[3673,3],c,[7575,3],294,c,[9802,7],c,[10345,6],c,[8740,35],c,[211,3],20,25,c,[8471,125],c,[8635,164],c,[497,148],c,[312,36],c,[920,8],c,[9259,35],c,[17703,84],c,[8403,29],c,[17816,114],c,[793,3],128,c,[8453,5],142,258,26,32,c,[8388,4],142,258,68,c,[8537,14],c,[4172,61],c,[822,139],c,[549,39],c,[1390,25],c,[5812,75],c,[4722,3],c,[75,3],117,118,c,[3166,3],c,[8167,6],c,[18555,3],c,[14,7],c,[13,3],c,[121,91],c,[9757,4],71,78,247,c,[32358,54],c,[419,28],c,[101,11],247,278,20,15,c,[97,20],c,[6039,79],c,[6137,19],c,[17525,313],c,[31791,228],c,[19003,109],c,[2890,50],26,32,c,[7918,135],c,[19243,99],66,68,c,[26803,98],c,[7629,3],c,[7380,95],c,[7722,124],c,[15954,4],c,[17458,3],c,[5522,12],c,[386,43],16,c,[6372,91],185,c,[19707,3],274,26,79,c,[16995,301],c,[7360,8],c,[98,97],c,[7789,17],c,[1301,99],c,[7144,6],c,[6,6],c,[24571,115],32,121,142,c,[5330,57],15,c,[27592,9],c,[2481,3],c,[7201,9],c,[7200,196],c,[6594,146],c,[3188,59],c,[1849,59],c,[1186,109],c,[14031,7],25,c,[10646,171],32,c,[16249,4],c,[4410,3],c,[3889,40],c,[4280,39],c,[3497,40],c,[13269,42],25,c,[163,41],c,[3331,4],294,c,[13093,6],16,c,[4626,41],c,[218,81],c,[39,38],c,[6369,17],c,[3919,112],c,[13650,147],22,c,[658,5],115,68,c,[158,150],c,[125,16],26,c,[12808,4],c,[178,5],24,c,[4065,10],c,[13736,6],c,[16,10],c,[18459,4],c,[14,7],277,279,26,c,[30083,91],c,[3994,5],71,248,c,[4098,3],c,[22715,5],c,[5598,38],c,[762,39],25,118,c,[12000,114],c,[6525,203],c,[31337,60],c,[1545,99],c,[2716,91],185,c,[10168,9],c,[16877,8],c,[3406,58],c,[3405,53],c,[3628,4],c,[3253,3],c,[492,97],c,[78,3],c,[10050,62],c,[63,13],c,[16138,54],c,[8149,162],c,[7617,209],79,120,c,[2248,43],c,[1750,41],c,[6866,46],c,[89,43],c,[8340,4],c,[14992,40],c,[1601,38],c,[170,3],c,[14125,102],c,[276,5],c,[1901,16],15,c,[12,8],c,[11,11],c,[23,4],c,[1750,40],c,[1934,91],71,c,[28973,91],278,c,[6538,194],c,[7399,150],c,[2446,76],c,[37811,248],c,[13879,103],c,[2388,48],c,[2057,4],68,c,[11588,151],20,c,[3756,121],c,[7311,91],16,c,[3338,16],c,[1469,6],c,[7436,27],c,[1019,201],c,[92,91],c,[3866,166],c,[638,129],c,[28411,221],c,[13557,95],c,[4156,41],c,[2721,83],c,[1076,5],c,[4419,17],c,[2161,39],c,[3683,4],c,[2781,36],c,[7329,98],c,[1487,120],c,[5586,7],c,[265,40],25,c,[451,85],c,[10078,17],c,[1279,75],c,[15718,91],278]),type:u([s,[2,65],s,[0,50],1,c,[110,66],s,[2,91],c,[92,158],s,[0,47],c,[111,175],c,[137,30],s,[2,143],c,[284,51],c,[196,12],c,[308,73],s,[0,49],c,[137,6],c,[540,117],c,[117,112],c,[566,69],c,[773,138],c,[721,97],c,[788,116],c,[58,12],s,[2,144],c,[807,67],c,[463,30],c,[1334,96],c,[1648,286],c,[111,333],c,[112,337],c,[1773,49],c,[114,179],c,[1999,54],c,[1576,146],c,[1054,290],c,[2500,126],c,[123,57],c,[127,72],c,[118,53],c,[7,14],c,[991,178],c,[111,380],c,[1436,114],c,[2668,619],c,[1836,224],c,[891,223],c,[5062,186],c,[5349,97],c,[461,206],c,[4584,18],c,[172,33],c,[5039,179],c,[579,257],c,[113,10],c,[5864,8],c,[5865,83],c,[146,49],c,[6696,159],c,[566,140],c,[612,53],c,[3,6],c,[3981,100],c,[99,50],c,[4257,127],c,[5955,117],c,[1862,172],c,[533,116],c,[123,54],c,[4100,125],c,[7913,159],c,[206,139],c,[6381,68],c,[301,50],c,[1655,21],c,[2014,103],c,[2239,186],c,[113,53],c,[2130,12],c,[407,21],c,[2657,25],c,[2700,23],c,[315,116],c,[7528,123],c,[1003,201],c,[8812,191],c,[288,198],c,[3848,301],c,[208,372],c,[6714,134],c,[390,146],c,[5283,121],c,[9035,24],c,[5214,163],c,[2557,43],c,[185,145],c,[1544,163],c,[852,98],c,[5816,211],c,[1479,189],c,[393,72],c,[1427,144],c,[6314,208],c,[345,213],c,[170,13],c,[182,74],c,[647,167],c,[1284,237],c,[6285,18],c,[893,170],c,[111,98],c,[3223,187],c,[473,72],c,[4543,119],c,[4126,292],c,[2007,232],c,[4985,271],c,[97,869],c,[143,56],c,[149,25],c,[3559,67],c,[1902,49],c,[7035,41],c,[1314,37],c,[1351,39],c,[1391,23],c,[5282,63],c,[1838,166],c,[2608,165],c,[9360,21],c,[14189,8],c,[14572,77],c,[10088,150],c,[250,11],c,[8161,121],c,[7280,206],c,[8498,172],c,[6859,279],c,[12156,557],c,[10771,170],c,[9876,128],c,[129,51],c,[1347,161],c,[14951,88],c,[4303,124],c,[124,365],c,[6801,117],c,[4645,236],c,[6429,182],c,[1564,113],c,[13175,48],c,[10516,126],c,[999,122],c,[1017,121],c,[2551,339],c,[2203,17],c,[4678,11],c,[10111,273],c,[13019,164],c,[10232,130],c,[5533,117],c,[244,100],c,[53,66],c,[17798,149],c,[13630,180],c,[8611,159],c,[4741,119],c,[2887,238],c,[238,60],c,[1262,175],c,[10165,57],c,[9643,120],c,[114,164],c,[171,65],c,[487,75],c,[16144,210],c,[8673,211],c,[421,55],c,[669,110],c,[12347,30],c,[502,156],c,[21083,381],c,[15899,103],c,[12043,72],c,[8303,46],c,[12942,65],c,[41,39],c,[1922,43],c,[385,45],c,[10168,231],c,[22501,14],c,[316,43],c,[1191,125],c,[563,62],c,[13103,228],c,[822,47],c,[298,114],c,[114,73],c,[2979,103],c,[7254,17],c,[4191,9],c,[2040,6],c,[2044,57],c,[9212,12],c,[73,51],c,[5602,177],c,[5236,237],c,[872,114],c,[6487,13],c,[3246,202],c,[611,190],c,[15900,109],c,[14976,123],c,[2995,161],c,[543,77],c,[22948,172],c,[1893,120],c,[10381,244],c,[15340,170],c,[8666,212],c,[7167,115],c,[24056,194],c,[16036,145],c,[26788,190],c,[98,169],c,[9732,328],c,[19810,56],c,[10,12],c,[235,150],c,[59,118],c,[62,22],c,[6109,9],c,[1068,83],c,[663,57],c,[21250,98],c,[4812,143],c,[921,109],c,[21164,96],c,[16961,202],c,[3979,199],c,[750,101],c,[5663,170],c,[19921,146],c,[4554,182],c,[325,124],c,[450,107],c,[10613,171],c,[17282,212],c,[8648,210],c,[4783,230],c,[15718,203],c,[97,162],c,[8553,161],c,[16769,44],c,[38,43],c,[21593,65],c,[7643,168],c,[152,43],c,[157,132],c,[3997,24],c,[2908,34],c,[363,128],c,[529,164],c,[654,147],c,[9306,59],c,[227,102],c,[13980,169],c,[14225,9],c,[10492,8],c,[3566,149],c,[822,92],c,[6362,120],c,[8845,16],c,[121,96],c,[4486,5],c,[2875,94],c,[6039,192],c,[29237,407],c,[15091,219],c,[8676,58],c,[16575,171],c,[5137,111],c,[7380,166],c,[5141,109],c,[19482,100],c,[27417,72],c,[21640,332],c,[20476,77],c,[35464,57],c,[1424,170],c,[20844,17],c,[7201,102],c,[7200,241],c,[667,63],c,[26258,175],c,[20774,66],c,[17127,129],c,[3458,137],c,[43,42],c,[36494,22],c,[394,33],c,[218,116],c,[4742,127],c,[4391,122],c,[3581,77],c,[4901,145],c,[1244,13],c,[1260,16],c,[8835,17],c,[13853,97],c,[4098,31],c,[684,107],c,[26976,155],c,[97,153],c,[21223,210],c,[11697,126],c,[3628,8],c,[7017,159],c,[23364,113],c,[8149,186],c,[3640,173],c,[1908,61],c,[1798,69],c,[41,81],c,[23339,118],c,[1901,29],c,[1883,15],c,[2434,135],c,[38381,97],c,[6538,290],c,[2623,125],c,[12279,296],c,[29615,108],c,[14472,126],c,[97,55],c,[7432,190],c,[3354,24],c,[40836,114],c,[40282,198],c,[4024,151],c,[638,146],c,[97,266],c,[16677,116],c,[2810,66],c,[4419,22],c,[144,54],c,[631,140],c,[1487,99],c,[265,70],c,[5169,149],c,[1371,93]]),state:u([1,2,3,5,26,56,64,21,22,20,17,18,25,38,19,35,34,16,90,55,23,48,50,52,51,46,76,47,79,103,24,111,80,106,87,107,49,27,65,45,75,77,4,15,14,11,31,6,9,10,123,124,127,128,131,165,118,166,167,168,c,[56,38],170,c,[56,7],171,c,[47,46],175,176,111,172,180,c,[51,46],183,182,194,87,107,195,190,31,187,191,201,c,[57,35],200,c,[57,7],197,199,c,[59,3],205,202,206,207,c,[109,46],209,218,c,[48,6],211,215,17,212,c,[51,28],217,213,c,[51,4],216,214,c,[51,3],219,c,[98,46],222,225,227,224,228,c,[51,46],230,234,236,237,239,238,240,246,248,249,256,111,253,254,258,257,262,c,[63,46],c,[311,17],263,c,[47,29],264,c,[94,46],265,c,[47,46],266,c,[47,46],267,c,[47,46],269,c,[47,46],271,c,[47,46],274,c,[47,3],273,c,[48,43],276,c,[48,3],277,c,[48,43],279,3,278,c,[949,46],283,287,288,286,291,292,c,[197,46],294,c,[47,46],297,26,296,56,298,64,295,c,[623,60],313,c,[47,6],302,304,47,308,c,[49,5],314,317,87,107,315,305,306,291,27,312,45,311,c,[54,9],328,c,[151,38],324,326,329,c,[50,8],334,106,331,332,256,111,335,254,336,c,[1258,47],337,c,[257,46],338,c,[47,46],339,c,[924,54],341,c,[1133,29],342,c,[48,5],340,c,[48,3],345,c,[95,9],343,c,[96,37],346,c,[143,46],347,c,[47,46],348,c,[47,46],349,c,[47,46],350,c,[47,46],351,c,[47,46],352,c,[47,46],353,c,[47,3],354,c,[48,43],355,c,[871,52],358,c,[50,43],c,[1969,7],359,c,[104,46],c,[54,7],360,369,79,103,c,[30,3],378,364,366,374,375,372,373,365,362,363,368,367,386,c,[73,46],391,c,[47,18],388,390,c,[122,35],394,3,393,c,[943,46],399,397,404,401,402,c,[2050,4],409,31,407,410,411,c,[165,46],415,412,413,418,c,[2101,44],419,c,[2101,4],420,c,[170,7],205,421,205,422,423,424,c,[13,6],426,118,279,3,427,c,[184,46],428,c,[171,46],429,c,[168,36],436,435,c,[2269,11],249,c,[168,7],c,[7,7],445,26,56,443,c,[64,5],440,441,442,447,c,[116,38],453,456,c,[116,3],455,c,[165,33],457,c,[49,9],458,227,459,c,[569,14],462,c,[569,3],465,c,[129,7],466,c,[2213,5],471,c,[2681,48],472,c,[49,48],475,477,480,482,486,488,490,495,c,[109,3],493,494,496,246,498,499,c,[63,3],502,c,[362,43],256,111,504,506,c,[412,46],508,c,[47,3],507,c,[48,35],509,c,[747,14],c,[2796,4],c,[420,14],c,[7,14],511,c,[955,53],512,c,[54,53],513,c,[54,53],c,[412,19],c,[1997,29],c,[3149,15],c,[7,7],516,c,[482,48],517,c,[613,14],518,c,[613,3],521,c,[19,14],523,c,[19,3],524,525,c,[96,7],279,3,527,c,[3308,52],530,c,[160,8],533,c,[284,46],534,c,[2273,24],536,c,[2273,29],539,c,[2273,49],c,[104,17],541,c,[3419,33],544,543,291,548,c,[54,3],550,c,[105,29],547,c,[56,6],549,c,[56,7],524,246,554,552,555,c,[2431,39],556,c,[158,10],557,c,[594,53],559,c,[54,46],560,334,106,563,564,c,[51,46],c,[991,3],c,[878,21],c,[1376,37],566,c,[1376,11],572,c,[49,9],571,c,[226,44],c,[7,70],575,576,111,c,[754,14],577,c,[754,3],580,c,[19,7],591,589,c,[19,4],592,588,368,367,586,597,594,596,c,[21,14],601,368,367,602,c,[18,8],604,c,[18,5],368,367,c,[16,8],605,c,[16,15],606,608,c,[17,7],611,c,[1467,5],c,[123,7],613,c,[2011,19],615,c,[2011,36],617,c,[530,53],623,622,625,626,404,631,402,633,c,[61,53],638,415,641,413,c,[2017,44],642,c,[59,3],418,646,c,[49,3],648,c,[108,43],651,654,c,[49,3],653,c,[157,50],c,[7,7],656,c,[218,46],657,c,[47,46],658,c,[47,46],659,c,[47,46],660,c,[4202,63],c,[47,19],661,c,[47,10],420,663,c,[95,46],c,[2275,9],664,c,[2275,41],669,673,674,c,[100,3],675,c,[445,50],166,297,26,677,c,[2962,3],c,[3011,45],678,c,[49,48],679,c,[49,48],680,c,[49,46],c,[305,9],681,c,[305,41],683,c,[303,3],682,c,[303,50],684,686,688,c,[509,17],693,c,[57,29],696,694,695,c,[1232,8],c,[1251,7],698,c,[1251,3],699,475,703,c,[71,3],701,c,[129,43],705,c,[2142,48],709,c,[1260,4],713,c,[52,3],712,c,[102,43],714,c,[682,46],715,c,[47,46],716,c,[47,46],721,724,728,726,555,729,c,[198,3],730,c,[56,38],731,c,[428,14],471,3,732,c,[306,46],733,c,[1922,48],734,254,c,[1283,14],736,c,[1764,21],580,c,[2219,34],744,49,743,c,[2220,13],580,746,748,c,[2715,9],750,c,[150,38],751,c,[59,7],752,c,[47,3],755,c,[48,35],753,c,[877,9],756,c,[877,46],757,c,[2153,24],c,[2591,7],761,c,[2590,28],763,764,c,[54,3],765,c,[110,43],768,c,[48,3],769,c,[936,50],c,[2597,4],c,[375,34],773,c,[2594,14],c,[60,7],775,c,[56,3],774,c,[115,35],776,c,[5075,46],778,779,c,[164,8],554,782,555,c,[546,14],783,c,[8,7],786,c,[641,46],787,c,[1718,82],788,c,[47,10],c,[4995,10],789,c,[378,44],792,c,[149,46],580,794,795,c,[2562,15],796,368,367,799,c,[18,14],800,c,[1329,3],c,[2508,8],803,c,[2508,8],c,[17,8],806,c,[16,7],808,c,[2613,17],810,c,[18,8],811,c,[35,7],816,597,817,596,820,c,[39,14],821,c,[73,10],c,[38,8],c,[33,14],823,c,[17,10],825,c,[33,15],829,c,[139,8],475,c,[2634,19],834,c,[245,28],835,c,[300,7],404,839,840,842,843,844,c,[13,7],415,846,848,851,638,c,[2533,44],853,c,[468,39],c,[48,8],854,c,[3054,4],c,[1308,9],855,c,[1308,46],c,[278,14],856,368,367,867,859,862,863,866,696,872,695,c,[81,7],873,c,[2776,53],c,[7,20],876,c,[8,7],878,118,880,249,c,[223,36],884,c,[86,17],c,[2063,9],886,c,[2063,41],c,[51,9],887,c,[50,40],888,c,[155,3],889,c,[242,43],890,892,893,c,[50,3],894,c,[292,50],c,[5427,6],895,c,[57,50],898,c,[112,3],897,c,[55,43],899,c,[366,17],901,c,[48,29],902,906,907,909,c,[416,30],c,[1539,5],49,910,291,c,[55,5],908,c,[55,7],911,c,[54,53],c,[1489,4],912,914,915,580,919,c,[60,3],917,c,[213,43],921,c,[48,3],920,c,[316,50],925,c,[55,3],924,c,[55,43],926,c,[2413,4],927,c,[3679,12],c,[7,21],929,931,490,935,934,c,[36,3],937,c,[814,46],c,[5124,4],940,941,c,[82,21],c,[4103,3],946,947,948,c,[79,38],949,c,[893,21],472,3,952,c,[4861,45],953,c,[70,7],954,c,[1662,63],c,[101,7],955,c,[2095,28],c,[53,24],956,c,[4739,29],c,[1252,9],958,c,[8220,53],471,3,959,c,[56,53],c,[4596,47],c,[2103,39],961,c,[4747,10],c,[50,39],962,c,[4954,26],c,[49,19],964,c,[1429,24],965,249,c,[2050,10],966,c,[828,44],c,[1981,14],967,c,[1841,9],c,[17,7],968,c,[4577,10],c,[18,7],970,c,[2016,11],c,[1893,16],972,c,[2032,16],c,[1665,6],975,c,[2033,11],977,c,[35,8],597,978,816,c,[38,14],982,c,[2014,32],987,c,[33,26],988,c,[121,16],989,c,[16,15],c,[170,8],c,[2045,19],992,c,[6738,47],993,c,[4727,29],404,996,997,415,999,1000,418,c,[350,14],c,[176,17],1004,c,[176,16],1005,c,[17,8],1006,867,1008,1009,863,866,867,1012,863,866,1015,1016,s,[1019,4,1],1025,914,c,[75,7],1027,c,[689,46],1028,c,[47,46],1030,c,[47,3],1029,c,[48,43],1032,c,[48,3],1031,c,[48,43],1033,c,[143,46],1034,c,[6728,8],c,[4288,49],c,[791,14],1037,c,[1674,4],1038,1040,c,[1733,53],c,[67,7],1044,696,1046,1050,c,[62,3],1049,c,[2352,64],1052,1053,c,[259,46],1054,490,1055,490,1056,c,[2472,53],c,[3973,4],c,[1669,4],1057,496,c,[137,21],763,c,[15,14],1063,c,[100,3],1065,c,[101,43],554,1066,555,1068,249,1069,c,[3128,47],c,[1073,24],c,[985,6],1074,c,[17,10],1075,c,[793,16],c,[826,16],c,[66,8],597,1078,597,1079,c,[5734,9],c,[1072,22],1081,c,[17,10],1082,c,[87,16],1083,c,[104,40],1087,c,[187,24],c,[16,8],1006,1015,867,1094,c,[941,3],867,1096,c,[950,3],1097,866,1101,1103,1105,1106,1107,c,[135,14],1108,c,[152,16],1111,368,367,c,[380,6],1114,c,[388,7],1116,c,[2176,21],1119,118,1120,c,[358,46],1122,1126,c,[743,52],1127,696,1128,c,[2309,28],471,3,1131,c,[1888,46],1133,c,[692,53],c,[391,32],c,[1580,9],c,[33,24],c,[610,30],1140,c,[3331,3],1144,c,[3331,3],1015,1015,867,1146,c,[424,3],1147,866,867,1149,863,866,c,[35,14],1151,368,367,1154,1155,1156,c,[103,24],1157,c,[1754,22],1158,c,[577,18],1159,1162,c,[257,3],1161,c,[258,43],1164,c,[48,3],1163,c,[48,43],1165,c,[48,3],1166,c,[354,49],1168,118,1169,c,[473,14],c,[828,30],1173,c,[17,10],1174,c,[1691,9],1015,867,1177,c,[746,4],1179,c,[315,10],c,[61,8],1181,1183,c,[384,24],c,[95,16],1185,c,[78,8],c,[622,21],1186,c,[220,3],1187,c,[220,43],c,[181,14],1188,c,[975,34],c,[513,3],1194,c,[191,10],1195,c,[470,16],c,[39,8],c,[292,37],1197,c,[17,10],1198,c,[73,8],1015,c,[264,40],c,[32,8],1206,1208]),mode:u([2,s,[1,64],2,1,s,[2,5],c,[9,4],c,[19,13],c,[59,36],s,[2,83],c,[85,85],c,[91,13],s,[1,129],c,[244,54],c,[37,21],c,[77,4],c,[441,4],c,[16,10],c,[96,10],c,[472,7],c,[3,6],c,[471,6],c,[258,11],c,[99,23],c,[26,5],c,[534,11],c,[94,4],c,[72,11],c,[554,8],c,[45,9],c,[562,9],c,[83,8],c,[14,9],s,[1,285],c,[809,146],c,[79,31],c,[828,81],c,[178,67],c,[765,6],c,[1144,156],c,[232,6],c,[238,49],c,[47,27],c,[75,17],s,[1,717],c,[972,74],c,[75,51],c,[1945,20],c,[375,231],c,[119,125],c,[2149,6],c,[2103,293],c,[1462,680],c,[1481,64],c,[64,46],c,[1290,85],c,[135,12],c,[3314,6],c,[3870,11],c,[35,8],c,[1715,40],c,[3372,13],c,[156,80],c,[1338,26],c,[336,15],c,[178,7],c,[179,15],c,[1837,7],c,[1693,163],c,[403,145],c,[314,88],c,[3224,90],c,[2465,135],c,[3365,22],c,[138,102],c,[58,42],c,[1426,195],c,[2823,53],c,[549,126],c,[1011,15],c,[2744,147],c,[779,74],c,[69,22],c,[156,122],c,[5501,98],c,[635,54],c,[1943,156],c,[592,74],c,[5562,10],c,[9,17],c,[5593,9],c,[5597,12],c,[3733,232],c,[2287,80],c,[6016,91],c,[4166,13],c,[445,10],c,[5978,8],c,[143,12],c,[215,13],c,[123,34],c,[270,90],c,[90,179],c,[2891,155],c,[3201,219],c,[1911,41],c,[109,31],c,[139,45],c,[273,69],c,[21,18],c,[164,14],c,[1355,126],c,[6333,143],c,[3066,96],c,[75,70],c,[3125,7],c,[1389,85],c,[515,164],c,[566,131],c,[1349,155],c,[68,28],c,[1151,46],c,[350,69],c,[71,45],c,[6538,204],c,[662,80],c,[614,13],c,[2867,6],c,[2883,16],c,[1489,60],c,[8895,157],s,[2,138],c,[8736,10],c,[288,53],c,[3173,141],c,[882,104],c,[255,11],c,[5055,122],c,[2390,99],c,[90,114],c,[1648,130],c,[4978,63],c,[1089,88],c,[3971,156],c,[640,269],c,[90,204],c,[360,35],c,[270,147],c,[3318,33],c,[180,122],c,[1090,89],c,[5305,75],c,[821,18],c,[6448,177],c,[2132,79],c,[9077,111],c,[3284,50],c,[9080,7],c,[520,76],c,[4522,91],c,[170,17],c,[9265,61],c,[244,72],c,[2019,98],c,[9703,113],c,[2405,157],c,[9126,326],c,[3747,111],c,[10201,145],c,[265,11],c,[267,28],c,[41,12],c,[162,115],c,[10749,120],c,[937,315],c,[3195,91],c,[13,19],c,[12721,33],c,[8141,128],c,[181,90],c,[8045,70],c,[2076,94],c,[2713,147],c,[1731,195],c,[10099,13],c,[284,71],c,[2291,268],c,[3784,140],c,[12703,34],c,[3691,150],c,[6278,11],c,[14729,58],c,[3300,11],c,[14729,19],c,[103,10],c,[14729,39],c,[2550,71],c,[5830,11],c,[6281,134],c,[5421,85],c,[1395,252],c,[1293,99],c,[799,8],c,[2681,16],c,[1985,54],c,[7156,65],c,[317,78],c,[1167,39],c,[15226,50],c,[228,13],c,[7401,66],c,[1512,255],c,[1347,10],c,[2456,66],c,[4934,50],c,[7286,88],c,[11767,126],c,[14608,304],c,[1219,10],c,[113,92],c,[474,25],c,[963,7],c,[31,19],c,[1896,86],c,[3800,30],c,[2047,102],c,[12369,33],c,[1254,16],c,[5759,13],c,[1204,51],c,[1788,15],c,[4084,10],c,[14158,108],c,[382,45],c,[109,91],c,[14423,129],c,[156,28],c,[159,14],c,[7189,29],c,[1059,33],c,[1566,17],c,[1139,39],c,[16940,10],c,[1695,53],c,[61,14],c,[2635,228],c,[9974,90],c,[3516,11],c,[9136,61],c,[14050,11],c,[18789,16],c,[277,84],c,[4936,11],c,[3690,13],c,[3689,29],c,[9680,7],c,[626,13],c,[67,10],c,[755,21],c,[6695,280],c,[14580,46],c,[6435,85],c,[14131,155],c,[5228,175],c,[5610,113],c,[4453,20],c,[12007,7],c,[12550,100],c,[1333,73],c,[6120,138],c,[3048,99],c,[69,43],c,[13945,89],c,[15922,91],c,[11528,190],c,[1617,137],c,[1841,169],c,[13953,99],c,[13199,8],c,[852,44],c,[52,59],c,[53,36],c,[1170,12],c,[5214,15],c,[9756,79],c,[4990,194],c,[271,37],c,[752,97],c,[12632,213],c,[6351,79],c,[3086,104],c,[1806,48],c,[3336,93],c,[5761,118],c,[13909,72],c,[17213,66],c,[5396,158],c,[6002,59],c,[8461,113],c,[115,107],c,[783,188],c,[20412,255],c,[13003,181],c,[4263,130],c,[4017,152],c,[5906,114],c,[6655,22],c,[120,21],c,[6045,114],c,[8813,12],c,[1168,27],c,[6457,131],c,[131,109],c,[6456,156],c,[4961,180],c,[2615,38],c,[7070,131],c,[20400,112],c,[2938,19],c,[20511,94],c,[23650,19],c,[19426,78],c,[4646,98],c,[12995,413],c,[2171,70],c,[396,122],c,[25881,39],c,[6067,95],c,[5706,90],c,[3812,75],c,[17810,41],c,[6221,101],c,[11821,160],c,[22495,92],c,[5588,90],c,[2207,139],c,[11207,17],c,[158,42],c,[10909,13],c,[4760,188],c,[4991,45],c,[6719,18],c,[530,24],c,[19260,44],c,[11595,60],c,[588,104],c,[402,44],c,[3844,85],c,[822,73],c,[10182,26],c,[1702,41],c,[373,86],c,[2989,134],c,[3496,111],c,[6765,31],c,[275,20],c,[18764,35],c,[275,55],c,[10478,15],c,[7041,14],c,[288,22],c,[6273,79],c,[2865,149],c,[5040,180],c,[2983,124],c,[8661,89],c,[12808,69],c,[8025,103],c,[7755,47],c,[6211,59],c,[23003,171],c,[3298,94],c,[1753,51],c,[461,8],c,[1749,89],c,[10794,109],c,[13390,42],c,[1777,26],c,[21943,91],c,[29694,91],c,[5081,147],c,[5716,114],c,[19977,140],c,[13270,234],c,[18629,93],c,[1179,69],c,[5630,94],c,[15410,12],c,[774,208],c,[865,115],c,[6936,132],c,[20843,203],c,[2890,157],c,[991,53],c,[2022,54],c,[1196,97],c,[2374,72],c,[3998,32],c,[306,53],c,[1057,179]]),goto:u([1,57,93,94,95,98,101,78,102,s,[58,6,1],91,92,96,97,99,s,[40,5,1],39,36,37,7,108,74,73,s,[69,4,1],109,53,86,88,89,s,[81,5,1],104,110,54,114,105,112,113,100,8,12,13,33,32,66,67,68,28,29,30,2,115,s,[9,5],116,117,10,138,140,136,142,146,155,156,162,163,10,120,s,[10,3],125,126,129,130,132,134,s,[135,5,2],144,145,s,[147,8,1],s,[157,5,1],164,119,121,122,c,[87,4],133,s,[458,84],100,s,[458,6],s,[460,84],100,s,[460,6],c,[305,12],169,c,[306,52],c,[370,64],s,[21,17],177,s,[21,36],174,s,[21,20],173,179,21,21,178,21,110,114,s,[21,7],599,c,[155,5],s,[599,7],101,s,[599,5],78,599,599,102,599,599,c,[171,4],181,599,62,63,s,[599,6],c,[179,4],s,[599,20],99,599,599,c,[201,3],599,599,c,[203,3],599,36,s,[599,5],37,599,7,599,108,s,[599,5],74,599,599,73,s,[599,6],109,53,599,86,s,[599,3],88,599,599,c,[226,10],599,c,[227,4],s,[599,5],c,[232,4],599,c,[233,7],184,185,186,100,192,188,193,196,39,189,113,c,[17,3],c,[311,12],198,c,[312,52],204,203,100,100,c,[69,6],208,c,[380,57],210,c,[34,4],c,[449,64],c,[64,12],220,c,[65,7],221,c,[66,45],s,[217,67],223,s,[217,22],s,[139,52],388,s,[139,3],226,c,[5,4],s,[139,26],100,s,[139,6],c,[314,64],233,232,231,229,244,245,235,242,243,241,s,[362,66],c,[121,3],362,362,247,s,[362,72],100,s,[252,84],250,251,s,[252,4],110,114,255,s,[197,46],261,s,[197,26],259,260,s,[197,15],c,[716,76],c,[64,256],268,c,[65,64],270,c,[65,64],272,c,[65,57],275,c,[65,6],232,c,[65,7],231,c,[66,116],c,[197,7],280,c,[197,52],284,282,281,179,285,s,[378,71],196,378,378,289,388,s,[378,49],113,290,s,[378,17],c,[605,70],293,c,[64,62],155,156,c,[130,13],299,148,300,c,[2443,6],c,[139,52],301,78,309,c,[74,4],303,c,[141,10],319,44,39,289,388,c,[68,13],310,88,307,c,[70,12],318,320,321,322,316,c,[73,17],330,78,102,323,c,[74,4],325,c,[215,26],327,c,[141,26],333,105,112,c,[1301,3],4,c,[75,6],4,78,4,102,4,c,[76,4],4,c,[1216,320],344,c,[321,320],c,[64,185],c,[1468,73],c,[130,52],s,[73,18],356,s,[73,45],s,[75,18],357,s,[75,45],c,[1318,75],464,c,[3844,9],s,[464,4],120,s,[464,7],125,126,464,130,464,464,c,[3852,8],464,148,464,c,[91,6],464,464,c,[3852,3],s,[464,37],133,464,464,c,[357,64],116,117,466,c,[156,9],s,[466,4],120,s,[466,7],c,[4007,5],466,c,[4008,22],s,[466,9],119,s,[466,5],121,122,466,466,c,[104,4],s,[466,14],133,466,466,361,s,[388,3],377,383,376,382,370,379,384,380,c,[128,7],c,[127,3],100,371,381,385,c,[733,76],389,c,[65,26],387,392,c,[67,26],600,c,[247,9],s,[600,4],120,s,[600,7],125,126,600,130,600,600,c,[247,8],600,148,600,c,[247,6],600,600,c,[247,3],s,[600,37],133,600,600,c,[221,64],395,606,606,398,287,606,606,396,400,405,403,100,406,192,c,[3815,3],408,c,[3815,16],c,[86,52],414,100,416,s,[586,12],417,s,[586,77],c,[157,64],s,[595,84],c,[3365,3],s,[595,3],c,[486,9],120,c,[4729,35],100,100,c,[691,4],s,[388,54],c,[58,42],c,[147,9],233,120,232,c,[149,27],231,425,c,[151,8],c,[2821,65],c,[415,64],c,[33,4],s,[430,4,1],s,[406,9],434,s,[406,50],c,[4519,65],437,143,143,144,144,463,463,s,[252,42],170,170,c,[3892,16],c,[378,9],145,145,c,[527,28],145,c,[377,8],c,[573,10],438,c,[47,27],439,c,[424,20],c,[226,14],451,37,444,446,448,449,450,c,[230,35],452,s,[218,68],454,s,[218,21],c,[2002,66],c,[4613,87],s,[139,6],s,[473,54],460,s,[473,35],461,c,[1669,4],463,c,[1670,17],384,464,103,c,[481,9],s,[103,4],120,s,[103,7],125,126,103,130,103,103,c,[492,8],103,148,103,c,[492,6],103,103,c,[492,3],s,[103,37],133,103,103,244,245,467,c,[4749,3],469,468,c,[531,12],470,c,[955,116],474,287,287,473,476,s,[414,7],478,479,s,[416,7],478,479,s,[421,8],481,478,479,484,483,s,[429,3],485,s,[429,7],487,s,[296,3],491,489,243,241,244,330,245,492,c,[193,3],c,[107,3],247,c,[4956,3],497,c,[571,8],501,c,[135,4],500,c,[572,53],505,110,503,114,255,c,[2709,88],510,c,[67,42],26,c,[500,9],s,[26,4],120,s,[26,7],c,[991,5],26,c,[992,22],s,[26,9],119,s,[26,5],121,122,26,26,c,[102,4],s,[26,14],133,26,26,s,[29,17],177,s,[29,36],174,s,[29,20],173,179,29,29,178,29,110,114,s,[29,7],s,[30,3],136,142,s,[30,9],120,s,[30,8],126,30,130,30,30,c,[180,3],30,c,[180,4],s,[30,8],157,s,[30,4],164,s,[30,37],133,30,30,31,c,[270,9],s,[31,4],120,s,[31,7],c,[270,5],31,c,[270,22],s,[31,9],119,s,[31,5],121,122,31,31,c,[270,4],s,[31,14],133,31,31,32,c,[90,9],s,[32,4],120,s,[32,7],c,[90,5],32,c,[90,22],s,[32,9],119,s,[32,5],121,122,32,32,c,[90,4],s,[32,14],133,32,32,33,c,[90,9],s,[33,4],120,s,[33,7],c,[90,5],33,c,[90,22],s,[33,9],119,s,[33,5],121,122,33,33,c,[90,4],s,[33,14],133,33,33,c,[671,64],35,c,[154,9],s,[35,4],120,s,[35,7],c,[154,5],35,c,[154,22],s,[35,9],119,s,[35,5],121,122,35,35,c,[102,4],s,[35,14],133,35,35,c,[154,64],37,c,[154,9],s,[37,4],120,s,[37,7],125,126,37,130,37,37,c,[154,8],37,148,37,c,[154,6],37,37,c,[154,3],s,[37,37],133,37,37,c,[154,64],c,[1892,10],221,c,[2466,32],221,221,c,[1891,7],c,[4719,67],208,c,[120,9],s,[208,4],120,s,[208,7],125,126,208,130,208,208,c,[131,8],208,148,208,c,[131,6],208,208,c,[131,3],s,[208,19],69,70,s,[208,16],133,208,c,[89,10],120,514,c,[7405,36],515,115,c,[322,64],179,c,[3428,21],519,520,s,[382,66],522,s,[382,76],c,[1925,22],s,[388,74],c,[3003,58],s,[388,12],384,526,s,[280,3],136,142,s,[280,9],120,s,[280,8],126,280,130,280,280,c,[459,3],280,c,[459,4],s,[280,8],157,s,[280,4],164,s,[280,37],133,280,280,c,[3016,65],c,[603,9],528,c,[3130,30],529,c,[605,8],s,[92,50],531,s,[92,39],s,[96,27],532,s,[96,62],50,c,[230,9],s,[50,4],120,s,[50,7],c,[239,5],50,c,[240,22],s,[50,9],119,s,[50,5],121,122,50,50,c,[254,4],s,[50,14],133,50,50,c,[873,64],287,535,287,287,c,[68,7],c,[1152,5],c,[1151,59],s,[256,9],301,301,c,[4,4],c,[5,3],s,[256,40],537,s,[327,11],538,s,[327,44],c,[5985,68],c,[322,39],540,c,[65,25],s,[406,9],315,315,c,[4,4],c,[5,3],s,[406,43],s,[398,9],316,316,c,[3,3],316,s,[398,35],c,[8461,40],c,[8453,8],173,179,542,178,c,[8438,3],388,546,289,388,545,c,[434,3],290,c,[2672,6],386,386,78,102,386,c,[2675,5],386,c,[2676,11],551,c,[569,42],388,420,420,388,c,[4,3],s,[420,5],c,[8,4],388,c,[6,3],s,[388,4],c,[23,12],c,[9,8],s,[420,13],c,[1245,12],c,[13,4],c,[40,8],c,[14,4],c,[71,5],s,[388,6],c,[79,9],c,[50,11],c,[52,3],s,[361,101],s,[354,3],s,[361,13],c,[8058,63],c,[8057,39],s,[358,3],s,[362,13],553,451,c,[923,8],c,[737,3],c,[670,30],c,[735,66],c,[1440,34],449,120,s,[449,4],c,[2046,34],558,c,[4148,27],c,[115,38],s,[453,6],330,s,[453,3],561,s,[453,58],c,[6968,3],562,c,[137,64],505,110,114,565,255,203,c,[258,9],s,[203,4],120,s,[203,7],125,126,203,130,203,203,c,[265,8],203,148,203,c,[265,6],203,203,c,[265,3],s,[203,19],69,70,s,[203,16],133,203,203,205,c,[90,9],s,[205,4],120,s,[205,7],125,126,205,130,205,205,c,[90,8],205,148,205,c,[90,6],205,205,c,[90,3],s,[205,19],69,70,s,[205,16],133,205,205,235,c,[90,9],s,[235,4],120,s,[235,7],c,[444,5],235,c,[445,22],s,[235,9],119,s,[235,5],121,122,235,235,c,[287,4],s,[235,14],133,235,235,c,[4851,65],567,568,s,[406,9],569,s,[406,48],s,[200,15],570,s,[200,74],c,[215,12],573,c,[215,52],206,c,[370,9],s,[206,4],120,s,[206,7],c,[370,5],206,c,[370,22],s,[206,9],119,s,[206,5],121,122,206,206,c,[102,4],s,[206,14],133,206,206,202,c,[90,9],s,[202,4],120,s,[202,7],125,126,202,130,202,202,c,[90,8],202,148,202,c,[90,6],202,202,c,[90,3],s,[202,19],69,70,s,[202,16],133,202,202,204,c,[90,9],s,[204,4],120,s,[204,7],125,126,204,130,204,204,c,[90,8],204,148,204,c,[90,6],204,204,c,[90,3],s,[204,19],69,70,s,[204,16],133,204,204,28,c,[90,9],s,[28,4],120,s,[28,7],c,[270,5],28,c,[270,22],s,[28,9],119,s,[28,5],121,122,28,28,c,[270,4],s,[28,14],133,28,28,41,c,[90,9],s,[41,4],120,s,[41,7],c,[90,5],41,c,[90,22],s,[41,9],119,s,[41,5],121,122,41,41,c,[90,4],s,[41,14],133,41,41,42,c,[90,9],s,[42,4],120,s,[42,7],c,[90,5],42,c,[90,22],s,[42,9],119,s,[42,5],121,122,42,42,c,[90,4],s,[42,14],133,42,42,43,c,[90,9],s,[43,4],120,s,[43,7],125,126,43,130,43,43,c,[90,8],43,148,43,c,[90,6],43,43,c,[90,3],s,[43,9],119,s,[43,5],121,122,43,43,c,[90,4],s,[43,14],133,43,43,44,c,[90,9],s,[44,4],120,s,[44,7],c,[180,5],44,c,[180,22],s,[44,9],119,s,[44,5],121,122,44,44,c,[90,4],s,[44,14],133,44,44,47,c,[90,9],s,[47,4],120,s,[47,7],c,[90,4],47,47,c,[90,22],s,[47,9],119,s,[47,5],121,122,47,47,c,[90,4],s,[47,14],133,47,47,410,c,[90,9],s,[410,4],120,s,[410,7],c,[180,5],410,c,[90,22],s,[410,9],119,s,[410,5],121,122,410,410,c,[90,4],s,[410,14],133,410,410,s,[91,50],531,s,[91,39],c,[3840,10],574,c,[3839,35],179,110,114,c,[3609,22],579,287,287,578,554,527,s,[554,3],581,582,554,527,527,556,530,s,[556,4],530,530,584,583,585,c,[47,4],587,c,[47,15],590,371,381,593,599,595,598,100,600,c,[3851,19],c,[28,3],603,384,c,[3875,21],c,[21,25],607,c,[22,15],609,371,381,244,245,610,c,[5392,3],c,[6734,44],612,133,614,s,[287,3],c,[1879,38],c,[7336,27],c,[115,9],277,120,s,[277,3],c,[119,34],277,616,c,[2132,65],c,[230,10],10,618,c,[451,35],115,619,620,621,c,[11155,4],607,607,288,607,607,624,100,287,627,287,628,s,[642,4],629,630,c,[7360,3],632,c,[140,64],634,635,611,c,[143,9],s,[611,4],120,s,[611,7],125,126,611,130,611,611,c,[153,8],611,148,611,c,[153,6],611,611,c,[153,3],s,[611,19],69,70,s,[611,16],133,611,611,636,637,287,639,s,[629,4],640,414,c,[11264,7],78,102,288,c,[168,4],288,c,[169,52],643,644,417,287,287,645,c,[5929,13],647,c,[5929,53],649,650,s,[471,55],652,s,[471,42],c,[6667,66],c,[548,10],655,c,[4838,36],233,c,[7413,10],s,[233,3],120,s,[233,7],c,[57,5],233,c,[58,22],s,[233,9],119,s,[233,5],121,122,233,233,c,[74,4],s,[233,14],133,233,233,c,[9256,384],s,[406,9],662,s,[406,52],s,[252,9],595,595,c,[4,6],s,[252,26],595,169,169,c,[7632,16],c,[252,90],c,[7601,42],665,667,666,233,670,232,231,668,671,s,[46,9],233,46,232,s,[46,27],231,672,s,[46,9],c,[902,76],c,[900,28],676,c,[901,7],186,186,c,[13064,3],c,[10748,80],c,[75,24],236,c,[75,14],236,236,c,[10898,109],c,[10973,76],c,[544,62],c,[485,66],211,c,[486,9],s,[211,4],120,s,[211,7],125,126,211,130,211,211,c,[498,8],211,148,211,c,[225,6],211,211,c,[498,3],s,[211,19],69,70,s,[211,16],133,211,211,s,[406,10],233,s,[406,9],232,s,[406,30],231,406,685,s,[406,36],s,[473,54],687,c,[8141,36],s,[132,10],692,s,[132,9],691,s,[132,30],690,132,689,s,[132,36],c,[1103,64],100,c,[2740,3],697,c,[2645,21],384,c,[8071,3],700,c,[522,24],702,c,[657,54],704,c,[163,52],115,706,707,115,708,244,245,s,[288,3],c,[2766,3],710,711,c,[10725,130],c,[64,128],s,[717,4,1],287,287,722,322,322,723,s,[322,3],478,479,725,484,483,727,451,287,244,245,c,[286,3],c,[90,64],399,c,[951,9],s,[399,4],120,s,[399,7],c,[1448,5],399,c,[1449,22],s,[399,9],119,s,[399,5],121,122,399,399,c,[102,4],s,[399,14],133,399,399,c,[8789,129],c,[12133,3],c,[3338,44],735,133,239,c,[47,9],s,[239,4],120,s,[239,7],c,[58,5],239,c,[59,22],s,[239,9],119,s,[239,5],121,122,239,239,c,[75,4],s,[239,14],133,239,239,s,[240,65],116,117,s,[240,23],c,[8952,3],c,[229,10],737,c,[2788,35],c,[46,10],738,c,[46,45],739,c,[3428,36],740,c,[1116,3],741,742,380,c,[442,5],s,[380,7],275,s,[380,5],78,380,380,102,380,380,c,[961,5],380,62,63,s,[380,6],c,[466,4],s,[380,20],99,380,c,[989,4],380,c,[6330,4],380,36,s,[380,5],37,380,7,380,108,s,[380,5],74,380,380,c,[505,5],380,380,109,53,380,86,s,[380,3],88,380,380,c,[513,10],380,c,[514,4],s,[380,5],c,[519,4],380,c,[520,7],c,[148,3],745,s,[364,68],384,s,[364,6],747,s,[364,68],s,[369,68],384,s,[369,74],c,[487,10],749,c,[3368,36],c,[1295,69],754,c,[1489,65],c,[2367,70],155,156,c,[57,9],51,c,[264,9],s,[51,4],120,s,[51,7],c,[273,5],51,c,[274,22],s,[51,9],119,s,[51,5],121,122,51,51,c,[113,4],s,[51,14],133,51,51,758,759,760,c,[309,6],288,78,309,c,[4030,16],c,[7575,49],c,[7649,3],762,c,[1812,6],312,312,78,102,312,c,[79,4],766,312,c,[327,27],767,c,[2552,38],770,c,[3037,62],449,120,771,c,[6733,38],772,s,[21,9],317,317,21,177,s,[317,3],c,[7411,37],c,[7410,4],c,[174,6],384,384,78,102,384,c,[571,5],384,c,[7401,54],371,c,[180,9],s,[371,4],120,s,[371,7],c,[187,5],371,c,[188,22],s,[371,9],119,s,[371,5],121,122,371,371,c,[102,4],s,[371,14],133,371,371,s,[372,65],116,117,s,[372,23],c,[2308,66],777,c,[7290,9],453,561,c,[642,5],453,c,[7294,53],781,780,553,287,287,451,c,[322,9],447,120,s,[447,4],c,[1610,44],450,120,s,[450,4],c,[50,35],330,c,[1982,44],784,133,s,[406,9],785,c,[11767,62],c,[4383,192],c,[6893,53],790,c,[364,10],206,791,c,[1538,99],c,[1940,3],793,c,[5973,6],288,382,288,c,[3209,17],797,798,100,c,[3233,4],801,c,[5879,21],804,c,[22,4],802,c,[5880,14],805,c,[3280,21],809,807,287,287,c,[5995,22],377,582,383,376,582,582,382,813,582,c,[27,15],812,371,381,s,[557,18],584,s,[557,67],583,s,[557,16],585,s,[557,5],s,[527,60],582,s,[527,48],814,815,287,287,599,598,100,818,819,c,[349,5],c,[277,18],s,[544,10],377,s,[544,5],383,544,544,376,544,544,382,813,544,370,s,[544,30],379,384,s,[544,27],380,544,544,c,[102,8],544,c,[103,3],s,[544,6],c,[359,3],822,c,[132,22],s,[535,18],584,s,[535,67],583,s,[535,16],585,s,[535,5],s,[536,18],584,s,[536,67],583,s,[536,16],585,s,[536,5],377,383,824,376,828,382,827,c,[243,15],826,c,[6624,21],c,[722,3],s,[517,18],584,s,[517,67],583,s,[517,16],585,s,[517,5],c,[4088,3],830,832,833,831,c,[6239,14],c,[6240,27],288,c,[6666,27],c,[6735,4],c,[1101,9],278,120,s,[278,3],c,[1103,34],278,133,836,837,838,s,[288,3],c,[6539,3],s,[637,4],100,841,100,100,627,c,[70,11],120,845,c,[1170,35],288,414,100,847,s,[626,4],100,849,850,100,637,287,852,c,[1426,128],596,c,[190,9],s,[596,4],120,s,[596,7],c,[200,5],596,c,[201,22],s,[596,9],119,s,[596,5],121,122,596,596,c,[102,4],s,[596,14],133,596,596,c,[3928,65],c,[625,3],858,382,857,c,[892,18],s,[479,10],861,s,[479,7],869,479,479,860,s,[479,58],865,868,s,[479,5],870,871,100,s,[479,6],864,100,230,c,[277,9],s,[230,4],120,s,[230,7],c,[277,5],230,c,[277,22],s,[230,9],119,s,[230,5],121,122,230,230,c,[224,4],s,[230,14],133,230,230,c,[277,5],s,[284,7],101,284,78,284,c,[286,5],284,62,63,s,[284,5],c,[291,4],s,[284,20],99,284,c,[312,3],284,c,[313,3],284,36,284,c,[315,3],284,284,c,[317,8],284,86,284,88,284,c,[320,14],284,c,[321,11],234,c,[199,9],s,[234,4],120,s,[234,7],c,[199,5],234,c,[199,22],s,[234,9],119,s,[234,5],121,122,234,234,c,[106,4],s,[234,14],133,234,c,[89,10],874,c,[14345,36],c,[2336,37],875,c,[46,17],c,[14289,31],877,c,[49,48],879,c,[49,8],s,[252,40],881,882,883,c,[6435,79],c,[171,9],146,146,c,[268,28],146,c,[170,8],667,885,c,[5941,73],c,[6009,129],451,448,891,450,c,[4,4],c,[6568,76],183,183,c,[2564,40],c,[3972,70],s,[190,3],532,s,[190,3],s,[191,3],532,s,[191,3],s,[192,3],532,s,[192,3],s,[193,3],532,s,[193,3],667,896,216,c,[153,9],s,[216,4],120,s,[216,7],125,126,216,130,216,216,c,[163,8],216,148,216,c,[121,6],216,216,c,[163,3],s,[216,19],69,70,s,[216,16],133,216,216,c,[308,66],s,[121,10],692,s,[121,9],691,s,[121,30],690,121,900,s,[121,36],c,[788,64],692,691,690,904,903,c,[69,12],905,c,[4211,28],c,[72,13],c,[17654,22],c,[139,16],c,[69,47],473,s,[21,9],s,[473,4],c,[5,3],177,c,[8,5],c,[17,5],s,[21,22],s,[473,4],174,c,[45,7],c,[43,5],c,[47,6],473,473,173,179,473,473,178,473,110,114,c,[28,6],461,s,[474,12],913,s,[474,77],c,[12773,97],s,[140,52],389,c,[5,9],s,[140,31],c,[3429,3],916,c,[738,24],918,c,[17252,108],114,c,[961,9],s,[114,4],120,s,[114,7],c,[1123,5],114,c,[1124,22],s,[114,9],119,s,[114,5],121,122,114,114,c,[102,4],s,[114,14],133,114,114,922,115,923,c,[159,66],c,[6473,5],c,[5,5],108,c,[169,9],s,[108,4],120,s,[108,7],125,126,108,130,108,108,c,[169,8],108,148,108,c,[169,6],108,108,c,[169,3],s,[108,37],133,108,c,[89,10],415,415,120,s,[415,4],c,[1376,27],415,c,[1921,17],417,417,120,s,[417,4],c,[52,27],417,c,[52,17],424,424,120,s,[424,5],c,[53,27],424,c,[53,7],424,133,424,928,s,[425,8],930,478,479,288,288,c,[15196,4],932,933,244,320,320,245,s,[320,3],936,243,241,478,479,c,[1165,64],938,939,c,[15276,3],453,561,c,[355,3],942,118,c,[163,9],s,[118,4],120,s,[118,7],c,[167,5],118,c,[168,22],s,[118,9],119,s,[118,5],121,122,118,118,c,[113,4],s,[118,14],133,c,[31,3],s,[119,64],116,117,s,[119,23],c,[9836,11],943,c,[1818,35],401,c,[48,9],s,[401,4],120,s,[401,7],c,[57,5],401,c,[58,22],s,[401,9],119,s,[401,5],121,122,401,401,c,[74,4],s,[401,14],133,401,401,505,944,c,[6870,3],945,179,s,[363,75],389,s,[363,68],s,[366,68],384,s,[366,74],c,[3086,109],c,[492,9],950,120,c,[6460,36],951,c,[22125,3],246,c,[52,9],s,[246,4],120,s,[246,7],c,[61,5],246,c,[62,22],s,[246,9],119,s,[246,5],121,122,246,246,c,[78,4],s,[246,14],133,246,246,s,[247,65],116,117,s,[247,23],c,[15060,73],s,[95,27],532,s,[95,62],c,[4084,71],c,[14134,64],c,[71,71],957,759,760,c,[551,9],303,303,120,s,[303,3],c,[5528,47],c,[4125,53],c,[115,9],306,306,120,s,[306,3],c,[115,100],960,375,c,[117,9],s,[375,4],120,s,[375,7],c,[123,5],375,c,[124,22],s,[375,9],119,s,[375,5],121,122,375,375,c,[103,4],s,[375,14],133,375,375,s,[376,65],116,117,s,[376,23],c,[246,8],454,c,[247,4],454,c,[622,58],c,[13833,66],c,[66,60],963,c,[819,64],166,c,[443,9],s,[166,4],120,s,[166,7],125,126,166,130,166,166,c,[443,8],166,148,166,c,[443,6],166,166,c,[443,3],s,[166,19],69,70,s,[166,16],133,166,166,167,c,[90,9],s,[167,4],120,s,[167,7],125,126,167,130,167,167,c,[90,8],167,148,167,c,[90,6],167,167,c,[90,3],s,[167,19],69,70,s,[167,16],133,167,167,c,[4263,70],c,[6503,53],c,[2120,10],c,[6501,36],c,[12303,42],c,[3050,3],969,c,[46,24],c,[5749,7],971,c,[5750,36],s,[542,18],584,s,[542,67],583,s,[542,16],585,s,[542,5],973,974,c,[6655,21],c,[5258,3],809,287,287,976,s,[559,18],584,s,[559,67],583,s,[559,16],585,s,[559,5],c,[270,22],599,288,288,598,100,979,980,c,[6455,3],981,377,573,573,383,376,983,382,984,573,c,[173,18],985,986,s,[543,10],377,s,[543,5],383,543,543,376,543,543,382,813,543,370,s,[543,30],379,384,s,[543,27],380,543,543,c,[104,8],543,c,[105,3],s,[543,6],c,[6457,3],c,[6456,22],s,[546,10],377,s,[546,5],383,546,546,376,546,546,382,813,546,370,s,[546,30],379,384,s,[546,27],380,546,546,c,[102,8],546,c,[103,3],s,[546,6],c,[131,3],s,[519,18],584,s,[519,67],583,s,[519,16],585,s,[519,5],c,[411,22],c,[22,19],990,c,[750,8],991,c,[6500,18],c,[13024,65],c,[65,65],832,833,994,995,c,[6367,3],100,838,998,414,100,100,1001,c,[12677,3],1002,c,[3156,11],1003,c,[1037,35],s,[514,10],377,s,[514,5],383,514,514,376,514,514,382,813,514,370,s,[514,30],379,384,s,[514,27],380,514,514,c,[297,8],514,c,[298,3],s,[514,6],c,[613,22],c,[373,22],c,[22,3],s,[469,12],1007,s,[469,77],861,c,[6273,3],1010,c,[6215,3],c,[6210,3],864,1011,869,1013,c,[9,6],s,[484,12],1014,s,[484,77],1018,1017,100,388,361,100,s,[505,15],1023,s,[505,36],388,505,505,361,s,[505,35],1024,1026,100,s,[472,12],913,s,[472,84],c,[10254,10],s,[231,4],120,s,[231,7],c,[608,5],231,c,[6080,23],s,[231,8],119,s,[231,5],121,122,231,231,c,[625,4],s,[231,14],133,231,231,c,[21995,199],c,[11336,125],c,[2171,58],667,1035,c,[1072,10],177,177,c,[6046,110],c,[122,10],180,180,c,[122,35],185,185,531,1036,214,c,[52,9],s,[214,4],120,s,[214,7],125,126,214,130,214,214,c,[62,8],214,148,214,c,[62,6],214,214,c,[62,3],s,[214,19],69,70,s,[214,16],133,214,214,c,[5847,3],c,[5706,90],c,[480,12],1039,c,[5866,57],1042,1041,s,[11,3],116,117,c,[259,9],12,120,12,12,c,[312,35],1043,1042,s,[130,10],692,s,[130,9],691,s,[130,30],690,130,1045,s,[130,36],288,100,1047,1048,c,[767,66],110,c,[211,9],s,[110,4],120,s,[110,7],c,[219,5],110,c,[220,22],s,[110,9],119,s,[110,5],121,122,110,110,c,[102,4],s,[110,14],133,110,110,115,c,[90,9],s,[115,4],120,s,[115,7],c,[90,5],115,c,[90,22],s,[115,9],119,s,[115,5],121,122,115,115,c,[90,4],s,[115,14],133,115,115,1051,107,c,[91,9],s,[107,4],120,s,[107,7],125,126,107,130,107,107,c,[91,8],107,148,107,c,[91,6],107,107,c,[91,3],s,[107,37],133,107,107,c,[8503,3],c,[15162,39],c,[339,26],c,[5483,4],c,[4,4],c,[72,64],s,[326,5],484,483,c,[236,9],324,324,120,s,[324,3],c,[630,35],244,245,454,c,[5886,4],330,c,[5887,4],242,c,[63,9],s,[242,4],120,s,[242,7],c,[69,5],242,c,[70,22],s,[242,9],119,s,[242,5],121,122,242,242,c,[86,4],s,[242,14],133,242,242,s,[243,65],116,117,s,[243,23],c,[179,9],1058,c,[4991,37],1059,c,[4991,3],49,c,[52,4],49,155,156,s,[49,6],120,s,[49,8],126,49,130,49,49,c,[62,8],49,148,49,c,[62,6],s,[49,4],164,s,[49,37],133,49,49,c,[11162,3],1060,c,[2520,11],1061,c,[8133,45],10,1062,c,[1495,40],c,[965,7],1064,c,[965,53],c,[10687,4],1067,c,[8107,122],1070,1071,c,[3757,3],1072,c,[2986,6],1073,c,[9486,37],c,[10160,4],c,[2704,22],585,383,376,585,585,382,813,585,c,[10182,18],1076,c,[97,6],1077,c,[97,18],c,[9986,3],c,[3,3],1080,377,570,570,383,376,570,382,813,570,c,[60,18],c,[131,45],c,[22,21],1084,s,[545,10],377,s,[545,5],383,545,545,376,545,545,382,813,545,370,s,[545,30],379,384,s,[545,27],380,545,545,c,[103,8],545,c,[104,3],s,[545,6],c,[176,6],c,[235,3],1085,c,[235,18],s,[522,18],584,s,[522,67],583,s,[522,16],585,s,[522,5],1086,c,[9721,4],1088,1089,c,[141,6],1090,c,[141,18],s,[516,10],377,s,[516,5],383,516,516,376,516,c,[43,3],516,370,s,[516,30],379,384,s,[516,27],380,516,516,c,[102,8],516,c,[103,3],s,[516,6],c,[109,3],1091,1007,287,1092,1014,484,287,1093,869,c,[3124,6],1095,1014,287,287,c,[11,7],1098,869,288,288,c,[10,6],1099,1100,c,[3051,52],s,[505,38],1102,1104,100,384,388,361,c,[16848,4],1110,382,1109,c,[588,37],c,[22,3],1112,1113,c,[9074,40],1115,c,[9123,48],1117,c,[49,8],157,c,[50,9],s,[157,4],120,s,[157,7],125,126,157,130,157,157,c,[60,8],157,148,157,c,[60,6],157,157,c,[60,3],s,[157,19],69,70,s,[157,16],133,157,157,158,c,[90,9],s,[158,4],120,s,[158,7],125,126,158,130,158,158,c,[90,8],158,148,158,c,[150,7],158,c,[90,3],s,[158,19],69,70,s,[158,16],133,158,c,[89,10],c,[229,31],1118,c,[11421,72],1121,s,[129,10],692,s,[129,9],691,s,[129,30],690,129,1123,s,[129,36],1124,1042,1125,c,[158,6],7,78,102,7,c,[160,4],7,c,[2662,57],c,[2825,3],100,111,c,[284,9],s,[111,4],120,s,[111,7],c,[293,5],111,c,[294,22],s,[111,9],119,s,[111,5],121,122,111,111,c,[109,4],s,[111,14],133,111,111,710,711,1129,c,[92,9],426,426,120,s,[426,5],c,[381,27],426,c,[380,7],426,133,426,1130,c,[56,9],321,321,120,s,[321,3],c,[1796,44],309,309,120,s,[309,3],c,[6261,100],1132,c,[549,64],168,c,[181,9],s,[168,4],120,s,[168,7],125,126,168,130,168,168,c,[188,8],168,148,168,c,[188,6],168,168,c,[188,3],s,[168,19],69,70,s,[168,16],133,168,168,1134,1135,377,583,383,376,583,583,382,813,583,c,[1693,21],c,[1333,3],1136,c,[1376,18],c,[5286,3],1137,377,571,571,383,376,571,382,813,571,c,[56,24],1138,c,[1905,21],1139,c,[11416,24],1141,382,1142,c,[1191,18],832,833,1143,c,[10794,21],1010,c,[10794,75],c,[1456,3],1093,c,[4,3],1145,c,[1461,7],1148,c,[8,7],1150,c,[8,7],c,[1344,22],1152,1153,c,[1489,90],384,c,[91,90],s,[506,10],377,s,[506,5],383,506,506,376,506,506,382,813,506,370,s,[506,30],379,384,s,[506,27],380,506,506,c,[285,8],506,c,[286,3],s,[506,6],c,[5081,44],c,[336,3],s,[502,10],377,s,[502,5],383,502,502,376,502,502,382,813,502,370,s,[502,30],379,384,s,[502,27],380,502,502,c,[102,8],502,c,[103,3],s,[502,6],c,[153,3],c,[352,90],1160,c,[4665,137],c,[10653,70],c,[1798,31],1167,c,[1315,8],c,[1568,3],1170,c,[3165,11],1171,c,[1366,35],165,c,[48,9],s,[165,4],120,s,[165,7],125,126,165,130,165,165,c,[58,8],165,148,165,c,[58,6],165,165,c,[58,3],s,[165,19],69,70,s,[165,16],133,165,165,1172,377,577,577,383,376,577,382,813,577,c,[2928,62],s,[481,12],1007,s,[481,77],1175,1176,c,[2597,10],c,[10,3],1178,869,1180,c,[12,6],s,[495,10],377,s,[495,5],383,495,495,376,495,495,382,813,495,370,s,[495,30],379,384,s,[495,27],380,495,495,c,[216,8],495,c,[217,3],s,[495,6],c,[774,93],1182,c,[91,90],c,[1627,6],1184,c,[1602,18],s,[508,10],377,s,[508,5],383,508,508,376,508,508,382,813,508,370,s,[508,30],379,384,s,[508,27],380,508,508,c,[102,8],508,c,[103,3],s,[508,6],c,[1242,25],149,c,[722,9],s,[149,4],120,s,[149,7],125,126,149,130,149,149,c,[722,8],149,c,[780,8],149,149,c,[722,3],s,[149,19],69,70,s,[149,16],133,149,149,152,c,[90,9],s,[152,4],120,s,[152,7],125,126,152,130,152,152,c,[90,8],152,148,152,c,[90,6],152,152,c,[90,3],s,[152,19],69,70,s,[152,16],133,152,152,159,c,[90,9],s,[159,4],120,s,[159,7],125,126,159,130,159,159,c,[90,8],159,148,159,c,[90,6],159,c,[960,4],s,[159,19],69,70,s,[159,16],133,159,159,c,[1158,66],c,[358,3],1189,382,1190,c,[942,19],578,578,383,376,578,382,813,578,c,[2170,24],1191,c,[543,18],1192,c,[871,3],1193,c,[885,10],c,[1691,23],1196,c,[7874,9],c,[62,14],162,c,[294,9],s,[162,4],120,s,[162,7],125,126,162,130,162,162,c,[294,8],162,148,162,c,[294,6],162,162,c,[294,3],s,[162,19],69,70,s,[162,16],133,162,162,377,574,574,383,376,574,382,813,574,c,[1195,62],1199,c,[219,3],1200,377,1201,c,[191,23],1202,377,575,575,383,376,575,382,813,575,c,[306,24],1203,c,[53,18],1204,1205,c,[966,90],1207,c,[91,90]])}),defaultActions:bda({idx:u([3,6,9,10,11,s,[14,9,1],s,[24,4,1],s,[46,8,1],s,[64,9,1],75,76,77,s,[79,7,1],89,s,[91,8,1],100,s,[103,9,1],113,123,125,126,131,s,[134,13,1],148,s,[150,15,1],166,167,172,175,176,187,190,191,194,195,196,199,202,230,236,237,238,246,250,251,252,254,256,257,259,260,261,273,277,283,287,288,299,300,301,304,306,317,s,[320,4,1],326,332,334,336,354,356,357,363,s,[367,9,1],385,387,390,402,413,422,426,441,447,453,455,465,468,470,478,479,481,483,487,488,492,494,495,498,502,503,504,507,514,515,517,519,522,525,530,542,s,[544,4,1],550,555,558,560,562,563,565,574,575,576,590,592,593,596,597,609,610,612,616,s,[618,4,1],623,624,625,632,634,635,636,642,645,648,649,653,666,669,673,675,682,684,688,695,699,701,706,707,709,712,719,723,729,s,[735,5,1],742,743,744,746,748,755,758,761,765,767,769,772,773,774,777,778,783,784,789,791,s,[793,4,1],799,802,805,807,812,814,824,826,830,831,834,837,839,840,842,843,845,846,848,850,851,853,863,870,871,876,878,881,882,s,[883,4,2],890,892,894,897,899,902,903,905,907,910,915,917,s,[920,6,2],931,934,938,939,940,s,[943,5,1],950,951,955,957,962,967,969,971,978,990,992,995,996,997,s,[999,5,1],1007,1011,1022,1029,1031,1036,1037,1041,1043,1044,1046,1048,1049,1051,1054,s,[1057,6,1],1065,1067,1070,1071,1076,1077,1078,1080,1085,1086,1088,1089,1090,1092,1093,1095,1097,1101,1114,1116,1119,1121,1122,1124,s,[1126,5,1],1132,s,[1134,5,1],1143,1147,1154,1156,1159,1161,1163,1166,s,[1168,4,1],1175,1176,1178,1181,1183,1184,1187,1191,1192,1199,1203,1206,1207,1208]),goto:u([5,456,461,462,463,467,468,s,[14,7,1],s,[22,4,1],s,[253,8,1],46,398,588,589,590,s,[222,4,1],406,407,408,s,[327,7,1],283,s,[52,8,1],420,334,335,345,346,359,236,237,336,337,361,27,39,40,45,s,[60,13,1],74,s,[76,15,1],457,459,409,263,266,609,613,615,632,633,362,591,511,116,393,397,413,117,403,404,405,340,344,198,226,227,228,220,209,269,360,379,73,75,289,292,302,352,355,356,357,435,441,348,351,3,48,93,94,550,524,525,526,528,529,s,[531,4,1],430,270,273,634,623,513,232,175,187,219,210,142,97,98,411,412,423,422,419,297,432,438,445,120,402,338,341,238,284,285,267,281,383,368,250,318,353,354,358,387,373,452,448,454,347,349,339,465,261,264,558,530,562,565,569,518,391,431,279,s,[601,4,1],617,608,618,610,614,616,621,592,587,598,512,229,172,179,182,184,215,212,124,477,141,112,100,102,394,106,418,323,446,343,241,34,36,38,282,377,381,365,370,251,290,293,304,314,307,313,385,374,436,442,455,350,199,207,389,262,265,551,555,547,541,580,560,563,537,520,392,271,274,619,635,638,640,641,612,624,627,630,631,593,486,509,510,153,154,194,195,196,171,176,178,188,189,181,213,122,125,133,134,8,13,478,104,113,99,105,395,428,427,298,319,325,433,439,400,342,286,268,367,244,245,294,291,444,552,548,539,566,523,275,605,636,639,625,628,622,594,597,288,480,501,155,156,174,123,136,138,128,475,390,109,101,299,440,248,249,295,305,308,311,437,201,553,581,561,567,564,521,538,272,620,515,470,485,482,487,494,147,150,161,173,126,135,6,131,476,396,300,443,549,540,584,568,572,276,488,498,500,503,148,151,160,164,127,137,310,483,490,489,496,499,507,163,579,491,492,576,504,493,497])}),parseError:function parseError(str,hash,ExceptionClass){if(hash.recoverable){if(typeof this.trace==='function'){this.trace(str);}hash.destroy();// destroy... well, *almost*!
}else{if(typeof this.trace==='function'){this.trace(str);}if(!ExceptionClass){ExceptionClass=this.JisonParserError;}throw new ExceptionClass(str,hash);}},parse:function parse(input){var self=this;var stack=new Array(128);// token stack: stores token which leads to state at the same index (column storage)
var sstack=new Array(128);// state stack: stores states (column storage)
var vstack=new Array(128);// semantic value stack
var lstack=new Array(128);// location stack
var table=this.table;var sp=0;// 'stack pointer': index into the stacks
var yyloc;var symbol=0;var TERROR=this.TERROR;var EOF=this.EOF;var ERROR_RECOVERY_TOKEN_DISCARD_COUNT=this.options.errorRecoveryTokenDiscardCount|0||3;var NO_ACTION=[0,1209/* === table.length :: ensures that anyone using this new state will fail dramatically! */];var lexer;if(this.__lexer__){lexer=this.__lexer__;}else{lexer=this.__lexer__=Object.create(this.lexer);}var sharedState_yy={parseError:undefined,quoteName:undefined,lexer:undefined,parser:undefined,pre_parse:undefined,post_parse:undefined,pre_lex:undefined,post_lex:undefined// WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
};var ASSERT;if(typeof assert!=='function'){ASSERT=function JisonAssert(cond,msg){if(!cond){throw new Error('assertion failed: '+(msg||'***'));}};}else{ASSERT=assert;}this.yyGetSharedState=function yyGetSharedState(){return sharedState_yy;};// shallow clone objects, straight copy of simple `src` values
// e.g. `lexer.yytext` MAY be a complex value object,
// rather than a simple string/value.
function shallow_copy(src){if(typeof src==='object'){var dst={};for(var k in src){if(Object.prototype.hasOwnProperty.call(src,k)){dst[k]=src[k];}}return dst;}return src;}function shallow_copy_noclobber(dst,src){for(var k in src){if(typeof dst[k]==='undefined'&&Object.prototype.hasOwnProperty.call(src,k)){dst[k]=src[k];}}}function copy_yylloc(loc){var rv=shallow_copy(loc);if(rv&&rv.range){rv.range=rv.range.slice(0);}return rv;}// copy state
shallow_copy_noclobber(sharedState_yy,this.yy);sharedState_yy.lexer=lexer;sharedState_yy.parser=this;// Does the shared state override the default `parseError` that already comes with this instance?
if(typeof sharedState_yy.parseError==='function'){this.parseError=function parseErrorAlt(str,hash,ExceptionClass){if(!ExceptionClass){ExceptionClass=this.JisonParserError;}return sharedState_yy.parseError.call(this,str,hash,ExceptionClass);};}else{this.parseError=this.originalParseError;}// Does the shared state override the default `quoteName` that already comes with this instance?
if(typeof sharedState_yy.quoteName==='function'){this.quoteName=function quoteNameAlt(id_str){return sharedState_yy.quoteName.call(this,id_str);};}else{this.quoteName=this.originalQuoteName;}// set up the cleanup function; make it an API so that external code can re-use this one in case of
// calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
// case this parse() API method doesn't come with a `finally { ... }` block any more!
//
// NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
//       or else your `sharedState`, etc. references will be *wrong*!
this.cleanupAfterParse=function parser_cleanupAfterParse(resultValue,invoke_post_methods,do_not_nuke_errorinfos){var rv;if(invoke_post_methods){var hash;if(sharedState_yy.post_parse||this.post_parse){// create an error hash info instance: we re-use this API in a **non-error situation**
// as this one delivers all parser internals ready for access by userland code.
hash=this.constructParseErrorInfo(null/* no error! */,null/* no exception! */,null,false);}if(sharedState_yy.post_parse){rv=sharedState_yy.post_parse.call(this,sharedState_yy,resultValue,hash);if(typeof rv!=='undefined')resultValue=rv;}if(this.post_parse){rv=this.post_parse.call(this,sharedState_yy,resultValue,hash);if(typeof rv!=='undefined')resultValue=rv;}// cleanup:
if(hash&&hash.destroy){hash.destroy();}}// clean up the lingering lexer structures as well:
if(lexer.cleanupAfterLex){lexer.cleanupAfterLex(do_not_nuke_errorinfos);}// prevent lingering circular references from causing memory leaks:
if(sharedState_yy){sharedState_yy.lexer=undefined;sharedState_yy.parser=undefined;if(lexer.yy===sharedState_yy){lexer.yy=undefined;}}sharedState_yy=undefined;this.parseError=this.originalParseError;this.quoteName=this.originalQuoteName;// nuke the vstack[] array at least as that one will still reference obsoleted user values.
// To be safe, we nuke the other internal stack columns as well...
stack.length=0;// fastest way to nuke an array without overly bothering the GC
sstack.length=0;lstack.length=0;vstack.length=0;sp=0;// nuke the error hash info instances created during this run.
// Userland code must COPY any data/references
// in the error hash instance(s) it is more permanently interested in.
if(!do_not_nuke_errorinfos){for(var i=this.__error_infos.length-1;i>=0;i--){var el=this.__error_infos[i];if(el&&typeof el.destroy==='function'){el.destroy();}}this.__error_infos.length=0;}return resultValue;};// merge yylloc info into a new yylloc instance.
//
// `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.
//
// `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which
// case these override the corresponding first/last indexes.
//
// `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search
// through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)
// yylloc info.
//
// Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.
this.yyMergeLocationInfo=function parser_yyMergeLocationInfo(first_index,last_index,first_yylloc,last_yylloc,dont_look_back){var i1=first_index|0,i2=last_index|0;var l1=first_yylloc,l2=last_yylloc;var rv;// rules:
// - first/last yylloc entries override first/last indexes
if(!l1){if(first_index!=null){for(var i=i1;i<=i2;i++){l1=lstack[i];if(l1){break;}}}}if(!l2){if(last_index!=null){for(var i=i2;i>=i1;i--){l2=lstack[i];if(l2){break;}}}}// - detect if an epsilon rule is being processed and act accordingly:
if(!l1&&first_index==null){// epsilon rule span merger. With optional look-ahead in l2.
if(!dont_look_back){for(var i=(i1||sp)-1;i>=0;i--){l1=lstack[i];if(l1){break;}}}if(!l1){if(!l2){// when we still don't have any valid yylloc info, we're looking at an epsilon rule
// without look-ahead and no preceding terms and/or `dont_look_back` set:
// in that case we ca do nothing but return NULL/UNDEFINED:
return undefined;}else{// shallow-copy L2: after all, we MAY be looking
// at unconventional yylloc info objects...
rv=shallow_copy(l2);if(rv.range){// shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
rv.range=rv.range.slice(0);}return rv;}}else{// shallow-copy L1, then adjust first col/row 1 column past the end.
rv=shallow_copy(l1);rv.first_line=rv.last_line;rv.first_column=rv.last_column;if(rv.range){// shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
rv.range=rv.range.slice(0);rv.range[0]=rv.range[1];}if(l2){// shallow-mixin L2, then adjust last col/row accordingly.
shallow_copy_noclobber(rv,l2);rv.last_line=l2.last_line;rv.last_column=l2.last_column;if(rv.range&&l2.range){rv.range[1]=l2.range[1];}}return rv;}}if(!l1){l1=l2;l2=null;}if(!l1){return undefined;}// shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking
// at unconventional yylloc info objects...
rv=shallow_copy(l1);// first_line: ...,
// first_column: ...,
// last_line: ...,
// last_column: ...,
if(rv.range){// shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
rv.range=rv.range.slice(0);}if(l2){shallow_copy_noclobber(rv,l2);rv.last_line=l2.last_line;rv.last_column=l2.last_column;if(rv.range&&l2.range){rv.range[1]=l2.range[1];}}return rv;};// NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
//       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
this.constructParseErrorInfo=function parser_constructParseErrorInfo(msg,ex,expected,recoverable){var pei={errStr:msg,exception:ex,text:lexer.match,value:lexer.yytext,token:this.describeSymbol(symbol)||symbol,token_id:symbol,line:lexer.yylineno,loc:copy_yylloc(lexer.yylloc),expected:expected,recoverable:recoverable,state:state,action:action,new_state:newState,symbol_stack:stack,state_stack:sstack,value_stack:vstack,location_stack:lstack,stack_pointer:sp,yy:sharedState_yy,lexer:lexer,parser:this,// and make sure the error info doesn't stay due to potential
// ref cycle via userland code manipulations.
// These would otherwise all be memory leak opportunities!
//
// Note that only array and object references are nuked as those
// constitute the set of elements which can produce a cyclic ref.
// The rest of the members is kept intact as they are harmless.
destroy:function destructParseErrorInfo(){// remove cyclic references added to error info:
// info.yy = null;
// info.lexer = null;
// info.value = null;
// info.value_stack = null;
// ...
var rec=!!this.recoverable;for(var key in this){if(this.hasOwnProperty(key)&&typeof key==='object'){this[key]=undefined;}}this.recoverable=rec;}};// track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
this.__error_infos.push(pei);return pei;};function getNonTerminalFromCode(symbol){var tokenName=self.getSymbolName(symbol);if(!tokenName){tokenName=symbol;}return tokenName;}function stdLex(){var token=lexer.lex();// if token isn't its numeric value, convert
if(typeof token!=='number'){token=self.symbols_[token]||token;}return token||EOF;}function fastLex(){var token=lexer.fastLex();// if token isn't its numeric value, convert
if(typeof token!=='number'){token=self.symbols_[token]||token;}return token||EOF;}var lex=stdLex;var state,action,r,t;var yyval={$:true,_$:undefined,yy:sharedState_yy};var p;var yyrulelen;var this_production;var newState;var retval=false;lexer.setInput(input,sharedState_yy);// NOTE: we *assume* no lexer pre/post handlers are set up *after* 
// this initial `setInput()` call: hence we can now check and decide
// whether we'll go with the standard, slower, lex() API or the
// `fast_lex()` one:
if(typeof lexer.canIUse==='function'){var lexerInfo=lexer.canIUse();if(lexerInfo.fastLex&&typeof fastLex==='function'){lex=fastLex;}}yyloc=lexer.yylloc;lstack[sp]=yyloc;vstack[sp]=null;sstack[sp]=0;stack[sp]=0;++sp;if(this.pre_parse){this.pre_parse.call(this,sharedState_yy);}if(sharedState_yy.pre_parse){sharedState_yy.pre_parse.call(this,sharedState_yy);}newState=sstack[sp-1];for(;;){// retrieve state number from top of stack
state=newState;// sstack[sp - 1];
// use default actions if available
if(this.defaultActions[state]){action=2;newState=this.defaultActions[state];}else{// The single `==` condition below covers both these `===` comparisons in a single
// operation:
//
//     if (symbol === null || typeof symbol === 'undefined') ...
if(!symbol){symbol=lex();}// read action for current state and first input
t=table[state]&&table[state][symbol]||NO_ACTION;newState=t[1];action=t[0];// handle parse error
if(!action){var errStr;var errSymbolDescr=this.describeSymbol(symbol)||symbol;var expected=this.collect_expected_token_set(state);// Report error
if(typeof lexer.yylineno==='number'){errStr='Parse error on line '+(lexer.yylineno+1)+': ';}else{errStr='Parse error: ';}if(typeof lexer.showPosition==='function'){errStr+='\n'+lexer.showPosition(79-10,10)+'\n';}if(expected.length){errStr+='Expecting '+expected.join(', ')+', got unexpected '+errSymbolDescr;}else{errStr+='Unexpected '+errSymbolDescr;}// we cannot recover from the error!
p=this.constructParseErrorInfo(errStr,null,expected,false);r=this.parseError(p.errStr,p,this.JisonParserError);if(typeof r!=='undefined'){retval=r;}break;}}switch(action){// catch misc. parse failures:
default:// this shouldn't happen, unless resolve defaults are off
if(action instanceof Array){p=this.constructParseErrorInfo('Parse Error: multiple actions possible at state: '+state+', token: '+symbol,null,null,false);r=this.parseError(p.errStr,p,this.JisonParserError);if(typeof r!=='undefined'){retval=r;}break;}// Another case of better safe than sorry: in case state transitions come out of another error recovery process
// or a buggy LUT (LookUp Table):
p=this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.',null,null,false);r=this.parseError(p.errStr,p,this.JisonParserError);if(typeof r!=='undefined'){retval=r;}break;// shift:
case 1:stack[sp]=symbol;vstack[sp]=lexer.yytext;lstack[sp]=copy_yylloc(lexer.yylloc);sstack[sp]=newState;// push state
++sp;symbol=0;// Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:
yyloc=lexer.yylloc;continue;// reduce:
case 2:this_production=this.productions_[newState-1];// `this.productions_[]` is zero-based indexed while states start from 1 upwards...
yyrulelen=this_production[1];r=this.performAction.call(yyval,yyloc,newState,sp-1,vstack,lstack);if(typeof r!=='undefined'){retval=r;break;}// pop off stack
sp-=yyrulelen;// don't overwrite the `symbol` variable: use a local var to speed things up:
var ntsymbol=this_production[0];// push nonterminal (reduce)
stack[sp]=ntsymbol;vstack[sp]=yyval.$;lstack[sp]=yyval._$;// goto new state = table[STATE][NONTERMINAL]
newState=table[sstack[sp-1]][ntsymbol];sstack[sp]=newState;++sp;continue;// accept:
case 3:if(sp!==-2){retval=true;// Return the `$accept` rule's `$$` result, if available.
//
// Also note that JISON always adds this top-most `$accept` rule (with implicit,
// default, action):
//
//     $accept: <startSymbol> $end
//                  %{ $$ = $1; @$ = @1; %}
//
// which, combined with the parse kernel's `$accept` state behaviour coded below,
// will produce the `$$` value output of the <startSymbol> rule as the parse result,
// IFF that result is *not* `undefined`. (See also the parser kernel code.)
//
// In code:
//
//                  %{
//                      @$ = @1;            // if location tracking support is included
//                      if (typeof $1 !== 'undefined')
//                          return $1;
//                      else
//                          return true;           // the default parse result if the rule actions don't produce anything
//                  %}
sp--;if(typeof vstack[sp]!=='undefined'){retval=vstack[sp];}}break;}// break out of loop: we accept or fail with error
break;}// ... AND FINALLY ...
retval=this.cleanupAfterParse(retval,true,true);return retval;}};parser.originalParseError=parser.parseError;parser.originalQuoteName=parser.quoteName;function Parser(){this.yy={};}Parser.prototype=parser;parser.Parser=Parser;return new Parser();}();if(typeof require!=='undefined'&&typeof exports!=='undefined'){exports.parser=Relic;exports.Parser=Relic.Parser;exports.parse=function(){return Relic.parse.apply(Relic,arguments);};}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Relic);

/***/ }),

/***/ "./lib/sourcemaps.js":
/*!***************************!*\
  !*** ./lib/sourcemaps.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SourceMap: () => (/* binding */ SourceMap),
/* harmony export */   Sources: () => (/* binding */ Sources)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "?a348");
let VLQ_SHIFT, VLQ_CONTINUATION_BIT, VLQ_VALUE_MASK, BASE64_CHARS;
VLQ_SHIFT = 5;
VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT; // 0010 0000

VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1; // 0001 1111


// Regular Base64 Encoding
// -----------------------
BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
class SourceMap {
  constructor(sources) {
    this.lines = {};
    this.names = [];
    this.sources = [];
    this.include(sources);
  }
  include(sources) {
    let base = this.lines;
    for (let source of sources) {
      if (!base[source.line]) {
        base[source.line] = {};
      }
      let line = base[source.line];
      line[source.column] = source;
      if (!this.sources.includes(source.source)) this.sources.push(source.source);
      if (!!source.sourceName && !this.names.includes(source.sourceName)) this.names.push(source.sourceName);
    }
  }
  generate(options, code = null) {
    let buffer = "",
      writingLine = 0,
      lastColumn = 0,
      lastSourceLine = 0,
      lastSourceColumn = 0,
      needComma = false,
      ref = this.lines;
    for (let lineNumber in ref) {
      let cols = ref[lineNumber];
      for (let col in cols) {
        let mapping = cols[col];
        while (writingLine < mapping.line) {
          lastColumn = 0;
          needComma = false;
          buffer += ";";
          writingLine++;
        }
        if (needComma) {
          buffer += ",";
          needComma = false;
        }
        buffer += this.encodeVlq(mapping.column - lastColumn);
        lastColumn = mapping.column;
        buffer += this.encodeVlq(this.sources.indexOf(mapping.source));
        buffer += this.encodeVlq(mapping.sourceLine - lastSourceLine);
        lastSourceLine = mapping.sourceLine;
        buffer += this.encodeVlq(mapping.sourceColumn - lastSourceColumn);
        lastSourceColumn = mapping.sourceColumn;
        if (mapping.sourceName) buffer += this.encodeVlq(this.names.indexOf(mapping.sourceName));
        needComma = true;
      }
    }
    let sources = this.sources;
    const v3 = {
      version: 3,
      file: options.generatedFile || '',
      sourceRoot: options.sourceRoot || '',
      sources,
      names: this.names || options.names || [],
      mappings: buffer
    };
    if (options.inlineMap) {
      v3.sourcesContent = [code];
    }
    return v3;
  }
  encodeVlq(value) {
    var answer, nextChunk, signBit, valueToEncode;
    answer = '';
    // Least significant bit represents the sign.
    signBit = value < 0 ? 1 : 0;
    // The next bits are the actual value.
    valueToEncode = (Math.abs(value) << 1) + signBit;
    // Make sure we encode at least one character, even if valueToEncode is 0.
    while (valueToEncode || !answer) {
      nextChunk = valueToEncode & VLQ_VALUE_MASK;
      valueToEncode = valueToEncode >> VLQ_SHIFT;
      if (valueToEncode) {
        nextChunk |= VLQ_CONTINUATION_BIT;
      }
      answer += this.encodeBase64(nextChunk);
    }
    return answer;
  }
  encodeBase64(value) {
    return BASE64_CHARS[value] || function () {
      throw new Error(`Cannot Base64 encode value: ${value}`);
    }();
  }
}
class Sources extends Array {
  constructor() {
    super();
    this.names = [];
  }
  add({
    first_line,
    first_column,
    last_line,
    last_column,
    src
  } = {}, name) {
    let hash = typeof crypto__WEBPACK_IMPORTED_MODULE_0__.randomBytes === "function" ? (0,crypto__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(9).toString('hex') : typeof window !== "undefined" ? ([1e7] + -1e3).replace(/[018]/g, function (c) {
      return (c ^ window.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16);
    }) : 'aa00ee11' + (this.length + Math.random());
    hash = `/*@${hash}*/`;
    this.push([hash, {
      first_line,
      first_column,
      source: src,
      sourceName: name,
      last_line,
      last_column
    }]);
    return hash;
  }
}

if (typeof module !== "undefined" && typeof require === "function") {
  module.exports = {
    SourceMap,
    Sources
  };
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;
//# sourceMappingURL=bundle.js.map